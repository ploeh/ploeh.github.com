I followed your article and got everything working except dependency inject (partially). In my project I am using unity and I am trying to create a custom Transaction attribute the purpose of which is to start an NHibernate transaction before the execution of an action and commit/rollback the transaction after the method execution.

This is the definition of my attribute:-

public class TransactionAttribute : Attribute
{
}

Following is the definition of my TransactionFilter

public class TransactionFilter : IActionFilter 
{
   private readonly IUnitOfWork _unitOfWork;
   
   public TransactionFilter(IUnitOfWork uow) {
      _unitOfWork = uow;
   }
   
   public Task<HttpResponseMessage> ExecuteActionFilterAsync(HttpActionContext actionContext, CancellationToken cancellationToken, Func<Task<HttpResponseMessage>> continuation) {
      var transAttribute = actionContext.ActionDescriptor.GetCustomAttributes<TransactionAttribute>().SingleOrDefault();
      if (transAttribute == null) {
         return continuation();
      }
      
      var transaction = repository.BeginTransaction();
      return continuation().ContinueWith(t => 
      {
         try{
            transaction.Commit();
            return t.Result;
         }
         catch(Exception e)
         {
             transaction.Rollback();
             return new ExceptionResult(ex, actionContext.ControllerContext.Controller as ApiController).ExecuteAsync(cancellationToken).Result;
         }
      }
   }
}

And I have created a custom filter provider which uses unity to construct this filter. 

The problem is everything works ok for the first request of any action  but subsequent requests for the same action doesn't recreate the TransactionFilter which means it doesn't call the constructor to assign a new UOW. I don't think I can disable the action filter caching.

The only option I have got now is to use the service locator pattern and get UOW instance using container inside ExecuteActionFilterAsync which in my opinion kills the purpose of this and I am better off implementing custom ActionFilterAttribute.

Any suggestions ?

