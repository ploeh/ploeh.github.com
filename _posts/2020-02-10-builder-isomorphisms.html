---
layout: post
title: "Builder isomorphisms"
description: "The Builder pattern is equivalent to the Fluent Builder pattern."
date: 2020-02-10 7:06 UTC
tags: [Software Design, Design Patterns]
image: "/content/binary/builder-fluent-builder-isomorphism.png"
image_alt: "isomorphism between Builder, Fluent Builder, and Immutable Fluent Builder."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		This article is part of <a href="/2018/01/08/software-design-isomorphisms">a series of articles about software design isomorphisms</a>. An isomorphism is when a bi-directional lossless translation exists between two representations. Such translations exist between the <a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder</a> pattern and two variations of the <em>Fluent Builder</em> pattern. Since the names sound similar, this is hardly surprising.
	</p>
	<p>
		<img src="/content/binary/builder-fluent-builder-isomorphism.png" alt="isomorphism between Builder, Fluent Builder, and Immutable Fluent Builder.">
	</p>
	<p>
		Given an implementation that uses one of those three patterns, you can translate your design into one of the other options. This doesn't imply that each is of equal value. When it comes to composability, both versions of Fluent Builder are superior to the classic Builder pattern.
	</p>
	<h3 id="553fdf908eb84ccb86a7c7972d45bc77">
		A critique of the Maze Builder example <a href="#553fdf908eb84ccb86a7c7972d45bc77" title="permalink">#</a>
	</h3>
	<p>
		In these articles, I usually first introduce the form presented in <a href="http://amzn.to/XBYukB">Design Patterns</a>. The code example given by the Gang of Four is, however, problematic. I'll start by pointing out the problems and then proceed to present a simpler, more useful example.
	</p>
	<p>
		The book presents an example centred on a <code>MazeBuilder</code> abstract class. The original example is in C++, but I here present my C# interpretation:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">abstract</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MazeBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">BuildMaze</span>()&nbsp;{&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">BuildRoom</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">room</span>)&nbsp;{&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">BuildDoor</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">roomFrom</span>,&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">roomTo</span>)&nbsp;{&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:#2b91af;">Maze</span>&nbsp;<span style="font-weight:bold;color:#74531f;">GetMaze</span>()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		As the book states, "the maze-building operations of MazeBuilder do nothing by default. They're not declared pure virtual to let derived classes override only those methods in which they're interested." This means that you could technically write a derived class that overrides only <code>BuildRoom</code>. That's unlikely to be useful, since <code>GetMaze</code> still returns <code>null</code>.
	</p>
	<p>
		Moreover, the presence of the <code>BuildMaze</code> method indicates <a href="https://en.wikipedia.org/wiki/Sequential_coupling">sequential coupling</a>. A client (a <em>Director</em>, in the pattern language of <em>Design Patterns</em>) is supposed to first call <code>BuildMaze</code> before calling any of the other methods. What happens if a client forgets to call <code>BuildMaze</code>? What happens if client code calls the method <em>after</em> some of the other methods. What happens if it calls it multiple times?
	</p>
	<p>
		Another issue with the sample code is that it's unclear how it accomplishes its stated goal of separating "the construction of a complex object from its representation." The <code>StandardMazeBuilder</code> presented seems tightly coupled to the <code>Maze</code> class to a degree where it's hard to see how to untangle the two. The book fails to make a compelling example by instead presenting a <code>CountingMazeBuilder</code> that never implements <code>GetMaze</code>. It never constructs the desired complex object.
	</p>
	<p>
		Don't interpret this critique as a sweeping dismissal of the pattern, or the book in general. As this article series implies, I've invested significant energy in it. I consider the book seminal, but we've learned much since its publication in 1994. A common experience is that not all of the patterns in the book are equally useful, and of those that are, some are useful for different reasons than the book gives. The Builder pattern is an example of that.
	</p>
	<p>
		The Builder pattern isn't useful only because it enables you to "separate the construction of a complex object from its representation." It's useful because it enables you to present an API that comes with good default behaviour, but which can be tweaked into multiple configurations. The pattern is useful even without polymorphism.
	</p>
	<h3 id="ed99bc3715f541be8b6b9239848395e3">
		HTTP request Builder <a href="#ed99bc3715f541be8b6b9239848395e3" title="permalink">#</a>
	</h3>
	<p>
		The <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httprequestmessage">HttpRequestMessage</a> class is a versatile API with good default behaviour, but it can be a bit awkward if you want to make an HTTP request with a body and particular headers. You can often get around the problem by using methods like <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient.postasync">PostAsync</a> on <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient">HttpClient</a>, but sometimes you need to drop down to <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient.sendasync">SendAsync</a>. When that happens, you need to build your own <code>HttpRequestMessage</code> objects. A Builder can encapsulate some of that work.
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">Uri</span>&nbsp;url;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">object</span>?&nbsp;jsonBody;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">url</span>)&nbsp;:&nbsp;<span style="color:blue;">this</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Uri</span>(<span style="font-weight:bold;color:#1f377f;">url</span>))&nbsp;{&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="color:#2b91af;">Uri</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">url</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.url&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">url</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;=&nbsp;<span style="color:#2b91af;">HttpMethod</span>.Get;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpMethod</span>&nbsp;Method&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;<span style="color:blue;">set</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">AddJsonBody</span>(<span style="color:blue;">object</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">jsonBody</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.jsonBody&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">jsonBody</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Build</span>()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">message</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessage</span>(Method,&nbsp;url);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#74531f;">BuildBody</span>(<span style="font-weight:bold;color:#1f377f;">message</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">message</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">BuildBody</span>(<span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">message</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(jsonBody&nbsp;<span style="color:blue;">is</span>&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">json</span>&nbsp;=&nbsp;<span style="color:#2b91af;">JsonConvert</span>.<span style="color:#74531f;">SerializeObject</span>(jsonBody);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">message</span>.Content&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">StringContent</span>(<span style="font-weight:bold;color:#1f377f;">json</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">message</span>.Content.Headers.ContentType.MediaType&nbsp;=&nbsp;<span style="color:#a31515;">&quot;application/json&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		Compared to <em>Design Patterns'</em> example, <code>HttpRequestMessageBuilder</code> isn't polymorphic. It doesn't inherit from a base class or implement an interface. As I pointed out in my critique of the <code>MazeBuilder</code> example, polymorphism doesn't seem to be the crux of the matter. You could easily introduce a base class or interface that defines the <code>Method</code>, <code>AddJsonBody</code>, and <code>Build</code> members, but what would be the point? Just like the <code>MazeBuilder</code> example fails to present a compelling <em>second</em> implementation, I can't think of another useful implementation of a hypothetical <code>IHttpRequestMessageBuilder</code> interface.
	</p>
	<p>
		Notice that I dropped the <em>Build</em> prefix from most of the Builder's members. Instead, I reserved the word <code>Build</code> for the method that actually creates the desired object. This is consistent with most modern Builder examples I've encountered.
	</p>
	<p>
		The <code>HttpRequestMessageBuilder</code> comes with a reasonable set of default behaviours. If you just want to make a <code>GET</code> request, you can easily do that:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="font-weight:bold;color:#1f377f;">url</span>);
<span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">msg</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>.<span style="font-weight:bold;color:#74531f;">Build</span>();
 
<span style="color:#2b91af;">HttpClient</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">client</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#74531f;">GetClient</span>();
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">client</span>.<span style="font-weight:bold;color:#74531f;">SendAsync</span>(<span style="font-weight:bold;color:#1f377f;">msg</span>);</pre>
	</p>
	<p>
		Since you only call the <code>builder</code>'s <code>Build</code> method, but never any of the other members, you get the default behaviour. A <code>GET</code> request with no body.
	</p>
	<p>
		Notice that the <code>HttpRequestMessageBuilder</code> protects its invariants. It follows the maxim that you should never be able to put an object into an invalid state. Contrary to <em>Design Patterns'</em> <code>StandardMazeBuilder</code>, it uses its constructors to enforce an invariant. Regardless of what sort of <code>HttpRequestMessage</code> you want to build, it must have a URL. Both constructor overloads require all clients to supply one. (In order to keep the code example as simple as possible, I've omitted all sorts of precondition checks, like checking that <code>url</code> isn't null, that it's a valid URL, and so on.)
	</p>
	<p>
		If you need to make a <code>POST</code> request with a JSON body, you can change the defaults:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="font-weight:bold;color:#1f377f;">url</span>);
<span style="font-weight:bold;color:#1f377f;">builder</span>.Method&nbsp;=&nbsp;<span style="color:#2b91af;">HttpMethod</span>.Post;
<span style="font-weight:bold;color:#1f377f;">builder</span>.<span style="font-weight:bold;color:#74531f;">AddJsonBody</span>(<span style="color:blue;">new</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;=&nbsp;<span style="color:#2b91af;">Guid</span>.<span style="color:#74531f;">NewGuid</span>(),
&nbsp;&nbsp;&nbsp;&nbsp;date&nbsp;=&nbsp;<span style="color:#a31515;">&quot;2020-03-22&nbsp;19:30:00&quot;</span>,
&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;<span style="color:#a31515;">&quot;Ælfgifu&quot;</span>,
&nbsp;&nbsp;&nbsp;&nbsp;email&nbsp;=&nbsp;<span style="color:#a31515;">&quot;ælfgifu@example.net&quot;</span>,
&nbsp;&nbsp;&nbsp;&nbsp;quantity&nbsp;=&nbsp;1&nbsp;});
<span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">msg</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>.<span style="font-weight:bold;color:#74531f;">Build</span>();
 
<span style="color:#2b91af;">HttpClient</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">client</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#74531f;">GetClient</span>();
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">client</span>.<span style="font-weight:bold;color:#74531f;">SendAsync</span>(<span style="font-weight:bold;color:#1f377f;">msg</span>);</pre>
	</p>
	<p>
		Other combinations of <code>Method</code> and <code>AddJsonBody</code> are also possible. You could, for example, make a <code>DELETE</code> request without a body by only changing the <code>Method</code>.
	</p>
	<p>
		This incarnation of <code>HttpRequestMessageBuilder</code> is cumbersome to use. You must first create a <code>builder</code> object and then mutate it. Once you've invoked its <code>Build</code> method, you rarely need the object any longer, but the <code>builder</code> variable is still in scope. You can address those usage issues by refactoring a Builder to a Fluent Builder.
	</p>
	<h3 id="38b145cd45674bd989ebd37ca92b40f6">
		HTTP request Fluent Builder <a href="#38b145cd45674bd989ebd37ca92b40f6" title="permalink">#</a>
	</h3>
	<p>
		In the Gang of Four Builder pattern, no methods return anything, except the method that creates the object you're building (<code>GetMaze</code> in the <code>MazeBuilder</code> example, <code>Build</code> in the <code>HttpRequestMessageBuilder</code> example). It's always possible to refactor such a Builder so that the <code>void</code> methods return something. They can always return the object itself:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpMethod</span>&nbsp;Method&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">set</span>;&nbsp;}
 
<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithMethod</span>(<span style="color:#2b91af;">HttpMethod</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newMethod</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">newMethod</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">this</span>;
}
 
<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>&nbsp;<span style="font-weight:bold;color:#74531f;">AddJsonBody</span>(<span style="color:blue;">object</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">jsonBody</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.jsonBody&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">jsonBody</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">this</span>;
}</pre>
	</p>
	<p>
		Changing <code>AddJsonBody</code> is as easy as changing its return type and returning <code>this</code>. Refactoring the <code>Method</code> property is a bit more involved. It's a language feature of C# (and a few other languages) that classes can have properties, so this concern isn't general. In languages without properties, things are simpler. In C#, however, I chose to make the property setter private and instead add a method that returns <code>HttpRequestMessageBuilder</code>. Perhaps it's a little confusing that the name of the method includes the word <em>method</em>, but keep in mind that the method in question is an HTTP method.
	</p>
	<p>
		You can now create a <code>GET</code> request with a one-liner:
	</p>
	<p>
		<pre><span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">msg</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="font-weight:bold;color:#1f377f;">url</span>).<span style="font-weight:bold;color:#74531f;">Build</span>();</pre>
	</p>
	<p>
		You don't have to declare any <code>builder</code> variable to mutate. Even when you need to change the defaults, you can just start with a builder and keep on chaining method calls:
	</p>
	<p>
		<pre><span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">msg</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="font-weight:bold;color:#1f377f;">url</span>)
&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">WithMethod</span>(<span style="color:#2b91af;">HttpMethod</span>.Post)
&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">AddJsonBody</span>(<span style="color:blue;">new</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;=&nbsp;<span style="color:#2b91af;">Guid</span>.<span style="color:#74531f;">NewGuid</span>(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date&nbsp;=&nbsp;<span style="color:#a31515;">&quot;2020-03-22&nbsp;19:30:00&quot;</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;<span style="color:#a31515;">&quot;Ælfgifu&quot;</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;email&nbsp;=&nbsp;<span style="color:#a31515;">&quot;ælfgifu@example.net&quot;</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity&nbsp;=&nbsp;1&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">Build</span>();</pre>
	</p>
	<p>
		This creates a <code>POST</code> request with a JSON message body.
	</p>
	<p>
		We can call this pattern <em>Fluent Builder</em> because this version of the Builder pattern has a <a href="https://www.martinfowler.com/bliki/FluentInterface.html">Fluent Interface</a>.
	</p>
	<p>
		This usually works well enough in practice, but is vulnerable to <a href="https://en.wikipedia.org/wiki/Aliasing_(computing)">aliasing</a>. What happens if you reuse an <code>HttpRequestMessageBuilder</code> object?
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="font-weight:bold;color:#1f377f;">url</span>);
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">deleteMsg</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>.<span style="font-weight:bold;color:#74531f;">WithMethod</span>(<span style="color:#2b91af;">HttpMethod</span>.Delete).<span style="font-weight:bold;color:#74531f;">Build</span>();
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">getMsg</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>.<span style="font-weight:bold;color:#74531f;">Build</span>();</pre>
	</p>
	<p>
		As the variable names imply, the programmer responsible for these three lines of code incorrectly believed that without the call to <code>WithMethod</code>, the <code>builder</code> will use its default behaviour when <code>Build</code> is called. The previous line of code, however, mutated the <code>builder</code> object. Its <code>Method</code> property remains <code>HttpMethod.Delete</code> until another line of code changes it!
	</p>
	<h3 id="a75c7962ece449f6b6161fe6ae7beb1e">
		HTTP request Immutable Fluent Builder <a href="#a75c7962ece449f6b6161fe6ae7beb1e" title="permalink">#</a>
	</h3>
	<p>
		You can disarm the aliasing booby trap by making the Fluent Builder immutable. A good first step in that refactoring is making sure that all class fields are <code>readonly</code>:
	</p>
	<p>
		<pre><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">Uri</span>&nbsp;url;
<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:blue;">object</span>?&nbsp;jsonBody;</pre>
	</p>
	<p>
		The <code>url</code> field was already marked <code>readonly</code>, so the change only applies to the <code>jsonBody</code> field. In addition to the class fields, don't forget any automatic properties:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpMethod</span>&nbsp;Method&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}</pre>
	</p>
	<p>
		The <code>HttpMethod</code> property previously had a <code>private</code> setter, but this is now gone. It's also strictly read only.
	</p>
	<p>
		Now that all data is read only, the only way you can 'change' values is via a constructor. Add a constructor overload that receives all data and chain the other constructors into it:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">url</span>)&nbsp;:&nbsp;<span style="color:blue;">this</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Uri</span>(<span style="font-weight:bold;color:#1f377f;">url</span>))&nbsp;{&nbsp;}
 
<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="color:#2b91af;">Uri</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">url</span>)&nbsp;:&nbsp;<span style="color:blue;">this</span>(<span style="font-weight:bold;color:#1f377f;">url</span>,&nbsp;<span style="color:#2b91af;">HttpMethod</span>.Get,&nbsp;<span style="color:blue;">null</span>)&nbsp;{&nbsp;}
 
<span style="color:blue;">private</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="color:#2b91af;">Uri</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">url</span>,&nbsp;<span style="color:#2b91af;">HttpMethod</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">method</span>,&nbsp;<span style="color:blue;">object</span>?&nbsp;<span style="font-weight:bold;color:#1f377f;">jsonBody</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.url&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">url</span>;
&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">method</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.jsonBody&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">jsonBody</span>;
}</pre>
	</p>
	<p>
		I'm usually not keen on allowing <code>null</code> arguments, but I made the all-encompassing constructor <code>private</code>. In that way, at least no client code gets the wrong idea.
	</p>
	<p>
		The optional modification methods can now only do one thing: return a new object:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithMethod</span>(<span style="color:#2b91af;">HttpMethod</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newMethod</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(url,&nbsp;<span style="font-weight:bold;color:#1f377f;">newMethod</span>,&nbsp;jsonBody);
}
 
<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>&nbsp;<span style="font-weight:bold;color:#74531f;">AddJsonBody</span>(<span style="color:blue;">object</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">jsonBody</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(url,&nbsp;Method,&nbsp;<span style="font-weight:bold;color:#1f377f;">jsonBody</span>);
}</pre>
	</p>
	<p>
		The client code looks the same as before, but now you no longer have an aliasing problem:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="font-weight:bold;color:#1f377f;">url</span>);
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">deleteMsg</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>.<span style="font-weight:bold;color:#74531f;">WithMethod</span>(<span style="color:#2b91af;">HttpMethod</span>.Delete).<span style="font-weight:bold;color:#74531f;">Build</span>();
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">getMsg</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">builder</span>.<span style="font-weight:bold;color:#74531f;">Build</span>();</pre>
	</p>
	<p>
		Now <code>deleteMsg</code> represents a <code>Delete</code> request, and <code>getMsg</code> truly represents a <code>GET</code> request.
	</p>
	<p>
		Since this variation of the Fluent Builder pattern is immutable, it's natural to call it an <em>Immutable Fluent Builder</em>.
	</p>
	<p>
		You've now seen how to refactor from Builder via Fluent Builder to Immutable Fluent Builder. If these three pattern variations are truly isomorphic, it should also be possible to move in the other direction. I'll leave it as an exercise for the reader to do this with the HTTP request Builder example. Instead, I will briefly discuss another example that starts at the Fluent Builder pattern.
	</p>
	<h3 id="87464a8b3f4d4922b3929c50e098c344">
		Test Data Fluent Builder <a href="#87464a8b3f4d4922b3929c50e098c344" title="permalink">#</a>
	</h3>
	<p>
		A prominent example of the Fluent Builder pattern would be the set of all <a href="http://www.natpryce.com/articles/000714.html">Test Data Builders</a>. I'm going to use the example I've <a href="/2017/08/15/test-data-builders-in-c">already covered</a>. You can visit the previous article for all details, but in summary, you can, for example, write code like this:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Address</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">address</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">AddressBuilder</span>().<span style="font-weight:bold;color:#74531f;">WithCity</span>(<span style="color:#a31515;">&quot;Paris&quot;</span>).<span style="font-weight:bold;color:#74531f;">Build</span>();</pre>
	</p>
	<p>
		This creates an <code>Address</code> object with the <code>City</code> property set to <code>"Paris"</code>. The <code>Address</code> class comes with other properties. You can trust that the <code>AddressBuilder</code> gave them values, but you don't know what they are. You can use this pattern in unit tests when you need an <code>Address</code> in <a href="https://en.wikipedia.org/wiki/Paris">Paris</a>, but you don't care about any of the other data.
	</p>
	<p>
		In my previous article, I implemented <code>AddressBuilder</code> as a Fluent Builder. I did that in order to stay as true to <a href="http://www.natpryce.com">Nat Pryce</a>'s original example as possible. Whenever I use the Test Data Builder pattern in earnest, however, I use the immutable variation so that I avoid the aliasing issue.
	</p>
	<h3 id="4274fe6c008e41bd8d4e596b9cc11762">
		Test Data Builder as a Gang-of-Four Builder <a href="#4274fe6c008e41bd8d4e596b9cc11762" title="permalink">#</a>
	</h3>
	<p>
		You can easily refactor a typical Test Data Builder like <code>AddressBuilder</code> to a shape more reminiscent of the Builder pattern presented in <em>Design Patterns</em>. Apart from the <code>Build</code> method that produces the object being built, change all other methods to <code>void</code> methods:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">AddressBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">string</span>&nbsp;street;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">string</span>&nbsp;city;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:#2b91af;">PostCode</span>&nbsp;postCode;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">AddressBuilder</span>()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.street&nbsp;=&nbsp;<span style="color:#a31515;">&quot;&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.city&nbsp;=&nbsp;<span style="color:#a31515;">&quot;&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.postCode&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">PostCodeBuilder</span>().<span style="font-weight:bold;color:#74531f;">Build</span>();
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithStreet</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newStreet</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.street&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">newStreet</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithCity</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newCity</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.city&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">newCity</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithPostCode</span>(<span style="color:#2b91af;">PostCode</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newPostCode</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.postCode&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">newPostCode</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithNoPostcode</span>()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.postCode&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">PostCode</span>();
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Address</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Build</span>()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Address</span>(<span style="color:blue;">this</span>.street,&nbsp;<span style="color:blue;">this</span>.city,&nbsp;<span style="color:blue;">this</span>.postCode);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		You can still build a test address in Paris, but it's now more inconvenient.
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">addressBuilder</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">AddressBuilder</span>();
<span style="font-weight:bold;color:#1f377f;">addressBuilder</span>.<span style="font-weight:bold;color:#74531f;">WithCity</span>(<span style="color:#a31515;">&quot;Paris&quot;</span>);
 
<span style="color:#2b91af;">Address</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">address</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">addressBuilder</span>.<span style="font-weight:bold;color:#74531f;">Build</span>();</pre>
	</p>
	<p>
		You can still use multiple Test Data Builders to build more complex test data, but the classic Builder pattern doesn't compose well.
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">invoiceBuilder</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">InvoiceBuilder</span>();
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">recipientBuilder</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">RecipientBuilder</span>();
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">addressBuilder</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">AddressBuilder</span>();
<span style="font-weight:bold;color:#1f377f;">addressBuilder</span>.<span style="font-weight:bold;color:#74531f;">WithNoPostcode</span>();
<span style="font-weight:bold;color:#1f377f;">recipientBuilder</span>.<span style="font-weight:bold;color:#74531f;">WithAddress</span>(<span style="font-weight:bold;color:#1f377f;">addressBuilder</span>.<span style="font-weight:bold;color:#74531f;">Build</span>());
<span style="font-weight:bold;color:#1f377f;">invoiceBuilder</span>.<span style="font-weight:bold;color:#74531f;">WithRecipient</span>(<span style="font-weight:bold;color:#1f377f;">recipientBuilder</span>.<span style="font-weight:bold;color:#74531f;">Build</span>());
<span style="color:#2b91af;">Invoice</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">invoice</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">invoiceBuilder</span>.<span style="font-weight:bold;color:#74531f;">Build</span>();</pre>
	</p>
	<p>
		These seven lines of code creates an <code>Invoice</code> object with a address without a post code. Compare that with the Fluent Builder <a href="/2017/08/15/test-data-builders-in-c#de2e6fb74f6f4319a0fef86dcd9b839e">example in the previous article</a>. This is a clear example that while the variations are isomorphic, they aren't equally useful. The classic Builder pattern isn't as practical as one of the Fluent variations.
	</p>
	<p>
		You might protest that this variation of <code>AddressBuilder</code>, <code>InvoiceBuilder</code>, etcetera isn't equivalent to the Builder pattern. After all, the Builder shown in <em>Design Patterns</em> is polymorphic. That's really not an issue, though. Just extract an interface from the concrete builder:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IAddressBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Address</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Build</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithCity</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newCity</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithNoPostcode</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithPostCode</span>(<span style="color:#2b91af;">PostCode</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newPostCode</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">WithStreet</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newStreet</span>);
}</pre>
	</p>
	<p>
		Make the concrete class implement the interface:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">AddressBuilder</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IAddressBuilder</span></pre>
	</p>
	<p>
		You could argue that this adds no value. You'd be right. This goes contrary to the <a href="http://www.codemanship.co.uk/parlezuml/blog/?postid=934">Reused Abstractions Principle</a>. I think that the same criticism applies to <em>Design Patterns</em>' original description of the pattern, as I've already pointed out. The utility in the pattern comes from how it gives client code good defaults that it can then tweak as necessary.
	</p>
	<h3 id="a1e866bafec74def9a66f5ba96a0cca4">
		Summary <a href="#a1e866bafec74def9a66f5ba96a0cca4" title="permalink">#</a>
	</h3>
	<p>
		The Builder pattern was originally described in <em>Design Patterns</em>. Later, smart people like Nat Pryce figured out that by letting each mutating operation return the (mutated) Builder, such a Fluent API offered superior composability. A further improvement to the Fluent Builder pattern makes the Builder immutable in order to avoid aliasing issues.
	</p>
	<p>
		All three variations are isomorphic. Work that one of these variations afford is also afforded by the other variations.
	</p>
	<p>
		On the other hand, the variations aren't equally useful. Fluent APIs offer superior composability.
	</p>
	<p>
		<strong>Next:</strong> <a href="/2018/05/22/church-encoding">Church encoding</a>.
	</p>
</div>

<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	<div class="comment" id="f3f59d590234452aa6a9cd7ba56779f0">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a> <a href="#f3f59d590234452aa6a9cd7ba56779f0">#</a></div>
		<div class="comment-content">
			<blockquote>
				<p>
					You can now[, with the fluent builder implementation,] create a <code>GET</code> request with a one-liner:
				</p>
				<p>
					<pre><span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">msg</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">HttpRequestMessageBuilder</span>(<span style="font-weight:bold;color:#1f377f;">url</span>).<span style="font-weight:bold;color:#74531f;">Build</span>();</pre>
				</p>
			</blockquote>
			<p>
				It is also possible to write that one-liner with the original (non-fluent) builder implementation.  Did you mean to show how it is possible with the fluent builder implementation to create a <code>DELETE</code> request with a one-liner?  You have such an example two code blocks later.
			</p>
		</div>
		<div class="comment-date">2020-02-25 02:18 UTC</div>
	</div>

	<div class="comment" id="c12cb112352645a293bc5ecaf7d9c9aa">
	    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a> <a href="#c12cb112352645a293bc5ecaf7d9c9aa">#</a></div>
	    <div class="comment-content">
	    	<p>
	    		Tyson, you are, of course, right. The default behaviour could also have been a one-liner with the non-fluent design. Every other configuration, however, can't be a one-liner with the Gang-of-Four pattern, while it can in the Fluent guise.
	    	</p>
	    </div>
	    <div class="comment-date">2020-02-25 6:44 UTC</div>
	</div>

	<div class="comment" id="ecec868120f644c28381b188ee2e75e4">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a> <a href="#ecec868120f644c28381b188ee2e75e4">#</a></div>
		<div class="comment-content">
			<p>
				Among the example uses of your <code>HttpRequestMessageBuilder</code>, I see three HTTP verbs used: <code>GET</code>, <code>DELETE</code>, and <code>POST</code>.  Furthermore, a body is added if and only if the method is <code>POST</code>.  This matches my expectations gained from my limited experience doing web programming.  If a <code>GET</code> or <code>DELETE</code> request had a body or if a <code>POST</code> request did not have a body, then I would suspect that such behavior was a bug.
			</p>
			<p>
				For the sake of a question that I would like to ask, let's suppose that a body must be added if and only if the method is <code>POST</code>.  Under this assumption, <code>HttpRequestMessageBuilder</code> can create invalid messages.  For example, it can create a <code>GET</code> request with a body, and it can create a <code>POST</code> request without a body.  Under this assumption, how would you modify your design so that only valid messages can be created?
			</p>
		</div>
		<div class="comment-date">2020-02-25 14:34 UTC</div>
	</div>

	<div class="comment" id="1a3c2d6c7d484c5da92e49ce81c8755d">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a> <a href="#1a3c2d6c7d484c5da92e49ce81c8755d">#</a></div>
		<div class="comment-content">
			<p>
				Tyson, thank you for another inspiring question! It gives me a good motivation to write about polymorphic Builders. I'll try to address this question in a future article.
			</p>
		</div>
		<div class="comment-date">2020-03-02 8:40 UTC</div>
	</div>

	<div class="comment" id="484b7f2bd2714a2d8c08adece0955668">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a> <a href="#484b7f2bd2714a2d8c08adece0955668">#</a></div>
		<div class="comment-content">
			<p>
				Tyson, I've now attempted to answer your question in <a href="/2020/03/09/polymorphic-builder">a new article</a>.
			</p>
		</div>
		<div class="comment-date">2020-03-09 6:53 UTC</div>
	</div>
</div>