---
layout: post
title: "Functional design is intrinsically testable"
description: "TDD with Functional Programming doesn't lead to test-induced damage. Here's why."
date: 2015-05-07 6:13 UTC
tags: [Unit Testing, Software Design, Functional Programming]
image: "/content/binary/ideal-function-isolation-testability-stacked-venn.png"
image_alt: "Stacked Venn diagram that show that an ideal function is a subset of isolated functions, which is again a subset of testable functions."
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>{{ page.description }}</em>
  </p>
  <p>
    Over the years, there's been much criticism of Test-Driven Development (TDD). Perhaps <a href="http://david.heinemeierhansson.com">David Heinemeier Hansson</a> best condensed this criticism by claiming that <a href="http://david.heinemeierhansson.com/2014/test-induced-design-damage.html">TDD leads to test-induced design damage</a>. This isn't a criticism you can just brush away; it hits a sore point.
  </p>
  <p>
    Personally, I don't believe that TDD <em>has</em> to lead to test-induced damage (not even in Object-Oriented Programming), but I'm the first to admit that <a href="/2010/12/22/TheTDDApostate">it's not a design methodology</a>.
  </p>
  <p>
    In this article, though, you're going to learn about the fundamental reason that TDD with <em>Functional Programming</em> doesn't lead to test-induced damage.
  </p>
  <p>
    In Functional Programming, the ideal function is a <a href="http://en.wikipedia.org/wiki/Pure_function">Pure function</a>. A Pure function is a function that always returns the same value given the same input, and has no side-effects.
  </p>
  <h3 id="a20359945e5c406a8dbf3bd692dc2a1b">
    Isolation <a href="#a20359945e5c406a8dbf3bd692dc2a1b" title="permalink">#</a>
  </h3>
  <p>
    The first characteristic of a Pure function means that an ideal function can't depend on any implicit knowledge about the external world. Only the input into the function can influence the evaluation of the function.
  </p>
  <p>
    This is what <a href="http://jessitron.com">Jessica Kerr</a> <a href="http://www.functionalgeekery.com/episode-8-jessica-kerr">calls <em>Isolation</em></a>. A function has the property of Isolation when the only information it has about the external word is passed into it via arguments.
  </p>
  <p>
    You can think about Isolation as the <em>dual</em> of Encapsulation.
  </p>
  <p>
    In Object-Oriented Programming, <a href="http://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29">Encapsulation</a> is a very important concept. It means that while an object contains state, the external world doesn't know about that state, unless the object <strong>explicitly makes it available</strong>.
  </p>
  <p>
    In Functional Programming, a function is Isolated when it knows nothing about the state of the external world, unless it's <strong>explicitly made available to it</strong>.
  </p>
  <p>
    A Pure function, the ideal of Functional Programming, is Isolated.
  </p>
  <h3 id="55f5f9040e4b434cad839390ec1f038c">
    Unit testing <a href="#55f5f9040e4b434cad839390ec1f038c" title="permalink">#</a>
  </h3>
  <p>
    Why is this interesting?
  </p>
  <p>
    It's interesting if you start to think about what unit testing means. There are tons of conflicting definitions of what exactly constitutes a unit test, but most experts seem to be able to agree on this broad definition:
    <blockquote>
      A unit test is an automated test that tests a unit in isolation from its dependencies.
    </blockquote>
    Notice the use of the word <em>Isolation</em> in that definition. In order to unit test, you'll have to be able to isolate the unit from its dependencies. This is the requirement that tends to lead to Test-Induced Damage in Object-Oriented Programming. While there's nothing about Encapsulation that explicitly states that it's forbidden to isolate an object from its dependencies, it offers no help on the matter either. Programmers are on their own, because this concern isn't ingrained into Object-Oriented Programming.
  </p>
  <p>
    <img src="/content/binary/encapsulation-isolation-venn.png" alt="Venn diagram showing that while there's an intersection between Encapsulation and Isolation, it's only here that Object-Oriented Programming is also testable.">
  </p>
  <p>
    You can do TDD with Object-Oriented Programming, and as long as you stay within the intersection of Encapsulation and Isolation, you may be able to stay clear of test-induced damage. However, that zone of testability isn't particularly big, so it's easy to stray. You have to be very careful and know what you're doing. Not surprisingly, many books and articles have been written about TDD, including <a href="/tags.html#Unit Testing-ref">quite a few on this blog</a>.
  </p>
  <h3 id="05e982d1b87b46e6a4b963ac8280c99b">
    The best of both worlds <a href="#05e982d1b87b46e6a4b963ac8280c99b" title="permalink">#</a>
  </h3>
  <p>
    In Functional Programming, on the other hand, Isolation is the ideal. An ideal function is already isolated from its dependencies, so no more design work is required to make it testable.
  </p>
  <p>
    <img src="/content/binary/ideal-function-isolation-testability-stacked-venn.png" alt="Stacked Venn diagram that show that an ideal function is a subset of isolated functions, which is again a subset of testable functions.">
  </p>
  <p>
    Ideal Functional design is not only ideal, but also perfectly testable, so there's no conflict. This is the underlying reason that TDD doesn't lead to test-induced damage with Functional Programming.
  </p>
  <h3 id="f042d2da84424c76a424b70faea121c9">
    Summary <a href="#f042d2da84424c76a424b70faea121c9" title="permalink">#</a>
  </h3>
  <p>
    Isolation is an important quality of Functional Programming. An ideal function is Isolated, and that means that it's intrinsically testable. You don't have to tweak any design principles in order to make a function testable - in fact, if a function isn't testable, it's a sign that it's poorly designed. Thus, <strong>TDD doesn't lead to Test-Induced Damage in Functional Programming</strong>.
  </p>
  <p>
    If you want to learn more about this, as well as see lots of code examples, you can watch my <a href="{{ site.production_url }}/tdd-with-fsharp">Test-Driven Development with F#</a> Pluralsight course.
  </p>
</div>

<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	<div class="comment" id="e1992711a2074e068fd3372e65cddbf7">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<blockquote>
				A Pure function is a function that always returns the same value given the same input, and has no side-effects.
			</blockquote>
			<p>
				What do you mean by "value"?  Can an exception instance be a value?  More specifically, would you say that the C# function <code>int Foo() =&gt; new Exception();</code> is pure?
			</p>
			<p>
				Many of your posts mention pure funcitons and at least a few of them include your own definition.  I decided to comment on this post since it was the oldest post I found that included your own definition of a pure function.
			</p>
		</div>
		<div class="comment-date">2020-03-06 22:50 UTC</div>
	</div>

  <div class="comment" id="8357b5ab8ada4f44bf17dcacd9b9b079">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Tyson, thank you for writing. I don't think that <code>int Foo() =&gt; new Exception();</code> compiles...
      </p>
      <p>
        Apart from that, how do you find that this is my own definition of a pure function? It seems to me to be a standard and non-controversial definition. I even <a href="https://en.wikipedia.org/wiki/Pure_function">link to the Wikipedia definition</a> in the beginning of the article.
      </p>
    </div>
    <div class="comment-date">2020-03-07 8:49 UTC</div>
  </div>

	<div class="comment" id="f7819c9f3a304c86a4f14b2833674a34">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<blockquote>
				Apart from that, how do you find that this is my own definition of a pure function? It seems to me to be a standard and non-controversial definition. I even <a href="https://en.wikipedia.org/wiki/Pure_function">link to the Wikipedia definition</a> in the beginning of the article.
			</blockquote>
			<p>
				I am not trying claim that any particular definition of a pure function is non-standard or is controversial.  I also don't mean that the text I quoted is "your definition" in the sense that it semantically differs from the one on Wikipedia.  I just mean that it is "your definition" in the sense that you have syntactically included in your post the text that I quoted.
			</p>
			<p>
				However, I am unsure about the precise meaning the defintion for a pure function that you have syntactically included in your post and that I quoted.  To help me improve my understanding of that defintion, I tried to ask you if a particular C# function is pure.
			</p>
			<blockquote>
				I don't think that <code>int Foo() =&gt; new Exception();</code> compiles...
			</blockquote>
			<p>
				Ah, yes.  Thanks for alerting me to my mistake.  I meant to include the <code>throws</code> keyword as well.  For clarity, I now repeat that whole paragraph but with the prose "thrown" and the keyword <code>throws</code> added.
			</p>
			<p>
				What do you mean by "value"?  Can a thrown exception instance be a value?  More specifically, would you say that the C# function <code>int Foo() =&gt; throws new Exception();</code> is pure?
			</p>
		</div>
		<div class="comment-date">2020-03-07 12:27 UTC</div>
	</div>

  <div class="comment" id="97e4ae29436e4828813bf445ee1c37dc">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Tyson, your code still doesn't compile, but I think I understand the question ðŸ˜œ
      </p>
      <p>
        Yes, <code>int Foo() =&gt; throw new Exception();</code> is still a pure function, but it isn't <em>total</em>. Rather, it's a <a href="https://en.wikipedia.org/wiki/Partial_function">partial function</a>. This is an independent quality of functions.
      </p>
      <p>
        Purity relates to determinism and the lack of side effects. A total function, on the other hand, is a function that returns a proper value for every possible value in its <em>domain</em>. What do I mean by <em>proper?</em>
      </p>
      <p>
        There's two ways in which a function can fail to return a value. One is if the function never returns. Due to the <a href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a> there's no general-purpose way to determine whether or not this is the case for a Turing-complete language.
      </p>
      <p>
        Another way a function can fail to return a value is if it throws an exception. Most languages (even Haskell!) allows exception-throwing. This isn't considered a 'proper' value because, using the type system, you declared that <code>Foo</code> returns an <code>int</code>. It doesn't. It 'returns' an exception.
      </p>
      <p>
        Both non-termination and exceptions are typically considered a special value termed <em>bottom</em>, often written with the symbol <code>âŠ¥</code>.
      </p>
      <p>
        Functions can be pure, but partial. Your <code>Foo</code> function is an example of that. The holy grail in statically typed functional programming is pure and total functions. It's up to the programmer to provide the totality guarantee, though, since the type system can't enforce termination (due to the halting problem). You can, on the other hand, easily program without exceptions once you get the hang of it.
      </p>
    </div>
    <div class="comment-date">2020-03-07 13:21 UTC</div>
  </div>

	<div class="comment" id="eacb540e91fb47e6bf6296c520522aaa">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<p>
				Thanks for seeing pass my second compile error and understanding my question.
			</p>
			<p>
				Ah, yes.  I definitely know about partial and total functions from my experience with mathematics, and I am pretty sure I have previously called a function that throws an exception partial, but I completely forgot about this connection.  (I think that is because I have so focused on purity.)  Thank you for bringing this concept (back) to my attention.
			</p>
			<blockquote>
				[The definition of a pure funciton in question] seems to me to be a standard and non-controversial definition.
			</blockquote>
			<p>
				I was asking about pure functions and exception throwing because I was thinking about the definition for a pure function given by Enrico Buonanno in <a href="https://www.manning.com/books/functional-programming-in-c-sharp">Functional Programming in C#</a>.  He considers throwing an exception a side effect and includes this paragraph about this decision.
			</p>
			<blockquote>
				Some will argue that a function can be considered pure despite throwing exceptions. However, in throwing exceptions it will cause indeterminism to appear in code that makes some decisions based on exception handling, or in the absence of exception handling, in the side effect of the program crashing.
			</blockquote>
			<p>
				What do you think about Enrico's choice to define exception throwing as a side effect?
			</p>
			<p>
				It might be worth considering <code>async void Foo() =&gt; throw new Exception();</code> because it produces an unhandled exception, which crashes the executing process.
			</p>
		</div>
		<div class="comment-date">2020-03-09 03:59 UTC</div>
	</div>

  <div class="comment" id="7bdf9f1597334a40afe4b8488456d7b2">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        I haven't seen anyone take that position before, so I can only evaluate it based on what you wrote. With that limited context, however, I don't find the argument convincing. First, that throwing exceptions will cause indeterminism to appear in code that handles exceptions says nothing about the function that throws the exception. It says something about the code that handles the exception.
      </p>
      <p>
        Making decisions based on data is itself not non-deterministic. If it was, <code>if/else</code> blocks or pattern matching couldn't be pure. If the exception handler does something impure while handling an exception, then it's just an impure action. The <a href="/2018/11/19/functional-architecture-a-definition">functional interaction law</a> explicitly allows this.
      </p>
      <p>
        Keep in mind that the definition of purity that we're discussing is really only a checklist to figure out whether a function is <a href="https://en.wikipedia.org/wiki/Referential_transparency">referentially transparent</a>. That's the core definition: Can you replace a function call with its result?
      </p>
      <p>
        Yes, if the function is pure. This includes a function that throws an exception. It basically just returns <code>âŠ¥</code>. If you have code that handles the exception, it'll do that based on the exception that was thrown. It doesn't really matter if the function 'actually executed' or not. We can replace the function call with the <em>bottom</em> value.
      </p>
      <p>
        If you don't handle the exception, then yes: the program crashes. It'll do so, however, regardless of whether you 'run' the function, or you just replace it with a thrown exception.
      </p>
    </div>
    <div class="comment-date">2020-03-11 18:50 UTC</div>
  </div>

	<div class="comment" id="e118a437e8a84a9d95bd117bbe597084">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<p>
				Yes, this helps.  I agree with you.  Thanks for your explanation.
			</p>
			<blockquote>
				Due to the <a href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a> there's no general-purpose way to determine whether or not this is the case for a Turing-complete language.<br>
				...<br>
				It's up to the programmer to provide the totality guarantee, though, since the type system can't enforce termination (due to the halting problem).
			</blockquote>
			<p>
				The respective problems of deciding if a given function is total or pure are equally difficult; both are undecidable by <a href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice's theorem</a>.  A compiler for Haskell is not a general-purpose algorithm for deciding the purity of a function.  It follows from the syntax of Haskell that all functions in Haskell with a return type different from the IO monad are pure (and technically all the others as well).  Rice's theorem doesn't apply when the property being checked is syntactic.
			</p>
			<p>
				In the same way, it is possible to design a programming language with two contexts: one in which partial functions can be defined and another in which only total functions can be defined.  As before, the partial function context could be expressed by the syntactic requirement that the return type is some monad.
			</p>
		</div>
		<div class="comment-date">2020-03-11 21:08 UTC</div>
	</div>

  <div class="comment" id="34436c76e8274a0db7d28d70ee1f2321">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        I'm not familiar with Rice's theorem, so I'll have to take your word on that. Haskell, however, seems to be doing a fairly good job of distinguishing between pure and impure, but this could be because the impure actions ultimately aren't implemented in Haskell (IIRC, they're written in C or C++). This might be analogous to the following escape hatch for partiality versus totality.
      </p>
      <p>
        You can't define a <em>Turing-complete</em> language where you generally distinguish between total and partial functions. That's what Turing, GÃ¶del, and Church proved in the 1930's. The escape hatch is that if you define a language that's <em>not</em> Turing-complete, you can distinguish between total and partial functions. If I remember correctly, that's the underlying design philosophy of <a href="https://www.idris-lang.org">Idris</a>. I believe that Edwin Brady once called the concept <em>Pac-Man-complete</em>; while not Turing-complete, he was aiming for a language powerful enough that you could still implement Pac Man in it. I do believe that Idris also comes with an option where you can escape into the wider, Turing-complete part of the language by giving up on the compiler checking of totality versus partiality.
      </p>
    </div>
    <div class="comment-date">2020-03-11 21:47 UTC</div>
  </div>

	<div class="comment" id="5958a2e4ad61481782da313906bfe81e">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<p>
				Ah, great.  Your comment motivated me to read more about Idris, and I have learned some things.
			</p>
			<p>
				First, Idris includes a totality checker for functions.  By default, a function is not checked for totality.  Putting the keyword <code>total</code> above a function defintion enables the checker.  Here are <a href="https://en.wikipedia.org/wiki/Idris_(programming_language)#Dependent_types">some examples</a> of this.  The code then compiles if and only if the checker (which is essentially a theorem prover) is able to prove that the function is total.  So the two contexts are distinguished by the presence or absence of the keyword <code>total</code>.  This is a completely different approach to creating the two contexts than what I was vaguely suggesting.
			</p>
			<p>
				Second, Idris is Turing-complete as <a href="https://cs.stackexchange.com/questions/19577/what-can-idris-not-do-by-giving-up-turing-completeness/23916#23916">confirmed by Edwin Brady himself</a>.  Furthermore, both Edwin and <a href="http://adam.chlipala.net/cpdt/html/Coinductive.html">this page about coinductive</a> that he cites say (paraphrased into my words) that one could also separate the partial and total contexts using a monad.  Though the linked page goes onto say that "this is a heavyweight solution, and so we would like to avoid it whenever possible."
			</p>
			<p>
				I am really glad to have learned those things.  Thanks for the great conversation :)
			</p>
		</div>
		<div class="comment-date">2020-03-12 03:25 UTC</div>
	</div>

	<div class="comment" id="dd76d156c25b4b8e99b9018f3aa2939e">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<p>
				Would you say that <code>int Foo() { if (new Random().Next() % 2 == 0) throw new Exception(); else throw new NotImplementedException(); }</code> is pure?
			</p>
		</div>
		<div class="comment-date">2020-03-17 03:44 UTC</div>
	</div>

  <div class="comment" id="904c09a013c144e48a7d322e75f70d94">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        No, that variation of <code>Foo</code> is impure because of the non-deterministic behaviour. You can't replace a call to <code>Foo</code> with a corresponding <em>bottom</em> value.
      </p>
    </div>
    <div class="comment-date">2020-03-17 7:27 UTC</div>
  </div>

  <div class="comment" id="644b577f-c60c-46b5-8349-d8878c19bbac">
    <div class="comment-author"><a href="https://spencerfarley.com">Spencer Farley</a></div>
    <div class="comment-content">
      <p>
        Idris is very interesting. Have you seen attempts to test totality in other languages? 
      </p>
    </div>
    <div class="comment-date">2022-05-21 00:43 UTC</div>
  </div>
</div>