---
layout: post
title: "Coupling from a big-O perspective"
description: "Don't repeat yourself (DRY) implies O(1) edits."
date: 2025-11-13 9:18 UTC
tags: [Code, Architecture]
image: "/content/binary/three-way-dependency.png"
image_alt: "A box labelled 'Calling code' with arrows to two other boxes: One labelled FakeDatabase, and another labelled SqlReservationsRepository."
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        Here's a half-baked idea: We may view coupling in software through the lens of <a href="https://en.wikipedia.org/wiki/Big_O_notation">big-O notation</a>. Since this isn't yet a fully-formed idea of mine, this is one of those articles I write in order to learn from the process of having to formulate the idea to other people.
    </p>
    <h3 id="27a38591f54342e9845fe2e67fa2b893">
        Widening the scope of big-O analysis <a href="#27a38591f54342e9845fe2e67fa2b893">#</a>
    </h3>
    <p>
        Big-O analysis is usually described in terms of functions on ℝ (the real numbers), such as O(n), O(lg n), O(n<sup>3</sup>), O(2<sup>n</sup>) and so on. This is somewhat ironic because when analysing algorithm efficiency, <em>n</em> is usually an integer (i.e. <em>n</em> ∈ ℕ). That, however, suits me fine, because it establishes precedence for what I have in mind.
    </p>
    <p>
        Usually, big-O analysis is applied to algorithms, and usually by measuring an abstraction notion of an 'instruction step'. You can, however, also apply such analysis to other aspects of resource utilization. Even within the confines of algorithm analysis, you may instead of instruction count be concerned with memory consumption. In other words, you may analyze an algorithm in order to determine that it uses O(n<sup>2</sup>) memory.
    </p>
    <p>
        With that in mind, nothing prevents you from widening the scope further. While I tend to be disinterested in the small-scale performance optimizations involved with algorithms, I have a keen eye on how it applies to software architecture. In modern computers, CPU cycles are fast, but network hops are still noticeable to human perception. For example, the well-known <em>n+1 problem</em> really just implies O(n) network calls. Given that a single network hop may already (depending on topology and distance) be observable, even moderate numbers of <em>n</em> (e.g. 100) may be a problem.
    </p>
    <p>
        What I have in mind for this article is to once more transplant the thinking behind big-O notation to a new area. Instead of instructions or network calls, let O(...) indicate the number of edits you have to make in a code base in order to make a change. If we want to be more practical about it, we may measure this number in how many methods or functions we need to edit, or, even more coarsely, the number of files we need to change.
    </p>
    <h3 id="09584e8476bd4ef39a204a8069c12d0e">
        Don't Repeat Yourself <a href="#09584e8476bd4ef39a204a8069c12d0e">#</a>
    </h3>
    <p>
        In this view, the old <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principle</a> implies O(1) edits. You create a single point in your code base responsible for a given behaviour. If you need to make changes, you edit a single part of the code base. This seems obvious.
    </p>
    <p>
        What the big-O perspective implies, however, is that a small constant number of edits may be fine, too. For instance, 'dual' coupling, where two code blocks change together, is not that uncommon. This could for example be where you model messages on an internal queue. Every time you add a new message type, you'll need to define both how to send it (i.e. what data it contains and how it serializes) and how to handle it. If you are using a statically typed language, you can use a <a href="https://en.wikipedia.org/wiki/Tagged_union">sum type</a> or <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a> to keep track of all message types, which means that the type checker will remind you if you forget one or the other.
    </p>
    <p>
        In big-O notation, we simplify all constants to <em>1</em>, so even if you have systematic, but constant, coupling like this, we would still consider it O(1). In other words, if your architecture contains <em>some</em> coupling that remains constant, we may deem it O(1) and perhaps benign.
    </p>
    <p>
        This also suggests why we have a heuristic like the <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">rule of three</a>. Dual duplication is still O(1), and as long as the coupling stays constant, there's no evidence that it's growing. Once you make the third copy does evidence begin to suggest that the coupling is O(n) rather than O(1).
    </p>
    <h3 id="e0f1270bc4b24a97bc373f61052011dd">
        Small values of 1 <a href="#e0f1270bc4b24a97bc373f61052011dd">#</a>
    </h3>
    <p>
        Big-O notation is concerned about comparing orders of magnitude, which is why specific constants are simplified to <em>1</em>. The number <em>1</em> is a stand-in for any constant value, <em>1</em>, <em>2</em>, <em>10</em>, og even six billion. When editing source code, however, the actual number of edits does matter. In the following sections, I'll give concrete examples where '1' is small.
    </p>
    <h3 id="4020dbeed059499e9d345d3657a57e2f">
        Test-specific equality <a href="#4020dbeed059499e9d345d3657a57e2f">#</a>
    </h3>
    <p>
        The first example we may consider is <a href="http://xunitpatterns.com/test-specific%20equality.html">test-specific equality</a>. My <a href="/2010/06/29/IntroducingAutoFixtureLikeness">first treatment</a> related to this topic was in 2010, and <a href="/2012/06/21/TheResemblanceidiom">again in 2012</a>. Since then, I've come to view the need for test-specific equality as a test smell. If you are doing test-driven development (which you <a href="/2025/10/20/epistemology-of-software">chiefly should</a>), giving your objects or values <a href="/2021/05/03/structural-equality-for-better-tests">sane equality semantics makes testing much easier</a>. And a well-known benefit of test-driven development (TDD) is that <a href="/2011/11/10/TDDimprovesreusability">code that is easy to test is easy to use</a>.
    </p>
    <p>
        Still, if you must work with mutable objects (as in naive object-oriented design), you can't give objects structural equality. And as I recently rediscovered, functional programming doesn't entirely shield you from this kind of problem either. Functions, for example, don't have clear equality semantics in practice, so when bundling data and behaviour (does that <a href="/2018/01/22/function-isomorphisms">sound familiar</a>?), data structures can't have structural equality.
    </p>
    <p>
        Still, TDD suggests that you should reconsider your API design when that happens. Sometimes, however, part of an API is locked. I recently described such a situation, which prompted me to write <a href="">test-specific Eq instances</a>. In short, the <a href="https://www.haskell.org/">Haskell</a> data type <code>Finch</code> was not an <code>Eq</code> instance, so I added this test-specific data type to improve testability:
    </p>
    <p>
        <pre><span style="color:blue;">data</span>&nbsp;FinchEq&nbsp;=&nbsp;FinchEq
&nbsp;&nbsp;{&nbsp;feqID&nbsp;::&nbsp;Int
&nbsp;&nbsp;,&nbsp;feqHP&nbsp;::&nbsp;Galapagos.HP
&nbsp;&nbsp;,&nbsp;feqRoundsLeft&nbsp;::&nbsp;Galapagos.Rounds
&nbsp;&nbsp;,&nbsp;feqColour&nbsp;::&nbsp;Galapagos.Colour
&nbsp;&nbsp;,&nbsp;feqStrategyExp&nbsp;::&nbsp;Exp&nbsp;}
&nbsp;&nbsp;<span style="color:blue;">deriving</span>&nbsp;(<span style="color:#2b91af;">Eq</span>,&nbsp;<span style="color:#2b91af;">Show</span>)</pre>
    </p>
    <p>
        Later, I also introduced a second test-specific data structure, <code>CellStateEq</code> to address the equivalent problem that <code>CellState</code> isn't an <code>Eq</code> instance. This means that I have two representations of essentially the same kind of data. If I, much later, learn that I need to add, remove, or modify a field of, say, <code>Finch</code>, I would also need to edit <code>FinchEq</code>.
    </p>
    <p>
        There's a clear edit-time coupling with constant value <em>2</em>. When I edit one, I also need to edit the other. In big-O perspective, we could say that the specific value of <em>1</em> is <em>2</em>, or <em>1~2</em>, and so the edits required to maintain this part of the code base is of the order O(1).
    </p>
    <h3 id="fca4412f1ed3446694a8e027a1b2666d">
        Maintaining Fake objects <a href="#fca4412f1ed3446694a8e027a1b2666d">#</a>
    </h3>
    <p>
        Another interesting example is the one that originally elicited this chain of thought. In <a href="/2025/09/15/greyscale-box-test-driven-development">Greyscale-box test-driven development</a> I showed an example of how using interactive white-box testing with <a href="http://xunitpatterns.com/Configurable%20Test%20Double.html#Dynamically%20Generated%20Test%20Double">Dynamically Generated Test Doubles</a> (AKA Dynamic Mocks) leads to <a href="http://xunitpatterns.com/Fragile%20Test.html">Fragile Tests</a>. More on this later, but I also described how using <a href="http://xunitpatterns.com/Fake%20Object.html">Fake Objects</a> and <a href="/2019/02/18/from-interaction-based-to-state-based-testing">state-based testing</a> doesn't have the same problem.
    </p>
    <p>
        In <a href="https://bsky.app/profile/ladeak.net/post/3lyvldkwf6c2h">a response on Bluesky</a> Laszlo (<a href="https://bsky.app/profile/ladeak.net">@ladeak.net</a>) pointed out that this seemed to imply a three-way coupling that I had, frankly, overlooked.
    </p>
    <p>
        You can review the full description of the example in the article <a href="/2025/09/15/greyscale-box-test-driven-development">Greyscale-box test-driven development</a>, but in summary it proceeds like this: We wish to modify an implementation detail related to how the system queries its database. Specifically, we wish to change an inclusive integer-based upper bound to an exclusive bound. Thus, we change the relevant part of the <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> <code>WHERE</code> clause from
    </p>
    <p>
        <pre><span style="color:maroon;">@Min&nbsp;&lt;=&nbsp;[At]&nbsp;AND&nbsp;[At]&nbsp;&lt;=&nbsp;@Max&quot;</span></pre>
    </p>
    <p>
        to
    </p>
    <p>
        <pre><span style="color:maroon;">@Min&nbsp;&lt;=&nbsp;[At]&nbsp;AND&nbsp;[At]&nbsp;&lt;&nbsp;@Max&quot;</span></pre>
    </p>
    <p>
        Specifically, the single-character edit removes <code>=</code> from the rightmost <code>&lt;=</code>.
    </p>
    <p>
        Since this modification changes the implied contract, we also need to edit the calling code. That's another single-line edit that changes
    </p>
    <p>
        <pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>.<span style="font-weight:bold;color:#74531f;">AddDays</span>(1).<span style="font-weight:bold;color:#74531f;">AddTicks</span>(-1);</pre>
    </p>
    <p>
        to
    </p>
    <p>
        <pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>.<span style="font-weight:bold;color:#74531f;">AddDays</span>(1);</pre>
    </p>
    <p>
        What I had overlooked was that I should also have changed the single test-specific Fake object used for state-based testing. Since I changed the contract of the <code>IReservationsRepository</code> interface, and since <a href="/2023/11/13/fakes-are-test-doubles-with-contracts">Fakes are Test Doubles with contracts</a>, it follows that the <code>FakeDatabase</code> class must also change.
    </p>
    <p>
        This I had overlooked because no tests based on <code>FakeDatabase</code> failed. More on that in a future post, but the required edit is easy enough. Change
    </p>
    <p>
        <pre>.<span style="font-weight:bold;color:#74531f;">Where</span>(<span style="font-weight:bold;color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>&nbsp;<span style="font-weight:bold;color:#74531f;">&lt;=</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">r</span>.At&nbsp;&amp;&amp;&nbsp;<span style="font-weight:bold;color:#1f377f;">r</span>.At&nbsp;<span style="font-weight:bold;color:#74531f;">&lt;=</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>).<span style="font-weight:bold;color:#74531f;">ToList</span>());</pre>
    </p>
    <p>
        to
    </p>
    <p>
        <pre>.<span style="font-weight:bold;color:#74531f;">Where</span>(<span style="font-weight:bold;color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>&nbsp;<span style="font-weight:bold;color:#74531f;">&lt;=</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">r</span>.At&nbsp;&amp;&amp;&nbsp;<span style="font-weight:bold;color:#1f377f;">r</span>.At&nbsp;<span style="font-weight:bold;color:#74531f;">&lt;</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>).<span style="font-weight:bold;color:#74531f;">ToList</span>());</pre>
    </p>
    <p>
        Again, the edit involves deleting a single <code>=</code> character.
    </p>
    <p>
        <img src="/content/binary/three-way-dependency.png" alt="A box labelled 'Calling code' with arrows to two other boxes: One labelled FakeDatabase, and another labelled SqlReservationsRepository." width="500">
    </p>
    <p>
        Still, in this example, not only two, but three files are coupled. With the perspective of big-O notation, however, we may say that <em>1~3</em>, and the order of edits required to maintain this part of the code base remains O(1). Later in this article, I will discuss the maintenance burden of dynamic mocks, which I consider to be O(n). Thus, even if I have a three-way coupling, I don't expect the coupling to grow over time. That's the point: I prefer O(1) over O(n).
    </p>
    <h3 id="8d57760e1eb94d01881585eefa6d0a71">
        Large values of 1 <a href="#8d57760e1eb94d01881585eefa6d0a71">#</a>
    </h3>
    <p>
        As I'm sure practical programmers know, big-O notation has limitations. First, as <a href="https://doc.cat-v.org/bell_labs/pikestyle">Rob Pike observed</a>, "<em>n</em> is usually small". More germane to this discussion
    </p>
    <blockquote>
        <p>
            "algorithms have big constants."
        </p>
        <footer><cite><a href="https://doc.cat-v.org/bell_labs/pikestyle">Notes on Programming in C</a>, Rob Pike, 1989</cite></footer>
    </blockquote>
    <p>
        In this context, this implies that the constant we're deliberately ignoring when we label something O(1) could, in theory, be significant. We don't write O(2,000,000), but if we did, it would look like more, wouldn't it? Even if it doesn't depend on <em>n</em>.
    </p>
    <p>
        It looks to me that when we discuss source code edits, <em>5</em> or <em>6</em> could already be considered large.
    </p>
    <h3 id="aabab4ba51e245d289e78f11b446ea9b">
        Layers <a href="#aabab4ba51e245d289e78f11b446ea9b">#</a>
    </h3>
    <p>
        Although software design thought leaders have denounced layered software architecture more than a decade ago, I don't entirely agree with that position. That, however, is a topic for a different article. In any case, I still regularly see examples of design that involves a <em>UI DTO</em>, a <em>Domain Model</em>, and a <em>Data Access layer</em>.
    </p>
    <p>
        As I enumerated in 2012, a simple operation, such as adding a <em>label</em> field, involves at least six steps.
    </p>
    <blockquote>
        <ol>
            <li>"A Label column must be added to the database schema and the DbTrack class.</li>
            <li>"A Label property must be added to the Track class.</li>
            <li>"The mapping from DbTrack to Track must be updated.</li>
            <li>"A Label property must be added to the TopTrackViewModel class.</li>
            <li>"The mapping from Track to TopTrackViewModel must be updated.</li>
            <li>"The UI must be updated."</li>
        </ol>
        <footer><cite><a href="/2012/02/09/IsLayeringWorththeMapping">Is Layering Worth the Mapping?</a>, 2012</cite></footer>
    </blockquote>
    <p>
        People often complain about all the seemingly redundant work involved with such layering, and I don't blame them. At least, if there's no clear motivation for a design like that, and no evident benefit, it looks like redundant work. While you can make good use of separating concerns across layers, that's outside the scope of this article. In the naive way most often employed, it seems like mindless ceremony.
    </p>
    <p>
        Even so, how would we denote the above enumeration in terms of big-O notation? Adding a <em>label</em> field is an O(1) edit.
    </p>
    <p>
        How so? Adding, changing, or deleting a field in a particular database table always entails the same number of steps (six) as outlined above. If, in addition to the Track table you want to add, say, an Album table, you create it according to the three-layer model. This again means that every edit of <em>that</em> table involves six steps. It's still O(1), with <em>1~6</em>, but already it hurts.
    </p>
    <p>
        Apparently, six may be a 'large constant'.
    </p>
    <h3 id="3e44a59d433c4b03acdff65a491c51ac">
        Linear edits <a href="#3e44a59d433c4b03acdff65a491c51ac">#</a>
    </h3>
    <p>
        So far, we've exclusively examined multiple examples of O(1) edits. Some of them, particularly the layered-architecture example, may seem counterintuitive at first. If it requires editing six different 'blocks' of code to make a single change (not counting tests!) is still O(1), then does <em>anything</em> constitute O(n), or any other kind of relationship?
    </p>
    <p>
        To be realistic, I don't think we're in an analytical regime that allows us fine distinctions like identifying any kind of code organization to be, say O(lg n) or O(n lg n). On the other hand, examples of O(n) abound.
    </p>
    <p>
        Every time you run into the <a href="https://en.wikipedia.org/wiki/Shotgun_surgery">Shotgun Surgery</a> anti-pattern, you are looking at O(n) edits. As a simple example, consider poorly-factored logging, as for example shown initially in <a href="/2020/03/23/repeatable-execution">Repeatable execution</a>. In such situations, you have <em>n</em> classes that log. If you need to change how logging is done, you must change <em>n</em> classes.
    </p>
    <p>
        More generally, the main (unstated) goal of the DRY principle is to turn O(n) edits into O(1) edits.
    </p>
    <p>
        Every junior developer already knows this. Notwithstanding, there's a category of code where even senior programmers routinely forget this.
    </p>
    <h3 id="587527167f7c44be89d51536ccae34f6">
        Linear test coupling <a href="#587527167f7c44be89d51536ccae34f6">#</a>
    </h3>
    <p>
        When it comes to automated testing, many developers treat test code stepmotherly. The most common mistake is the misguided notion that copy-and-paste code is fine in test code. <a href="" title="Treat test code like production code">It's not</a>. Duplicated test code means that when you make a change in the System Under Test, <em>n</em> tests break, and you will have to fix each one individually, a clear O(n) edit (where <em>n</em> is the number of tests).
    </p>
    <p>
        A more subtle example of an O(n) test maintenance burden can be found in test code that uses dynamic mocks. When you use a configurable mock object, each test contains isolated configuration code related to that specific test.
    </p>
    <p>
        Let's look at an example. Consider the <a href="https://github.com/moq/moq4">Moq</a>-based tests from <a href="/2019/02/25/an-example-of-interaction-based-testing-in-c">An example of interaction-based testing in C#</a>. One test contains this <a href="https://xp123.com/3a-arrange-act-assert/">Assert</a> phase:
    </p>
    <p>
        <pre>readerTD
&nbsp;&nbsp;&nbsp;&nbsp;.Setup(r&nbsp;=&gt;&nbsp;r.Lookup(user.Id.ToString()))
&nbsp;&nbsp;&nbsp;&nbsp;.Returns(<span style="color:#2b91af;">Result</span>.Success&lt;<span style="color:#2b91af;">User</span>,&nbsp;<span style="color:#2b91af;">IUserLookupError</span>&gt;(user));
readerTD
&nbsp;&nbsp;&nbsp;&nbsp;.Setup(r&nbsp;=&gt;&nbsp;r.Lookup(otherUser.Id.ToString()))
&nbsp;&nbsp;&nbsp;&nbsp;.Returns(<span style="color:#2b91af;">Result</span>.Success&lt;<span style="color:#2b91af;">User</span>,&nbsp;<span style="color:#2b91af;">IUserLookupError</span>&gt;(otherUser));</pre>
    </p>
    <p>
        Another test arranges the same two <a href="https://martinfowler.com/bliki/TestDouble.html">Test Doubles</a>, but configures the second differently.
    </p>
    <p>
        <pre>readerTD
&nbsp;&nbsp;&nbsp;&nbsp;.Setup(r&nbsp;=&gt;&nbsp;r.Lookup(user.Id.ToString()))
&nbsp;&nbsp;&nbsp;&nbsp;.Returns(<span style="color:#2b91af;">Result</span>.Success&lt;<span style="color:#2b91af;">User</span>,&nbsp;<span style="color:#2b91af;">IUserLookupError</span>&gt;(user));
readerTD
&nbsp;&nbsp;&nbsp;&nbsp;.Setup(r&nbsp;=&gt;&nbsp;r.Lookup(otherUserId))
&nbsp;&nbsp;&nbsp;&nbsp;.Returns(<span style="color:#2b91af;">Result</span>.Error&lt;<span style="color:#2b91af;">User</span>,&nbsp;<span style="color:#2b91af;">IUserLookupError</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">UserLookupError</span>.InvalidId));</pre>
    </p>
    <p>
        Yet more tests arrange the System Under Test (SUT) in other combinations. Refer to the article for the full example.
    </p>
    <p>
        Such tests don't contain duplication per se, but each test is coupled to the SUT's dependencies. When you change one of the interfaces, you break O(n) tests, and you have to fix each one individually.
    </p>
    <p>
        As suggested earlier in the article, this is the reason to favour Fake Objects. While an interface change may still break the tests, the effort to correct them is O(1) edits.
    </p>
    <h3 id="aecc149a7055454bae3e287fd5688c02">
        Two kinds of coupling <a href="#aecc149a7055454bae3e287fd5688c02">#</a>
    </h3>
    <p>
        The big-O perspective on coupling suggests that there are two kinds of coupling: O(1) coupling and O(n) coupling. We can find duplication in both categories.
    </p>
    <p>
        In the O(1) case, duplication is somehow limited. It may be that you are following the rule of three. This allows two copies of a piece of code to exist. It may be that you've made a particular architectural decision, such as using Fake Objects for testing (triplication), or using layered architecture (sextuplication). In these cases, there's a fixed number of edits that you have to make, and in principle, you should know where to make them.
    </p>
    <p>
        I tend to be less concerned about this kind of coupling because it's manageable. In many cases, you may be able to lean on the compiler to guide you through the task of making a change. In other cases, you could have a checklist. Consider the above example of layered architecture. A checklist would enumerate the six separate steps you need to perform. Once you've checked off all six, you're done.
    </p>
    <p>
        It may be slow, tedious work, but it's generally safe, because you are unlikely to forget a spot.
    </p>
    <p>
        The O(n) case is where real trouble lies. This is the case when you copy and paste a snippet of code every time you need it somewhere new. When, later, you discover that there's a bug in the original 'source', you need to find all the places it occurs. Typical copy-paste code is often slightly modified after paste, so a naive search-and-replace strategy is likely to miss some instances.
    </p>
    <p>
        Of course, if you've copied a whole method, function, class, or module, you may still be able to find it by name, but if you've only copied an unnamed block of code, that will not work either.
    </p>
    <h3 id="9c636a02c64d4c14bb54a0425fc52f0c">
        Not all edits are equally difficult <a href="#9c636a02c64d4c14bb54a0425fc52f0c">#</a>
    </h3>
    <p>
        To be fair, we should acknowledge that not all edit are equally difficult. There are kinds of changes you can automate. Most modern code editors come with refactoring support. In the case of testing with dynamic mocks, for example, you can rename methods, rearrange parameter lists, or remove a parameter.
    </p>
    <p>
        Even so, some edits are harder. Changing the return type of a method tends to break calling code in most <a href="/2019/12/16/zone-of-ceremony">high-ceremony languages</a>. Likewise, changing a primitive parameter (an integer, a Boolean, a string) to a complex object is non-trivial, as is adding a parameter with no obvious good default value. This is when O(n) coupling hurts.
    </p>
    <h3 id="d5b66e9ae9d1444e930554768d276e76">
        Limitations <a href="#d5b66e9ae9d1444e930554768d276e76">#</a>
    </h3>
    <p>
        So far, we've considered O(1) and O(n) edits. Are there O(lg n) edits, O(n<sup>2</sup>), or even O(2<sup>n</sup>) edits?
    </p>
    <p>
        I can't rule it out, and if the reader can furnish some convincing examples, I'd be keen to learn about them. To be honest, though, I'm not sure it's that helpful. One could perhaps construe an example where inheritance creates a quadratic growth of subclasses, because someone is trying to model two independent features in a single inheritance tree. This, however, is just bad design, and we don't need the big-O lens to tell us that.
    </p>
    <h3 id="93726a996b024da48ae4ae861b52bc49">
        Conclusion <a href="#93726a996b024da48ae4ae861b52bc49">#</a>
    </h3>
    <p>
        As a thought experiment, one may adopt big-O notation as a viewpoint on code organisation. This seems particularly valuable when distinguishing between benign and malignant duplication. Duplication usually entails coupling. For a 'code architect', one of the most important tasks is to reduce, or at least control, coupling.
    </p>
    <p>
        Some coupling is of the order O(1). Hidden in this notation is a constant, which may indicate that a change can be made with a single edit, two edits, six edits, and so on. Even if the actual number is 'large', you can put tools in place to minimize risk: A simple checklist may be enough, or perhaps you can leverage a static type system.
    </p>
    <p>
        Other coupling is of the order O(n). Here, a single change must be made in O(n) different places, where <em>n</em> tends to grow over time, and there's no clear way to systematically find and identify them all. This kind of coupling strikes me as more dangerous than O(1) coupling.
    </p>
    <p>
        When I sometimes seem to have a cavalier attitude to duplication, it's likely because I've already subconsciously identified a particular duplication as of the order O(1).
    </p>
</div>