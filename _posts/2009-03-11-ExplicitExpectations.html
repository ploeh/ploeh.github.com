---
layout: post
tags: []
date: 2009-03-11 19:54:38 UTC
title: "Explicit Expectations"
comments: true
---
{% include JB/setup %}

<div id="post">
	<p>In previous <a href="http://blog.ploeh.dk/2009/01/28/ZeroFrictionTDD.aspx">Zero-Friction TDD</a> posts, I've discussed <a href="http://blogs.msdn.com/ploeh/archive/2008/10/06/naming-sut-test-variables.aspx">naming SUT</a> and <a href="http://blogs.msdn.com/ploeh/archive/2008/11/14/naming-direct-output-variables.aspx">Direct Output variables</a>, as well as the importance of <a href="http://blog.ploeh.dk/2009/03/03/DerivedValuesEnsureExecutableSpecification.aspx">explicitly describing the relationship between input and expected results</a>.</p> <p>Everything you can do to help the <a href="http://xunitpatterns.com/test%20reader.html">Test Reader</a> understand what's going on increases the quality of the test. Having a naming convention for expectations help in that regard, and it also helps coming up with variable names, thus saving yourself a bit of mental context switching.</p> <p>My naming convention is to always prefix my expectation variables with the term <em>expected</em>.</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;}??\fs20 [\cf3 TestMethod\cf0 ]\par ??\cf4 public\cf0  \cf4 void\cf0  DoStuffWillReturnMessage()\par ??\{\par ??    \cf5 // Fixture setup\par ??\cf0     \cf4 string\cf0  expectedResult = \cf6 "ploeh"\cf0 ;\par ??    \cf3 MyClass\cf0  sut = \cf4 new\cf0  \cf3 MyClass\cf0 ();\par ??    \cf5 // Exercise system\par ??\cf0     \cf4 string\cf0  result = sut.DoStuff(expectedResult);\par ??    \cf5 // Verify outcome\par ??\cf0     \cf3 Assert\cf0 .AreEqual&lt;\cf4 string\cf0 &gt;(expectedResult, result,\par ??        \cf6 "DoStuff"\cf0 );\par ??    \cf5 // Teardown\par ??\cf0 \}}
--> <div style="font-size: 10pt; background: white; color: black; font-family: courier new"><pre style="margin: 0px">[<span style="color: #2b91af">TestMethod</span>]</pre><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">void</span> DoStuffWillReturnMessage()</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> expectedResult = <span style="color: #a31515">"ploeh"</span>;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">MyClass</span> sut = <span style="color: blue">new</span> <span style="color: #2b91af">MyClass</span>();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> result = sut.DoStuff(expectedResult);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Assert</span>.AreEqual&lt;<span style="color: blue">string</span>&gt;(expectedResult, result,</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #a31515">"DoStuff"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Teardown</span></pre><pre style="margin: 0px">}</pre></div>
<p>In a test like this, the relationship between the input and output is straightforward, but in other cases it may be more complicated. Since tests should explicitly state the relationship between input and output, it may sometimes be necessary to reproduce parts of the <a href="http://xunitpatterns.com/SUT.html">SUT</a>'s behavior in the test to specify this association.</p>
<p>Do I really recommend duplicating the SUT's code in the test? Isn't this a violation of the DRY principle? And do I really think that embedding complex code in a test is a good idea?</p>
<p>No, no, and no.</p>
<p>What I really mean is best illustrated with an example. Imagine that you want to write an extension method that converts a string to PascalCase. There are several different rules that must be applied to such an algorithm, such as</p>
<ul>
<li>Convert the first letter in a word to upper case 
<li>Convert the remaining letters in the word to lower case 
<li>Remove white space</li></ul>
<p>The real algorithm would need to split the string into words along white space boundaries, then loop through this list and perform the conversion for each word, and finally concatenate all the words. However, I don't think you should reproduce this algorithm in any single test.</p>
<p>What you can do instead is to split this behavior into several tests that each test a small part of this specification, carefully avoiding any control flow language features (such as <em>if, switch, for, </em>etc.).</p>
<p>One such test might look like this:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;}??\fs20 [\cf3 TestMethod\cf0 ]\par ??\cf4 public\cf0  \cf4 void\cf0  ToPascalCaseWillConvertFirstLetterToUpper()\par ??\{\par ??    \cf5 // Fixture setup\par ??\cf0     \cf4 string\cf0  anonymousText = \cf6 "pLOeh"\cf0 ;\par ??    \cf4 string\cf0  expectedLetter =\par ??        anonymousText.First().ToString().ToUpper();\par ??    \cf5 // Exercise system\par ??\cf0     \cf4 string\cf0  result =\par ??        anonymousText.ToPascalCase();\par ??    \cf5 // Verify outcome\par ??\cf0     \cf3 Assert\cf0 .AreEqual&lt;\cf4 string\cf0 &gt;(expectedLetter,\par ??        result.First().ToString(), \cf6 "ToPascalCase"\cf0 );\par ??    \cf5 // Teardown\par ??\cf0 \}}
-->
<div style="font-size: 10pt; background: white; color: black; font-family: courier new"><pre style="margin: 0px">[<span style="color: #2b91af">TestMethod</span>]</pre><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">void</span> ToPascalCaseWillConvertFirstLetterToUpper()</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> anonymousText = <span style="color: #a31515">"pLOeh"</span>;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> expectedLetter =</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; anonymousText.First().ToString().ToUpper();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> result =</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; anonymousText.ToPascalCase();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Assert</span>.AreEqual&lt;<span style="color: blue">string</span>&gt;(expectedLetter,</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.First().ToString(), <span style="color: #a31515">"ToPascalCase"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Teardown</span></pre><pre style="margin: 0px">}</pre></div>
<p>While the complete implementation of ToPascalCase is more complex, I've extracted a tiny bit of the specification and simulated just that for the special case where there's only one word. Granted, there's a lot of method calls, but I expect that these have already been thoroughly tested, so I use them with confidence. The cyclomatic complexity of the test is minimal.</p>
<p>As an aside, note that I'm using LINQ queries to get the first letter of the string, instead of Substring(0, 1), since I find that the LINQ methods much better communicate intent.</p>
<p>I use a similar naming convention for unexpected values, imaginatively prefixing my variables with the term <em>unexpected</em>.</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;}??\fs20 [\cf3 TestMethod\cf0 ]\par ??\cf4 public\cf0  \cf4 void\cf0  CreateThingWillCreateThingWithCorrectGuid()\par ??\{\par ??    \cf5 // Fixture setup\par ??\cf0     \cf3 Guid\cf0  unexpectedId = \cf3 Guid\cf0 .Empty;\par ??    \cf3 MyClass\cf0  sut = \cf4 new\cf0  \cf3 MyClass\cf0 ();\par ??    \cf5 // Exercise system\par ??\cf0     \cf3 Thing\cf0  result = sut.CreateThing();\par ??    \cf5 // Verify outcome\par ??\cf0     \cf3 Assert\cf0 .AreNotEqual&lt;\cf3 Guid\cf0 &gt;(unexpectedId, result.Id,\par ??        \cf6 "CreateThing"\cf0 );\par ??    \cf5 // Teardown\par ??\cf0 \}}
-->
<div style="font-size: 10pt; background: white; color: black; font-family: courier new"><pre style="margin: 0px">[<span style="color: #2b91af">TestMethod</span>]</pre><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">void</span> CreateThingWillCreateThingWithCorrectGuid()</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Guid</span> unexpectedId = <span style="color: #2b91af">Guid</span>.Empty;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">MyClass</span> sut = <span style="color: blue">new</span> <span style="color: #2b91af">MyClass</span>();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Thing</span> result = sut.CreateThing();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Assert</span>.AreNotEqual&lt;<span style="color: #2b91af">Guid</span>&gt;(unexpectedId, result.Id,</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #a31515">"CreateThing"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Teardown</span></pre><pre style="margin: 0px">}</pre></div>
<p>Having a naming convention for expected values not only increases your productivity when writing tests, but also increases test maintainability.</p>
</div>
	