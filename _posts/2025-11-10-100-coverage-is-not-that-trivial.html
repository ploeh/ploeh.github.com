---
layout: post
title: "100% coverage is not that trivial"
description: "Dispelling a myth I helped propagate."
date: 2025-11-10 12:00 UTC
tags: [Unit Testing]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        Most people who have been around automated testing for a few years understand that <a href="/2015/11/16/code-coverage-is-a-useless-target-measure">code coverage is a useless target measure</a>. Unfortunately, through a game of Chinese whispers, this message often degenerates to the simpler, but incorrect, notion that code coverage is useless.
    </p>
    <p>
        As I've already covered in that article, code coverage may be useful for other reasons. That's not my agenda for this article. Rather, something about this discussion have been bothering me for a long time.
    </p>
    <p>
        Have you ever had an uneasy feeling about a topic, without being able to put your finger on exactly what the problem is? This happens to me regularly. I'm going along with the accepted narrative until the cognitive dissonance becomes so conspicuous that I can no longer ignore it.
    </p>
    <p>
        In this article, I'll grapple with the notion that 'reaching 100% code coverage is easy.'
    </p>
    <h3 id="1e210ae46a1b45d4a3764694d9128fc7">
        Origins <a href="#1e210ae46a1b45d4a3764694d9128fc7">#</a>
    </h3>
    <p>
        This tends to come up when discussing code coverage. People will say that 100% code coverage isn't a useful measure, because it's easy to reach 100%. I have <a href="/2015/11/16/code-coverage-is-a-useless-target-measure">used that argument myself</a>. Fortunately I also cited my influences in 2015; in this case Martin Fowler's <a href="https://martinfowler.com/bliki/AssertionFreeTesting.html">Assertion Free Testing</a>.
    </p>
    <blockquote>
        <p>
            "[...] of course you can do this and have 100% code coverage - which is one reason why you have to be careful on interpreting code coverage data."
        </p>
        <footer><a href="https://martinfowler.com/bliki/AssertionFreeTesting.html">Assertion Free Testing</a>, Martin Fowler, 2004</footer>
    </blockquote>
    <p>
        This may not be the only source of such a claim, but it may have been a contributing factor. There's little wrong with Fowler's article, which doesn't make any groundless claims, but I can imagine how <a href="https://martinfowler.com/bliki/SemanticDiffusion.html">semantic diffusion</a> works on an idea like that.
    </p>
    <p>
        Fowler also wrote that it's "a story from a friend of a friend." When the source of a story is twice-removed like that, alarm bells should go off. This is the stuff that urban legends are made of, and I wonder if this isn't rather an example of 'programmer folk wisdom'. I've heard variations of that story many times over the years, from various people.
    </p>
    <h3 id="b6de8ca704e0437dadc73f58c0fe84fa">
        It's not that easy <a href="#b6de8ca704e0437dadc73f58c0fe84fa">#</a>
    </h3>
    <p>
        Even though I've helped promulgate the idea that reaching 100% code coverage is easy if you cheat, I now realise that that's an overstatement. Even if you write no assertions, and surround the test code with a <code>try/catch</code> block, you can't trivially reach 100% coverage. There are going to be branches that you can't reach.
    </p>
    <p>
        This often happens in real code bases that query databases, call web services, and so on. If a branch depends on <a href="http://xunitpatterns.com/indirect%20input.html">indirect input</a>, you can't force execution down that path just by suppressing exceptions.
    </p>
    <p>
        An example is warranted.
    </p>
    <h3 id="11319fa843404ea193e56cc614603975">
        Example <a href="#11319fa843404ea193e56cc614603975">#</a>
    </h3>
    <p>
        Consider this <code>ReadReservation</code> method in the <code>SqlReservationsRepository</code> class from the code base that accompanies my book <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a>:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&lt;<span style="color:#2b91af;">Reservation</span>?&gt;&nbsp;<span style="font-weight:bold;color:#74531f;">ReadReservation</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="color:#2b91af;">Guid</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">id</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">const</span>&nbsp;<span style="color:blue;">string</span>&nbsp;readByIdSql&nbsp;=&nbsp;<span style="color:maroon;">@&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT&nbsp;[PublicId],&nbsp;[At],&nbsp;[Name],&nbsp;[Email],&nbsp;[Quantity]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;[dbo].[Reservations]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;[PublicId]&nbsp;=&nbsp;@id&quot;</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">using</span>&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">conn</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SqlConnection</span>(ConnectionString);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">using</span>&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">cmd</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SqlCommand</span>(readByIdSql,&nbsp;<span style="font-weight:bold;color:#1f377f;">conn</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">cmd</span>.Parameters.<span style="font-weight:bold;color:#74531f;">AddWithValue</span>(<span style="color:#a31515;">&quot;@id&quot;</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">id</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">conn</span>.<span style="font-weight:bold;color:#74531f;">OpenAsync</span>().<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">using</span>&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">rdr</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">cmd</span>.<span style="font-weight:bold;color:#74531f;">ExecuteReaderAsync</span>().<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(!<span style="font-weight:bold;color:#1f377f;">rdr</span>.<span style="font-weight:bold;color:#74531f;">Read</span>())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">null</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#74531f;">ReadReservationRow</span>(<span style="font-weight:bold;color:#1f377f;">rdr</span>);
}</pre>
    </p>
    <p>
        Even though it only has a <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a> of 2, most of it is unreachable to a test that tries to avoid hard work.
    </p>
    <p>
        You can try to cheat in the suggested way by adding a test like this:
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;<span style="font-weight:bold;color:#74531f;">ReadReservation</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">try</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SqlReservationsRepository</span>(<span style="color:#a31515;">&quot;dunno&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>.<span style="font-weight:bold;color:#74531f;">ReadReservation</span>(0,&nbsp;<span style="color:#2b91af;">Guid</span>.<span style="color:#74531f;">NewGuid</span>());
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">catch</span>&nbsp;{&nbsp;}
}</pre>
    </p>
    <p>
        Granted, this test passes, and if you had 0% code coverage before, it does improve the metric slightly. Interestingly, the <a href="https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-code-coverage">Coverlet collector for .NET</a> reports that only the first line, which creates the <code>conn</code> variable, is covered. I wonder, though, if this is due to some kind of compiler optimization associated with asynchronous execution that the coverage tool fails to capture.
    </p>
    <p>
        More understandably, execution reaches <code>conn.OpenAsync()</code> and crashes, since the test hasn't provided a connection to a real database. This is what happens if you run the test without the surrounding <code>try/catch</code> block.
    </p>
    <p>
        Coverlet reports 18% coverage, and that's as high you can get with 'the easy hack'. 100% is some distance away.
    </p>
    <h3 id="c6e5475f8257495f9c93e4b69e08f761">
        Toward better coverage <a href="#c6e5475f8257495f9c93e4b69e08f761">#</a>
    </h3>
    <p>
        You may protest that we can do better than this. After all, with utter disregard for using proper arguments, I passed <code>"dunno"</code> as a connection string. Clearly that doesn't work.
    </p>
    <p>
        Couldn't we easily get to 100% by providing a proper connection string? Perhaps, but what's a proper connection string?
    </p>
    <p>
        It doesn't help if you pass a well-formed connection string instead of <code>"dunno"</code>. In fact, it will only slow down the test, because then <code>conn.OpenAsync()</code> will attempt to open the connection. If the database is unreachable, that statement will eventually time out and fail with an exception.
    </p>
    <p>
        Couldn't you, though, give it a connection string to a real database?
    </p>
    <p>
        Yes, you could. If you do that, though, you should make sure that the database has a schema compatible with <code>readByIdSql</code>. Otherwise, the query will fail. What happens if the implied schema changes? Now you need to make sure that the database is updated, too. This sounds error-prone. Perhaps you should automate that.
    </p>
    <p>
        Furthermore, you may easily cover the branch that returns <code>null</code>. After all, when you query for <code>Guid.NewGuid()</code>, that value is not going to be in the table. On the other hand, how will you cover the other branch; the one that returns a row?
    </p>
    <p>
        You can only do that if you know the ID of a value already in that table. You may write a second test that queries for that known value. Now you have 100% coverage.
    </p>
    <p>
        What you have done at this point, however, is no longer an easy cheat to get to 100%. You have, essentially, added integration tests of the data access subsystem.
    </p>
    <p>
        How about adding some assertions to make the tests useful?
    </p>
    <h3 id="5286d5b5be734102b73c181d8df7dbaf">
        Integration tests for 100% <a href="#5286d5b5be734102b73c181d8df7dbaf">#</a>
    </h3>
    <p>
        In most systems, you will at least need some integration tests to reach 100% code coverage. While the code shown in <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a> doesn't have 100% code coverage (that was never my goal), it looks quite good. (It's hard to get a single number, because Coverlet apparently can't measure coverage by running multiple test projects, so I can only get partial results. Coverage is probably better than 80%, I estimate.)
    </p>
    <p>
        To test <code>ReadReservation</code> I wrote integration tests that automate setup and tear-down of a local test-specific database. The book, and the Git repository that accompanies it, has all the details.
    </p>
    <p>
        Getting to 100%, or even 80%, requires dedicated work. In a realistic code base, the claim that reaching 100% is trivial is hardly true.
    </p>
    <h3 id="5c0e004b31bb42208054e1e95f01b29d">
        Conclusion <a href="#5c0e004b31bb42208054e1e95f01b29d">#</a>
    </h3>
    <p>
        Programmer folk wisdom 'knows' that code coverage is useless. One argument is that any fool can reach 100% by writing assertion-free tests surrounded by <code>try/catch</code> blocks.
    </p>
    <p>
        This is hardly true in most significant code bases. Whenever you deal with indirect input, <code>try/catch</code> is insufficient to control whereto execution branches.
    </p>
    <p>
        This suggests that high code-coverage numbers are good, and low numbers bad. <a href="/2018/11/12/what-to-test-and-not-to-test">What constitutes high and low is context-dependent</a>. What seems to remain true, however, is that code coverage is a useless target. This has little to do with how trivial it is to reach 100%, but rather everything to do with how humans respond to incentives.
    </p>
</div>