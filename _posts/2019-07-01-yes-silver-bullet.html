---
layout: post
title: "Yes silver bullet"
description: "Since Fred Brooks published his essay, I believe that we, contrary to his prediction, have witnessed several silver bullets."
date: 2019-07-01 07:38 UTC
tags: [Productivity]
image: "/content/binary/essential-accidental-complexity-shells-brooks-scenario.png"
image_alt: "Some, but not much, accidental complexity as a shell around essential complexity."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		I've been rereading <a href="https://en.wikipedia.org/wiki/Fred_Brooks">Fred Brooks</a>'s 1986 essay <a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">No Silver Bullet</a> because I've become increasingly concerned that people seem to draw the wrong conclusions from it. <a href="https://martinfowler.com/bliki/SemanticDiffusion.html">Semantic diffusion</a> seems to have set in. These days, when people state something along the lines that there's <em>no silver bullet in software development</em>, I often get the impression that they mean that there's no panacea.
	</p>
	<p>
		Indeed; I agree. There's no miracle cure that will magically make all problems in software development go away. That's not what the essay states, however. It is, fortunately, more subtle than that.
	</p>
	<h3 id="712292e6c9c34663801dd40b4f278d3d">
		No silver bullet reread <a href="#712292e6c9c34663801dd40b4f278d3d" title="permalink">#</a>
	</h3>
	<p>
		It's a great essay. It's not my intent to dispute the central argument of the essay, but I think that Brooks made one particular assumption that I disagree with. That doesn't make me smarter in any way. He wrote the essay in 1986. I'm writing this in 2019, with the benefit of the experience of all the years in-between. Hindsight is 20-20, so anyone could make the observations that I do here.
	</p>
	<p>
		Before we get to that, though, a brief summary of the essence of the essay is in order. In short, the conclusion is this:
		<blockquote>
			<p>
				"There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity."
			</p>
			<footer><cite>Fred Brooks, <em>No Silver Bullet</em>, 1986</cite></footer>
		</blockquote>
		The beginning of the essay is a brilliant analysis of the reasons why software development is inherently difficult. If you read this together with Jack Reeves <em>What Is Software Design?</em> (available various places on the internet, or as an appendix in <a href="http://amzn.to/19W4JHk">APPP</a>), you'll probably agree that there's an inherent complexity to software development that no invention is likely to dispel.
	</p>
	<p>
		Ostensibly in the tradition of <a href="https://en.wikipedia.org/wiki/Aristotle">Aristotle</a>, Brooks distinguishes between <em>essential</em> and <em>accidental</em> complexity. This distinction is central to his argument, so it's worth discussing for a minute.
	</p>
	<p>
		Software development problems are complex, i.e. made up of many interacting sub-problems. Some of that complexity is <em>accidental</em>. This doesn't imply randomness or sloppiness, but only that the complexity isn't inherent to the problem; that it's only the result of our (human) failure to achieve perfection.
	</p>
	<p>
		If you imagine that you could whittle away all the accidental complexity, you'd ultimately reach a point where, in the words of Saint Exupéry, <em>there is nothing more to remove</em>. What's left is the <em>essential</em> complexity.
	</p>
	<p>
		Brooks' conjecture is that a typical software development project comes with both essential and accidental complexity. In his 1995 reflections <em>"No Silver Bullet" Refired</em> (available in <a href="http://bit.ly/mythical-man-month">The Mythical Man-Month</a>), he clarifies what he already implied in 1986:
		<blockquote>
			<p>
				"It is my opinion, and that is all, that the accidental or representational part of the work is now down to about half or less of the total."
			</p>
			<footer><cite>Fred Brooks, <em>"No Silver Bullet" Refired</em>, 1995</cite></footer>
		</blockquote>
		This I fundamentally disagree with, but more on that later. It makes sense to me to graphically represent the argument like this:
	</p>
	<p>
		<img src="/content/binary/essential-accidental-complexity-shells-brooks-scenario.png" alt="Some, but not much, accidental complexity as a shell around essential complexity.">
	</p>
	<p>
		The way that I think of Brooks' argument is that any software project contains some essential and some accidental complexity. For a given project, the size of the essential complexity is fixed.
	</p>
	<p>
		Brooks believes that less than half of the overall complexity is accidental:
	</p>
	<p>
		<img src="/content/binary/essential-accidental-complexity-pie-chart-brooks-scenario.png" alt="Essential and accidental complexity pie chart.">
	</p>
	<p>
		While a pie chart better illustrates the supposed ratio between the two types of complexity, I prefer to view Brooks' arguments as the first diagram, above. In that visualisation, the essential complexity is a core of fixed size, while accidental complexity is something you can work at removing. If you keep improving your process and technology, you may, conceptually, be able to remove (almost) all of it.
	</p>
	<p>
		<img src="/content/binary/essential-almost-no-accidental-complexity-shells.png" alt="Essential complexity with a very thin shell of accidental complexity.">
	</p>
	<p>
		Brooks' point, with which I agree, is that if the essential complexity is inherent, then you can't reduce the size of it. The only way to decrease the overall complexity is to reduce the accidental complexity.
	</p>
	<p>
		If you agree with the assessment that less than half of the overall complexity in modern software development is accidental, then it follows that no dramatic improvements are available. Even if you remove all accidental complexity, you've only reduced overall complexity by, say, forty percent.
	</p>
	<h3 id="d8e6f84d104b4ff6ad6b5473e46a4e30">
		Accidental complexity abounds <a href="#d8e6f84d104b4ff6ad6b5473e46a4e30" title="permalink">#</a>
	</h3>
	<p>
		I find Brooks' arguments compelling. I do not, however, accept the premise that there's only little accidental complexity left. Instead of the above diagrams, I believe that the situation looks more like this (not to scale):
	</p>
	<p>
		<img src="/content/binary/accidental-complexity-with-tiny-core-of-essential-complexity.png" alt="Accidental complexity with a tiny core of essential complexity.">
	</p>
	<p>
		I think that most of the complexity in software development is accidental. I'm not sure about today, but I believe that I have compelling evidence that this was the case in 1986, so I don't see why it shouldn't still be the case.
	</p>
	<p>
		To be clear, this is all anecdotal, since I don't believe that software development is quantifiable. In the essay, Brooks explicitly talks about the <em>invisibility</em> of software. Software is pure <em>thought stuff;</em> you can't measure it. I discuss this in my <a href="https://cleancoders.com/episode/humane-code-real-episode-1/show">Humane Code video</a>, but I also recommend that you read <a href="http://bit.ly/leprechauns-of-software-engineering">The Leprechauns of Software Engineering</a> if you have any illusions that we, as an industry, have any reliable measurements of productivity.
	</p>
	<p>
		Brooks predicts that, within the decade (from 1986 to 1996), there would be no single development that would increase productivity with an order of magnitude, i.e. by a factor of at least ten. Ironically, when he wrote <em>"No Silver Bullet" Refired</em> in 1995, at least two such developments were already in motion.
	</p>
	<p>
		We can't blame Brooks for not identifying those developments, because in 1995, their impact was not yet apparent. Again, hindsight is 20-20.
	</p>
	<p>
		Neither of these two developments are purely technological, although technology plays a role. Notice, though, that Brooks' prediction included <em>technology or management technique</em>. It's in the interaction between technology and the humane that the orders-of-magnitude developments emerged.
	</p>
	<h3 id="1d23f6fb89884b6d9833ce09d68a3b0f">
		World Wide Web <a href="#1d23f6fb89884b6d9833ce09d68a3b0f" title="permalink">#</a>
	</h3>
	<p>
		I have a dirty little secret. In the beginning of my programming career, I became quite the expert on a programming framework called <a href="https://en.wikipedia.org/wiki/Microsoft_Commerce_Server">Microsoft Commerce Server</a>. In fact, I co-authored a chapter of <a href="https://amzn.to/2CpE4rr">Professional Commerce Server 2000 Programming</a>, and in 2003 I received an <a href="https://mvp.microsoft.com">MVP</a> award as an acknowledgement of my work in the Commerce Server community (such as it were; it was mostly on <a href="https://en.wikipedia.org/wiki/Usenet">Usenet</a>).
	</p>
	<p>
		The Commerce Server framework was a black box. This was long before Microsoft embraced open source, and while there was a bit of official documentation, it was superficial; it was mostly of the <em>getting-started</em> kind.
	</p>
	<p>
		Over several years, I managed to figure out how the framework really worked, and thus, how one could extend it. This was a painstaking process. Since it was a black box, I couldn't just go and read the code to figure out how it worked. The framework was written in C++ and Visual Basic, so there wasn't even IL code to decompile.
	</p>
	<p>
		I had one window into the framework. It relied on SQL Server, and I could attach the profiler tool to spy on its interaction with the database. Painstakingly, over several years, I managed to wrest the framework's secrets from it.
	</p>
	<p>
		I wasted much time doing detective work like that.
	</p>
	<p>
		In general, programming in the late nineties and early two-thousands was less productive, not because the languages or tools were orders-of-magnitude worse than today, but because when you hit a snag, you were in trouble.
	</p>
	<p>
		These days, if you run into a problem beyond your abilities, you can ask for help on the World Wide Web. Usually, you'll find an existing answer on <a href="https://stackoverflow.com">Stack Overflow</a>, and you'll be able to proceed without too much delay.
	</p>
	<p>
		Compared to twenty years ago, I believe that the World Wide Web has increased my productivity more than ten-fold. While it also existed in 1995, there wasn't much content. It's not the technology itself that provides the productivity increase, but rather the synergy of technology and human knowledge.
	</p>
	<p>
		I think that Brooks vastly underestimated how much time one can waste when one is stuck. That's a sort of accidental complexity, although in the development process rather than in the technology itself.
	</p>
	<h3 id="a3b19483cd6a4c509d8c3a77fe324872">
		Automated testing <a href="#a3b19483cd6a4c509d8c3a77fe324872" title="permalink">#</a>
	</h3>
	<p>
		In the late nineties, I was developing web sites (with Commerce Server). When I wanted to run my code to see if it worked, I'd launch the web site on my laptop, log in, click around and enter data until I was convinced that the functionality was working as it should. Most of the time, however, it wasn't, so I'd change a bit of the code, and go through the same process again.
	</p>
	<p>
		I think that's a common way to 'test' software; at least, it was back then.
	</p>
	<p>
		While you could get good at going through these motions quickly, verifying a single, or a handful of related functionalities, could easily take at least a couple of seconds, and usually more like half a minute.
	</p>
	<p>
		If you had dozens, or even hundreds, of different scenarios to address, you obviously wouldn't run through them all every time you changed the code. At the very best, you'd click your way through three of four usage scenarios that you thought were relevant to the change you'd made. Other functionality, earlier declared <em>done</em>, you just considered to be unaffected.
	</p>
	<p>
		Needless to say, regressions were regular occurrences.
	</p>
	<p>
		In 2003 I discovered test-driven development, and through that, automated testing. While you can't directly compare unit tests with whole usage scenarios, I think it's fair to compare something like automated integration tests or user-scenario tests (whatever you want to call them) with manually clicking through an application.
	</p>
	<p>
		Even an integration test, if written properly, can verify a scenario <em>at least</em> ten times faster than you can do it by hand. A more realistic estimate is probably hundred times faster, or more.
	</p>
	<p>
		Granted, you have to write the automated test as well, and I know that it's not always trivial. Still, once you have an automated test suite in place, you can run it all the time.
	</p>
	<p>
		I never ran through <em>all</em> usage scenarios when I manually 'tested' my software. With automated tests, I do. This saves me from most regressions.
	</p>
	<p>
		This improvement is, in my opinion, a no-brainer. It's easily a factor ten improvement. All the time wasted manually 'testing' the software, plus the time wasted fixing regressions, can be put to better use.
	</p>
	<p>
		At the time Brooks was writing his own retrospective (in 1995), Kent Beck was beginning to talk to other people about test-driven development. As is a common theme in this article, hindsight is 20-20.
	</p>
	<h3 id="c7ca9269cce04b3ab934c97bc8cf0328">
		Honourable mentions <a href="#c7ca9269cce04b3ab934c97bc8cf0328" title="permalink">#</a>
	</h3>
	<p>
		There's been other improvements in software development since 1986. I considered including several other improvements as bona fide orders-of-magnitude improvements, but I think that's probably going too far. Each of the following developments have, however, offered significant improvements:
		<ul>
			<li>
				<strong>Git.</strong> It's surprising how much more productive Git can make you. While it's somewhat better than centralised source control systems at the functionality also available with those other systems, the productivity increase comes from all the new, unanticipated workflows it enables. Before I started using DVCS, I'd have lots of code that was commented out, so that I could experiment with various alternatives. With Git, I just create a new branch, or stash my changes, and experiment with abandon. While it's probably not a ten-fold increase in productivity, I believe it's the simplest technology change you can make to dramatically increase your productivity.
			</li>
			<li>
				<strong>Garbage collection.</strong> Since I've admitted that I worked with Microsoft Commerce Server, I've probably lost all credibility with my reader already, but let's see if I can win back a little. While Commerce Server programming involved <a href="https://en.wikipedia.org/wiki/VBScript">VBScript</a> programming, it also often involved <a href="https://en.wikipedia.org/wiki/Component_Object_Model">COM</a> programming, and I did quite a bit of that in C++. Having to make sure that you've cleaned up all memory after use is a bother. Garbage collection just makes this work go away. It's hardly a ten-fold improvement in productivity, but I do find it significant.
			</li>
			<li>
				<strong>Agile software development.</strong> The methodology of decreasing the feedback time between implementation and deployment has made me much more productive. I'm not interested in peddling any particular methodology like Scrum as much as just the general concept of getting rapid feedback. Particularly if you combine continuous delivery with Git, you have a powerful combination. Brooks already talked about incremental software development, and had some hopes attached to this as well. My personal experience can only agree with his sentiment. Again, probably not in itself a ten-fold increase in productivity, but enough that I wouldn't want to work on a project where rapid feedback and incremental development wasn't valued.
			</li>
		</ul>
		I'm probably forgetting lots of other improvements that have happened in the last decades. That's fine. The purpose of this article isn't to produce an exhaustive list, but rather to make the argument that significant improvements have been made since Brooks wrote his essay. I think it'd be folly, then, to believe that we've seen the last of such improvements.
	</p>
	<p>
		Personally, I'm inclined to believe another order-of-magnitude improvement is right at our feet.
	</p>
	<h3 id="bd2d47d8dac2401e936ca7902bc9109d">
		Statically typed functional programming <a href="#bd2d47d8dac2401e936ca7902bc9109d" title="permalink">#</a>
	</h3>
	<p>
		This section is conjecture on my part. The improvements I've so far covered are already realised (at least for those who choose to take advantage of them). The improvement I'll cover here is more speculative.
	</p>
	<p>
		I believe that statically typed functional programming offers another order-of-magnitude improvement over existing software development. Twenty years ago, I believed that object-oriented programming was a good idea. I now believe that I was wrong about that, so it's possible that in another twenty years, I'll also believe that I was wrong about functional programming. Take the following for what it is.
	</p>
	<p>
		When I carefully reread <em>No Silver Bullet</em>, I got the distinct impression that Brooks considered low-level details of programming part of its essential complexity:
		<blockquote>
			<p>
				"Much of the complexity in a software construct is, however, not due to conformity to the external world but rather to the implementation itself - its data structures, its algorithms, its connectivity."
			</p>
			<footer><cite>Fred Brooks, <em>"No Silver Bullet" Refired</em>, 1995</cite></footer>
		</blockquote>
		It's unreasonable to blame anyone writing in 1986, or 1995 for that matter, to think that <code>for</code> loops, variables, program state, and such other programming stables were anything but essential parts of the complexity of developing software.
	</p>
	<p>
		Someone, unfortunately I forget who, once made the point that all mainstream programming languages are layers of abstractions of how a CPU works. Assembly language is basically just mnemonics on top of a CPU instruction set, then C can be thought of as an abstraction over assembly language, C++ as the next step in abstraction, Java and C# as sort of abstractions of C++, and so on. The origin of the design is the physical CPU. You could say that these languages are designed in a bottom-up fashion.
	</p>
	<p>
		<img src="/content/binary/imperative-bottom-up-functional-top-down.png" alt="Imperative languages depicted as designed bottom-up, and functional languages as designed top-down.">
	</p>
	<p>
		Some functional languages (perhaps most famously <a href="https://www.haskell.org">Haskell</a>, but also <a href="https://en.wikipedia.org/wiki/APL_(programming_language)">APL</a>, and, possibly, <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>) are designed in a much more top-down fashion. You start with mathematical abstractions like <a href="https://en.wikipedia.org/wiki/Category_theory">category theory</a> and then figure out how to crystallise the theory into a programming language, and then again, via more layers of abstractions, how to turn the abstract language into machine code.
	</p>
	<p>
		The more you learn about the <a href="https://en.wikipedia.org/wiki/Pure_function">pure</a> functional alternative to programming, the more you begin to see mutable program state, variables, <code>for</code> loops, and similar language constructs merely as artefacts of the underlying model. Brooks, I think, thought of these as part of the essential complexity of programming. I don't think that that's the case. You can get by just fine with other abstractions instead.
	</p>
	<p>
		Besides, Brooks writes, under the heading of <em>Complexity:</em>
		<blockquote>
			<p>
				"From the complexity comes the difficulty of enumerating, much less understanding, all the possible states of the program, and from that comes the unreliability. From the complexity of the functions comes the difficulty of invoking those functions, which makes programs hard to use."
			</p>
			<footer><cite>Fred Brooks, <em>No Silver Bullet</em>, 1986</cite></footer>
		</blockquote>
		When he writes <em>functions</em>, I don't think that he means functions in the Haskell sense. I think that he means <em>operations</em>, <em>procedures</em>, or <em>methods</em>.
	</p>
	<p>
		Indeed, when you look at a C# method signature like the following, it's hard to enumerate, understand, or remember, all that it does:
	</p>
	<p>
		<pre><span style="color:blue;">int</span>?&nbsp;TryAccept(<span style="color:#2b91af;">Reservation</span>&nbsp;reservation);</pre>
	</p>
	<p>
		If this is a high-level function, many things could happen when you call that method. It could change the state of a database. It could send an email. It could mutate a variable. Not only that, but the behaviour could depend on non-deterministic factors, such as the date, time of day, or just raw randomness. Finally, how should you handle the return value? What does it mean if the return value is <em>null</em>? What if it's not? Is <code>0</code> a valid value? Are negative numbers valid? Are they different from positive values?
	</p>
	<p>
		It is, indeed, difficult to enumerate all the possible states of such a function.
	</p>
	<p>
		Consider, instead, a Haskell function with a type like this:
	</p>
	<p>
		<pre><span style="color:#2b91af;">tryAccept</span>&nbsp;::&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Reservation</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">MaybeT</span>&nbsp;<span style="color:blue;">ReservationsProgram</span>&nbsp;<span style="color:#2b91af;">Int</span></pre>
	</p>
	<p>
		What happens if you invoke this function? It returns a value. Does it send any emails? Does it mutate any state? No, it can't, because the static type informs us that this is a pure function. If any programmer, anywhere inside of the function, or the functions it calls, or functions they call, etc. tried to do something impure, it wouldn't have compiled.
	</p>
	<p>
		Can we enumerate the states of the program? Certainly. We just have to figure out what <code>ReservationsProgram</code> is. After following a few types, we find this statically typed enumeration:
	</p>
	<p>
		<pre><span style="color:blue;">data</span>&nbsp;ReservationsInstruction&nbsp;next&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;IsReservationInFuture&nbsp;Reservation&nbsp;(Bool&nbsp;-&gt;&nbsp;next)
&nbsp;&nbsp;|&nbsp;ReadReservations&nbsp;UTCTime&nbsp;([Reservation]&nbsp;-&gt;&nbsp;next)
&nbsp;&nbsp;|&nbsp;Create&nbsp;Reservation&nbsp;(Int&nbsp;-&gt;&nbsp;next)
&nbsp;&nbsp;<span style="color:blue;">deriving</span>&nbsp;Functor</pre>
	</p>
	<p>
		Essentially, there's three 'actions' that this type enables. The <code>tryAccept</code> function returns the <code>ReservationsProgram</code> inside of a <code>MaybeT</code> container, so there's a fourth option that something short-circuits along the way.
	</p>
	<p>
		You don't even have to keep track of this yourself. The compiler keeps you honest. Whenever you invoke the <code>tryAccept</code> function, the compiler will insist that you write code that can handle all possible outcomes. If you turn on the right compiler flags, the code is not going to compile if you don't.
	</p>
	<p>
		(Both code examples are taken from <a href="https://github.com/ploeh/dependency-injection-revisited">the same repository</a>.)
	</p>
	<p>
		Haskellers jokingly declare that <em>if Haskell code compiles, it works</em>. While humorous, there's a kernel of truth in that. An advanced type system can carry much information about the behaviour of a program. Some people, particularly programmers who come from a dynamically typed background, find Haskell's type system rigid. That's not an unreasonable criticism, but often, in dynamically typed languages, you have to write many automated tests to ensure that your program behaves as desired, and that it correctly handles various edge cases. A type system like Haskell's, on the other hand, embeds those rules in types instead of in tests.
	</p>
	<p>
		While you should still write automated tests for Haskell programs, fewer are needed. How many fewer? Compared to C-based languages, a factor ten isn't an unreasonable guess.
	</p>
	<p>
		After a few false starts, in 2014 I finally decided that <a href="https://fsharp.org">F#</a> would be my default choice of language on .NET. The reason for that decision was that I felt so much more productive in F# compared to C#. While F#'s type system doesn't embed information about pure versus impure functions, it does support <a href="https://en.wikipedia.org/wiki/Tagged_union">sum types</a>, which is what enables the sort of compile-time <em>enumeration</em> that Brooks discusses.
	</p>
	<p>
		F# is still my .NET language of choice, but I find that I mostly 'think in' Haskell these days. My conjecture is that a sufficiently advanced type system (like Haskell's) could easily represent another order-of-magnitude improvement over mainstream imperative languages.
	</p>
	<h3 id="a75ae35933314755b1a0cdb665262bc5">
		Improvements for those who want them <a href="#a75ae35933314755b1a0cdb665262bc5" title="permalink">#</a>
	</h3>
	<p>
		The essay <em>No Silver Bullet</em> is a perspicacious work. I think more people should read at least the first part, where Brooks explains why software development is hard. I find that analysis brilliant, and I agree: software development presupposes essential complexity. It's inherently hard.
	</p>
	<p>
		There's no reason to make it harder than it has to be, though.
	</p>
	<p>
		More than once, I've discussed productivity improvements with people, only to be met with the dismissal that 'there's no silver bullet'.
	</p>
	<p>
		Granted, there's no magical solution that will solve all problems with software development, but that doesn't mean that improvements can't be had.
	</p>
	<p>
		Consider the improvements I've argued for here. Everyone now uses the World Wide Web and sites like Stack Overflow for research; that particular improvement is firmly embedded in all organisations. On the other hand, I still regularly talk to organisations that don't routinely use automated testing.
	</p>
	<p>
		People still use centralised version control (like TFS or SVN). If there was ever a low-hanging fruit, changing to Git is one. Git is <em>free</em>, and there's plenty of tools you can use to migrate your version history to it. There's also plenty of training and help to be had. Yes, it'll require a small investment to make the change, but the productivity increase is significant.
		<blockquote>
			<p>
				"The future is already here — it's just not very evenly distributed."
			</p>
			<footer><cite>William Gibson</cite></footer>
		</blockquote>
		So it is with technology improvements. Automated testing is available, but not ubiquitous. Git is free, but still organisations stick to suboptimal version control. Haskell and F# are mature languages, yet programmers still program in C# or Java.
	</p>
	<h3 id="864e39a22bc84129bfecaafe33dd1757">
		Summary <a href="#864e39a22bc84129bfecaafe33dd1757" title="permalink">#</a>
	</h3>
	<p>
		The essay <em>No Silver Bullet</em> was written in 1986, but seems to me to be increasingly misunderstood. When people today talk about it at all, it's mostly as an excuse to stay where they are. "There's no silver bullets," they'll say.
	</p>
	<p>
		The essay, however, doesn't argue that no improvements can be had. It only argues that no more order-of-magnitude improvements can be had.
	</p>
	<p>
		In the present essay I argue that, since Brooks wrote <em>No Silver Bullet</em>, more than one such improvement happened. Once the World Wide Web truly began furnishing <em>information at your fingertips</em>, you could be more productive because you wouldn't be <em>stuck</em> for days or weeks. Automated testing reduces the work that manual testers used to perform, as well as limiting regressions.
	</p>
	<p>
		If you accept my argument, that order-of-magnitude improvements appeared after 1986, this implies that Brooks' premise was wrong. In that case, there's no reason to believe that we've seen the last significant improvement to software development.
	</p>
	<p>
		I think that more such improvements await us. I suggest that statically typed functional programming offers such an advance, but if history teaches us anything, it seems that breakthroughs tend to be unpredictable.
	</p>
</div>

<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	<div class="comment" id="7e7e932f5eea47f3bab328c58e9d164a">
		<div class="comment-author"><a href="http://blog.strobaek.org">Karsten Strøbæk</a></div>
		<div class="comment-content">
			<p>
				As always I enjoy reading your blog, even though I don't understand half of it most of the time. Or is that most of it half of the time? Allow me to put a few observations forward.
			</p>
			<p>
				First I should confess, that I have actually not read the whole of Brook's essay. When I initially tried I got about half way through; it sounds like I should make another go at it. That of course will not stop me from commenting on the above.
			</p>
			<p>
				Brook talks about complexity. To me designing and implementing a software system is not complex. Quantum physics is complex. Flying an airplane is difficult. Software development may be difficult depending on the task at hand (and unfortunately the qualifications of the team), but I would argue that it at most falls into the same category as flying an airplane.
			</p>
			<p>
				I would properly also state, that there are no silver bullets. But like you I feel that people understand it incorrectly and there is definetely no reason for making things harder than they are. I think the examples of technology that helps are excellent and exactly describe that things do move forward.
			</p>
			<p>
				That being said, it does not take away the creativity of the right decomposition, the responsibility for getting the use cases right, and especially the liability for getting it wrong. Sadly especially the last of overlooked. People should be reminded of where the phrase 'live under the bridge' comes from.
			</p>
			<p>
				To end my ramblins, I would also look a little into the future. As you know I am somewhat sceptial about machine learning and AI. However, looking at the recent break throughs and use cases in these areas, I would not be surprised of a future where software development is done by 'an AI' assemblying pre-defined 'entities' to create the software we need. Like an F16 cannot be flown without a computer, future software cannot be created by a human. 
			</p>
		</div>
		<div class="comment-date">2019-07-04 18:29:00 UTC</div>
	</div>

	<div class="comment" id="756066e5cb0e42368ff9eeb9569fa47f">
	    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
	    <div class="comment-content">
	    	<p>
	    		Karsten, thank you for writing. I'm not inclined to agree that software development falls into the same category of complexity as flying a plane. It seems to me to be orders of magnitudes more complex.
	    	</p>
	    	<p>
	    		Just look at error rates.
	    	</p>
	    	<p>
	    		Would you ever board an air plane if flying had error rates similar to those observed in software development? Would you fly even if only one percent of all flights ended with plane crash?
	    	</p>
	    	<p>
	    		In reality, flying is extremely safe. Would you claim that software development is as safe, predictable, and manageable as flying?
	    	</p>
	    	<p>
	    		I see no evidence of that.
	    	</p>
	    	<p>
	    		Are pilots significantly more capable human beings than software developers, or does something else explain the discrepancy in failure rates?
	    	</p>
	    </div>
	    <div class="comment-date">2019-07-05 15:47 UTC</div>
	</div>
	
	<div class="comment" id="7e7e932f5eea47f3bab328c58e9d164b">
		<div class="comment-author"><a href="http://blog.strobaek.org">Karsten Strøbæk</a></div>
		<div class="comment-content">
			<p>
				Hi Mark. The fact that error rates are higher in software development is more a statement to the bad state our industry is in and has been for a milinium or more.
			</p>
			<p>
				Why do we except that we produce crappy systems or in your words software that is not safe, predictable, and manageble? The list of excuses is very long and the list of results is very short. We as an industry are simply doing it wrong, but most people prefers hand waving and marketing than simple and plausible heuristic.
			</p>
			<p>
				To use your analogy about planes I could ask if you would fly with a place that had (only) been unit tested? Properly not as it is never the unit that fails, but always the integration. Should be test all integrations then? Yes, why not?
			</p>
			<p>
				The used of planes or pilots (or whatever) may have been bad. My point was, that I do not see software development as complex.
			</p>
		</div>
		<div class="comment-date">2019-07-05 20:12 UTC</div>
	</div>

	<div class="comment" id="0df7412992fb499d915e6f4cdbb644a0">
	    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
	    <div class="comment-content">
	    	<p>
	    		Karsten, if we, as an industry, are doing it wrong, then why are we doing that?
	    	</p>
	    	<p>
	    		And what should we be doing instead?
	    	</p>
	    </div>
	    <div class="comment-date">2019-07-06 16:00 UTC</div>
	</div>
</div>