---
layout: post
title: "Result is the most boring sum type"
description: "If you don't see the point, you may be looking in the wrong place."
date: 2025-11-11 6:55 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        I regularly encounter programmers who are curious about statically typed functional programming, but are struggling to understand the point of <a href="https://en.wikipedia.org/wiki/Tagged_union">sum types</a> (also known as Discriminated Unions, Union Types, or similar). Particularly, I get the impression that recently various <a href="https://x.com/hillelogram/status/1445435617047990273">thought leaders</a> have begun talking about <a href="https://en.wikipedia.org/wiki/Result_type">Result types</a>.
    </p>
    <p>
        There are deep mathematical reasons to start with Results, but on the other hand, I can understand if many learners are left nonplussed. After all, <a href="/2025/10/15/result-isomorphism">Result types are roughly equivalent to exceptions</a>, and since most languages already come with exceptions, it can be difficult to see what is the point of it all.
    </p>
    <p>
        The short response is that there's a natural explanation. A Result type is, so to speak, the fundamental sum type. From it, you can construct all other sum types. Thus, you can say that Results are the most abstract of all sum types. In that light, it's understandable if you struggle to see how they are useful.
    </p>
    <h3 id="f4ab82fa70e3481b9a8bb3bc2c9132b8">
        Coproduct <a href="#f4ab82fa70e3481b9a8bb3bc2c9132b8">#</a>
    </h3>
    <p>
        My goal with this article is to point out why and how Result types are the most abstract, and perhaps least interesting, sum types. The point is not to make Result types compelling, or sell sum types in general. Rather, my point is that if you're struggling to understand what all the fuss is about <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>, perhaps Result types are the wrong place to start.
    </p>
    <p>
        In the following, I will tend to call Result by another name: <a href="/2018/06/11/church-encoded-either">Either</a>, which is also the name used in <a href="https://www.haskell.org/">Haskell</a>, where it encodes <a href="https://bartoszmilewski.com/2015/01/07/products-and-coproducts/">a universal construction called a <em>coproduct</em></a>. Where Result indicates a choice between success and failure, Either models a choice between 'left' and 'right'.
    </p>
    <p>
        Although the English language allows the pun 'right = correct', and thereby the mnemonic that the right value is the opposite of failure, 'left' and 'right' are otherwise meant to be as neutral as possible. Ideally, Either carries no semantic value. This is what we would expect from a 'most abstract' representation.
    </p>
    <h3 id="0c2f5e20a5c3485c896867d0d121589b">
        Canonical representation <a href="#0c2f5e20a5c3485c896867d0d121589b">#</a>
    </h3>
    <p>
        As <a href="https://thinkingwithtypes.com/">Thinking with Types</a> does an admirable job of explaining, Either is part of a canonical representation of types, in which we can rewrite any type as a sum of products. In this context, a <em>product</em> is a pair, as <a href="https://bartoszmilewski.com/2015/01/07/products-and-coproducts/">also outlined by Bartosz Milewski</a>.
    </p>
    <p>
        The point is that we may rewrite any type to a combination of pairs and Either values, with the Either values on the outside. Such rewrites work both ways. You can rewrite any type to a combination of pairs and Eithers, or you can turn a combination of pairs and Eithers into more descriptive types. Since two-way translation is possible, we observe that the representations are isomorphic.
    </p>
    <h3 id="c5a93e795c064496bfe9a86c8d95c5ef">
        Isomorphism with Maybe <a href="#c5a93e795c064496bfe9a86c8d95c5ef">#</a>
    </h3>
    <p>
        Perhaps the simplest example is the <a href="/2022/07/18/natural-transformations">natural transformation</a> between <code>Either () a</code> and <code>Maybe a</code>, or, in <a href="https://fsharp.org/">F#</a> syntax, <code>Result&lt;&#39;a,unit&gt;</code> and <code>&#39;a&nbsp;option</code>. The <a href="/2022/07/18/natural-transformations">Natural transformations</a> article shows an F# example.
    </p>
    <p>
        For illustration, we may translate this isomorphism to C# in order to help readers who are more comfortable with object-oriented C-like syntax. We may reuse the <code>IgnoreLeft</code> implementation, also from <a href="/2022/07/18/natural-transformations">Natural transformations</a>, to implement a translation from <code><span style="color:#2b91af;">IEither</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:#2b91af;">R</span>&gt;</code> to <code><span style="color:#2b91af;">IMaybe</span>&lt;<span style="color:#2b91af;">R</span>&gt;</code>.
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IMaybe</span>&lt;<span style="color:#2b91af;">R</span>&gt;&nbsp;<span style="color:#74531f;">ToMaybe</span>&lt;<span style="color:#2b91af;">R</span>&gt;(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:#2b91af;">R</span>&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">source</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">source</span>.<span style="font-weight:bold;color:#74531f;">IgnoreLeft</span>();
}</pre>
    </p>
    <p>
        In order to go the other way, we may define <code>ToMaybe</code>'s counterpart like this:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:#2b91af;">T</span>&gt;&nbsp;<span style="color:#74531f;">ToEither</span>&lt;<span style="color:#2b91af;">T</span>&gt;(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IMaybe</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">source</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">source</span>.<span style="font-weight:bold;color:#74531f;">Accept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ToEitherVisitor</span>&lt;<span style="color:#2b91af;">T</span>&gt;());
}
 
<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">ToEitherVisitor</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;:&nbsp;<span style="color:#2b91af;">IMaybeVisitor</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:#2b91af;">T</span>&gt;&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:#2b91af;">T</span>&gt;&nbsp;VisitNothing&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Left</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:#2b91af;">T</span>&gt;(<span style="color:#2b91af;">Unit</span>.Instance);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:#2b91af;">T</span>&gt;&nbsp;<span style="font-weight:bold;color:#74531f;">VisitJust</span>(<span style="color:#2b91af;">T</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">just</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Right</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:#2b91af;">T</span>&gt;(<span style="font-weight:bold;color:#1f377f;">just</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        The following two parametrized tests demonstrate the isomorphisms.
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Theory</span>,&nbsp;<span style="color:#2b91af;">ClassData</span>(<span style="color:blue;">typeof</span>(<span style="color:#2b91af;">UnitIntEithers</span>))]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">IsomorphismViaMaybe</span>(<span style="color:#2b91af;">IEither</span>&lt;<span style="color:#2b91af;">Unit</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>.<span style="font-weight:bold;color:#74531f;">ToMaybe</span>().<span style="font-weight:bold;color:#74531f;">ToEither</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Equal</span>(<span style="font-weight:bold;color:#1f377f;">expected</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>);
}

[<span style="color:#2b91af;">Theory</span>,&nbsp;<span style="color:#2b91af;">ClassData</span>(<span style="color:blue;">typeof</span>(<span style="color:#2b91af;">StringMaybes</span>))]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">IsomorphismViaEither</span>(<span style="color:#2b91af;">IMaybe</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>.<span style="font-weight:bold;color:#74531f;">ToEither</span>().<span style="font-weight:bold;color:#74531f;">ToMaybe</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Equal</span>(<span style="font-weight:bold;color:#1f377f;">expected</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>);
}</pre>
    </p>
    <p>
        The first test starts with an Either value, converts it to <a href="/2022/04/25/the-maybe-monad">Maybe</a>, and then converts the Maybe value back to an Either value. The second test starts with a Maybe value, converts it to Either, and converts it back to Maybe. In both cases, the <code>actual</code> value is equal to the <code>expected</code> value, which was also the original input.
    </p>
    <p>
        Being able to map between Either and Maybe (or Result and Option, if you prefer) is hardly illuminating, since Maybe, too, is a general-purpose data structure. If this all seems a bit abstract, I can see why. Some more specific examples may help.
    </p>
    <h3 id="dc8fbf510b8f44f4a52d7d55341ff10c">
        Calendar periods in F# <a href="#dc8fbf510b8f44f4a52d7d55341ff10c">#</a>
    </h3>
    <p>
        Occasionally I run into the need to treat different calendar periods, such as days, months, and years, in a consistent way. To my recollection, the first time I <a href="/2013/10/21/replace-overloading-with-discriminated-unions">described a model</a> for that was in 2013. In short, in F# you can define a discriminated union for that purpose:
    </p>
    <p>
        <pre><span style="color:blue;">type</span>&nbsp;<span style="color:#066555;">Period</span>&nbsp;=&nbsp;<span style="color:#066555;">Year</span>&nbsp;<span style="color:blue;">of</span>&nbsp;<span style="color:#066555;">int</span>&nbsp;|&nbsp;<span style="color:#066555;">Month</span>&nbsp;<span style="color:blue;">of</span>&nbsp;<span style="color:#066555;">int</span>&nbsp;*&nbsp;<span style="color:#066555;">int</span>&nbsp;|&nbsp;<span style="color:#066555;">Day</span>&nbsp;<span style="color:blue;">of</span>&nbsp;<span style="color:#066555;">int</span>&nbsp;*&nbsp;<span style="color:#066555;">int</span>&nbsp;*&nbsp;<span style="color:#066555;">int</span></pre>
    </p>
    <p>
        A year is just a single integer, whereas a day is a triple, obviously with the components arranged in a sane order, with <code>Day (2025, 11, 14)</code> representing November 14, 2025.
    </p>
    <p>
        Since this is a three-way discriminated union, whereas Either (or, in F#: Result) only has two mutually exclusive options, we need to nest one inside of another to represent this type in canonical form: <code><span style="color:#066555;">Result</span>&lt;<span style="color:#066555;">int</span>,&nbsp;<span style="color:#066555;">Result</span>&lt;(<span style="color:#066555;">int</span>&nbsp;*&nbsp;<span style="color:#066555;">int</span>),&nbsp;(<span style="color:#066555;">int</span>&nbsp;*&nbsp;(<span style="color:#066555;">int</span>&nbsp;*&nbsp;<span style="color:#066555;">int</span>))&gt;&gt;</code>. Note that the 'outer' Result is a choice between a single integer (the year) and another Result value. The inner Result value then presents a choice between a month and a day.
    </p>
    <p>
        Converting back and forth is straightforward:
    </p>
    <p>
        <pre><span style="color:blue;">let</span>&nbsp;<span style="color:#74531f;">periodToCanonical</span>&nbsp;=&nbsp;<span style="color:blue;">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Year</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">y</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Ok</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">y</span>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Month</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Error</span>&nbsp;(<span style="color:#066555;">Ok</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>))
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Day</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">d</span>)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Error</span>&nbsp;(<span style="color:#066555;">Error</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;(<span style="font-weight:bold;color:#1f377f;">m</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">d</span>)))
 
<span style="color:blue;">let</span>&nbsp;<span style="color:#74531f;">canonicalToPeriod</span>&nbsp;=&nbsp;<span style="color:blue;">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Ok</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">y</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Year</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">y</span>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Error</span>&nbsp;(<span style="color:#066555;">Ok</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>))&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Month</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Error</span>&nbsp;(<span style="color:#066555;">Error</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;(<span style="font-weight:bold;color:#1f377f;">m</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">d</span>)))&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Day</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">d</span>)</pre>
    </p>
    <p>
        In F# this translations may strike you as odd, since the choice between <code>Ok</code> and <code>Error</code> hardly comes across as neutral. Even so, there's no loss of information when translating back and forth between the two representations.
    </p>
    <p>
        <pre>&gt; Month (2025, 12) |&gt; periodToCanonical;;
val it: Result&lt;int,Result&lt;(int * int),(int * (int * int))&gt;&gt; =
  Error (Ok (2025, 12))

&gt; Error (Ok (2025, 12)) |&gt; canonicalToPeriod;;
val it: Period = Month (2025, 12)</pre>
    </p>
    <p>
        The implied semantic difference between <code>Ok</code> and <code>Error</code> is one reason I favour Either over Result, when I have the choice. When translating to C#, I do have a choice, since there's no built-in coproduct data type.
    </p>
    <h3 id="908edd4b21e4412ea20280cccf99cc38">
        Calendar periods in C# <a href="#908edd4b21e4412ea20280cccf99cc38">#</a>
    </h3>
    <p>
        If you have been perusing the code base that accompanies <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a>, you may have noticed an <code>IPeriod</code> interface. Since this is <a href="/2021/03/01/pendulum-swing-internal-by-default">internal by default</a>, I haven't discussed it much, but it's equivalent to the above F# discriminated union. It's used to enumerate restaurant reservations for a day, a month, or even a whole year.
    </p>
    <p>
        Since this is a <a href="/2018/06/25/visitor-as-a-sum-type">Visitor-encoded sum type</a>, most of the information about data representation can be discerned from the Visitor interface:
    </p>
    <p>
        <pre><span style="color:blue;">internal</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IPeriodVisitor</span>&lt;<span style="color:#2b91af;">T</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">T</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitYear</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">year</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">T</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitMonth</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">year</span>,&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">month</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">T</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitDay</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">year</span>,&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">month</span>,&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">day</span>);
}</pre>
    </p>
    <p>
        Given an appropriate Either definition, we can translate any <code>IPeriod</code> value into a nested Either, just like the above F# example.
    </p>
    <p>
        <pre><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">ToCanonicalPeriodVisitor</span>&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IPeriodVisitor</span>&lt;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;&gt;&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;&gt;&nbsp;<span style="font-weight:bold;color:#74531f;">VisitDay</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">year</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">month</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">day</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Right</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Right</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;((<span style="font-weight:bold;color:#1f377f;">year</span>,&nbsp;(<span style="font-weight:bold;color:#1f377f;">month</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">day</span>))));
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;&gt;&nbsp;<span style="font-weight:bold;color:#74531f;">VisitMonth</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">year</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">month</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Right</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Left</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;((<span style="font-weight:bold;color:#1f377f;">year</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">month</span>)));
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;&gt;&nbsp;<span style="font-weight:bold;color:#74531f;">VisitYear</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">year</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Left</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;&gt;(<span style="font-weight:bold;color:#1f377f;">year</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        Look out! I've encoded year, month, and day from left to right as I did before. This means that the leftmost alternative indicates a year, and the rightmost alternative in the nested Either value indicates a day. This is structurally equivalent to the above F# encoding. If, however, you are used to thinking about <em>left</em> values indicating error, and <em>right</em> values indicating success, then the two mappings are not similar. In the F# encoding, an 'outer' <code>Ok</code> value indicates a year, whereas here, a left value indicates a year. This may be confusing if your are expecting a <em>right</em> value, corresponding to <code>Ok</code>.
    </p>
    <p>
        The structure is the same, but this may be something to be aware of going forward.
    </p>
    <p>
        You can translate the other way without loss of information.
    </p>
    <p>
        <pre><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">ToPeriodVisitor</span>&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IEitherVisitor</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;,&nbsp;<span style="color:#2b91af;">IPeriod</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IPeriod</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitLeft</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">left</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Year</span>(<span style="font-weight:bold;color:#1f377f;">left</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IPeriod</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitRight</span>(<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">right</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">right</span>.<span style="font-weight:bold;color:#74531f;">Accept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ToMonthOrDayVisitor</span>());
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">ToMonthOrDayVisitor</span>&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IEitherVisitor</span>&lt;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>),&nbsp;(<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>)),&nbsp;<span style="color:#2b91af;">IPeriod</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IPeriod</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitLeft</span>((<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>)&nbsp;<span style="font-weight:bold;color:#1f377f;">left</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>)&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">left</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Month</span>(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IPeriod</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitRight</span>((<span style="color:blue;">int</span>,&nbsp;(<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>))&nbsp;<span style="font-weight:bold;color:#1f377f;">right</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;(<span style="font-weight:bold;color:#1f377f;">m</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">d</span>))&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">right</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Day</span>(<span style="font-weight:bold;color:#1f377f;">y</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">m</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">d</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        It's all fairly elementary, although perhaps a bit cumbersome. The point of it all, should you have forgotten, is only to demonstrate that we can encode any sum type as a combination of Either values (and pairs).
    </p>
    <p>
        A test like this demonstrates that these two translations comprise a true isomorphism:
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Theory</span>,&nbsp;<span style="color:#2b91af;">ClassData</span>(<span style="color:blue;">typeof</span>(<span style="color:#2b91af;">PeriodData</span>))]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">IsomorphismViaEither</span>(<span style="color:#2b91af;">IPeriod</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">Accept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ToCanonicalPeriodVisitor</span>())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">Accept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ToPeriodVisitor</span>());
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Equal</span>(<span style="font-weight:bold;color:#1f377f;">expected</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>);
}</pre>
    </p>
    <p>
        This test converts arbitrary <code>IPeriod</code> values to nested Either values, and then translates them back to the same <code>IPeriod</code> value.
    </p>
    <h3 id="228670b9d03c4fc7b2057d95488ce02b">
        Payment types in F# <a href="#228670b9d03c4fc7b2057d95488ce02b">#</a>
    </h3>
    <p>
        Perhaps you are not convinced by a single example, so let's look at one more. In 2016 I was writing some code to integrate with a payment gateway. To model the various options that the gateway made available, I <a href="/2016/11/28/easy-domain-modelling-with-types">defined a discriminated union</a>, repeated here:
    </p>
    <p>
        <pre><span style="color:blue;">type</span>&nbsp;<span style="color:#066555;">PaymentService</span>&nbsp;=&nbsp;{&nbsp;Name&nbsp;:&nbsp;<span style="color:#066555;">string</span>;&nbsp;Action&nbsp;:&nbsp;<span style="color:#066555;">string</span>&nbsp;}
&nbsp;
<span style="color:blue;">type</span>&nbsp;<span style="color:#066555;">PaymentType</span>&nbsp;=
|&nbsp;<span style="color:#066555;">Individual</span>&nbsp;<span style="color:blue;">of</span>&nbsp;<span style="color:#066555;">PaymentService</span>
|&nbsp;<span style="color:#066555;">Parent</span>&nbsp;<span style="color:blue;">of</span>&nbsp;<span style="color:#066555;">PaymentService</span>
|&nbsp;<span style="color:#066555;">Child</span>&nbsp;<span style="color:blue;">of</span>&nbsp;originalTransactionKey&nbsp;:&nbsp;<span style="color:#066555;">string</span>&nbsp;*&nbsp;paymentService&nbsp;:&nbsp;<span style="color:#066555;">PaymentService</span></pre>
    </p>
    <p>
        This looks a little more complicated, since it also makes use of the custom <code>PaymentService</code> type. Even so, converting to the canonical sum of products representation, and back again, is straightforward:
    </p>
    <p>
        <pre><span style="color:blue;">let</span>&nbsp;<span style="color:#74531f;">paymentToCanonical</span>&nbsp;=&nbsp;<span style="color:blue;">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Individual</span>&nbsp;{&nbsp;Name&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">n</span>;&nbsp;Action&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>&nbsp;}&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Ok</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">n</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Parent</span>&nbsp;{&nbsp;Name&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">n</span>;&nbsp;Action&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>&nbsp;}&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Error</span>&nbsp;(<span style="color:#066555;">Ok</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">n</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>))
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Child</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">k</span>,&nbsp;{&nbsp;Name&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">n</span>;&nbsp;Action&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>&nbsp;})&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Error</span>&nbsp;(<span style="color:#066555;">Error</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">k</span>,&nbsp;(<span style="font-weight:bold;color:#1f377f;">n</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>)))
 
<span style="color:blue;">let</span>&nbsp;<span style="color:#74531f;">canonicalToPayment</span>&nbsp;=&nbsp;<span style="color:blue;">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Ok</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">n</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Individual</span>&nbsp;{&nbsp;Name&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">n</span>;&nbsp;Action&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Error</span>&nbsp;(<span style="color:#066555;">Ok</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">n</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>))&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Parent</span>&nbsp;{&nbsp;Name&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">n</span>;&nbsp;Action&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#066555;">Error</span>&nbsp;(<span style="color:#066555;">Error</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">k</span>,&nbsp;(<span style="font-weight:bold;color:#1f377f;">n</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>)))&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#066555;">Child</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">k</span>,&nbsp;{&nbsp;Name&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">n</span>;&nbsp;Action&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>&nbsp;})</pre>
    </p>
    <p>
        Again, there's no loss of information going back and forth between these two representations, even if the use of the <code>Error</code> case seems confusing.
    </p>
    <p>
        <pre>&gt; Child ("1234ABCD", { Name = "MasterCard"; Action = "Pay" }) |&gt; paymentToCanonical;;
val it:
  Result&lt;(string * string),
         Result&lt;(string * string),(string * (string * string))&gt;&gt; =
  Error (Error ("1234ABCD", ("MasterCard", "Pay")))

&gt; Error (Error ("1234ABCD", ("MasterCard", "Pay"))) |&gt; canonicalToPayment;;
val it: PaymentType = Child ("1234ABCD", { Name = "MasterCard"
                                           Action = "Pay" })</pre>
    </p>
    <p>
        Again, you might wonder why anyone would ever do that, and you'd be right. As a general rule, there's no reason to do this, and if you think that the canonical representation is more abstract, and harder to understand, I'm not going to argue. The point is, rather, that products (pairs) and coproducts (Either values) are universal building blocks of algebraic data types.
    </p>
    <h3 id="705e36f3709e4913904882d8b05eb7a9">
        Payment types in C# <a href="#705e36f3709e4913904882d8b05eb7a9">#</a>
    </h3>
    <p>
        As in the calendar-period example, it's possible to demonstrate the concept in alternative programming languages. For the benefit of programmers with a background in C-like languages, I once more present the example in C#. The starting point is where <a href="/2018/06/25/visitor-as-a-sum-type">Visitor as a sum type</a> ends. The code is also <a href="https://github.com/ploeh/ChurchEncoding">available on GitHub</a>.
    </p>
    <p>
        Translation to canonical form may be done with a <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a> like this:
    </p>
    <p>
        <pre><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">ToCanonicalPaymentTypeVisitor</span>&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IPaymentTypeVisitor</span>&lt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;&gt;&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#74531f;">VisitChild</span>(<span style="color:#2b91af;">ChildPaymentService</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">child</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Right</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Right</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">child</span>.OriginalTransactionKey,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">child</span>.PaymentService.Name,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">child</span>.PaymentService.Action
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)));
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#74531f;">VisitIndividual</span>(<span style="color:#2b91af;">PaymentService</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">individual</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Left</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-weight:bold;color:#1f377f;">individual</span>.Name,&nbsp;<span style="font-weight:bold;color:#1f377f;">individual</span>.Action));
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#74531f;">VisitParent</span>(<span style="color:#2b91af;">PaymentService</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">parent</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Right</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Left</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-weight:bold;color:#1f377f;">parent</span>.Name,&nbsp;<span style="font-weight:bold;color:#1f377f;">parent</span>.Action)));
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        If you find the method signatures horrible and near-unreadable, I don't blame you. This is an excellent example that C# (together with similar languages) inhabit the <a href="/2019/12/16/zone-of-ceremony">zone of ceremony</a>; compare this <code>ToCanonicalPaymentTypeVisitor</code> to the above F# <code>paymentToCanonical</code> function, which performs exactly the same work while being as strongly statically typed.
    </p>
    <p>
        Another Visitor translates the other way.
    </p>
    <p>
        <pre><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">FromCanonicalPaymentTypeVisitor</span>&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IEitherVisitor</span>&lt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;,&nbsp;<span style="color:#2b91af;">IPaymentType</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IPaymentType</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitLeft</span>((<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>)&nbsp;<span style="font-weight:bold;color:#1f377f;">left</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">name</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">action</span>)&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">left</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Individual</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">PaymentService</span>(<span style="font-weight:bold;color:#1f377f;">name</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">action</span>));
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IPaymentType</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitRight</span>(<span style="color:#2b91af;">IEither</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">right</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">right</span>.<span style="font-weight:bold;color:#74531f;">Accept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">CanonicalParentChildPaymentTypeVisitor</span>());
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">CanonicalParentChildPaymentTypeVisitor</span>&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IEitherVisitor</span>&lt;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>),&nbsp;(<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>)),&nbsp;<span style="color:#2b91af;">IPaymentType</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IPaymentType</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitLeft</span>((<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>)&nbsp;<span style="font-weight:bold;color:#1f377f;">left</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">name</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">action</span>)&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">left</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Parent</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">PaymentService</span>(<span style="font-weight:bold;color:#1f377f;">name</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">action</span>));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IPaymentType</span>&nbsp;<span style="font-weight:bold;color:#74531f;">VisitRight</span>((<span style="color:blue;">string</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">string</span>))&nbsp;<span style="font-weight:bold;color:#1f377f;">right</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">k</span>,&nbsp;(<span style="font-weight:bold;color:#1f377f;">n</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>))&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">right</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Child</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ChildPaymentService</span>(<span style="font-weight:bold;color:#1f377f;">k</span>,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">PaymentService</span>(<span style="font-weight:bold;color:#1f377f;">n</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">a</span>)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        Here I even had to split one generic type signature over multiple lines, in order to prevent horizontal scrolling. At least you have to grant the C# language that it's flexible enough to allow that.
    </p>
    <p>
        Now that it's possible to translate both ways, a simple tests demonstrates the isomorphism.
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Theory</span>,&nbsp;<span style="color:#2b91af;">ClassData</span>(<span style="color:blue;">typeof</span>(<span style="color:#2b91af;">PaymentTypes</span>))]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">IsomorphismViaEither</span>(<span style="color:#2b91af;">IPaymentType</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">Accept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ToCanonicalPaymentTypeVisitor</span>())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">Accept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">FromCanonicalPaymentTypeVisitor</span>());
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Equal</span>(<span style="font-weight:bold;color:#1f377f;">expected</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>);
}</pre>
    </p>
    <p>
        This test translates an arbitrary <code>IPaymentType</code> into canonical form, then translates that representation back to an <code>IPaymentType</code> value, and checks that the two values are identical. There's no loss of information either way.
    </p>
    <p>
        This and the previous example may seem like a detour around the central point that I'm trying to make: That Result (or Either) is the most boring sum type. I could have made the point, including examples, in a few lines of Haskell, but that language is so efficient at that kind of work that I fear that the syntax would look like pseudocode to programmers used to C-like languages. Additionally, Haskell programmers don't need my help writing small mappings like the ones shown here.
    </p>
    <h3 id="d0317d94363e404bb2b42e9f3c771673">
        Conclusion <a href="#d0317d94363e404bb2b42e9f3c771673">#</a>
    </h3>
    <p>
        Result (or Either) is as a fundamental building block in the context of algebraic data types. As such, this type may be considered the most boring sum type, since it effectively represents any other sum type, up to isomorphism.
    </p>
    <p>
        Object-oriented programmers trying to learn functional programming sometimes struggle to see the light. One barrier to understanding the power of algebraic data types may be related to starting a learning path with Result type. Since <a href="/2025/10/15/result-isomorphism">Results are equivalent to exceptions</a>, people understandably have a hard time seeing how Result values are better. Since Result types are so abstract, it can be difficult to see the wider perspective. This doubly applies if a teacher leads with Result, with it's success/failure semantics, rather than with Either and its more neutral left/right labels.
    </p>
    <p>
        Since Either is the fundamental sum type, it follows that any other sum type, being more specialized, carries more meaning, and therefore may be more interesting, and more illuminating as examples. In this article, I've used a few simple, but specialized sum types with the intention to help the reader see the difference.
    </p>
</div>