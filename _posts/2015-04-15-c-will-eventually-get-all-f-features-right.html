---
layout: post
title: "C# will eventually get all F# features, right?"
description: "C# will never get the important features that F# has. Here's why."
date: 2015-04-15 8:32 UTC
tags: [Languages, F#]
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>{{ page.description }}</em>
  </p>
  <p>
    The relationship between C# and F# is interesting, no matter if you look at it from the C# or the F# perspective:
    <ul>
      <li>
        Before releasing F# to the world, Don Syme, its inventor, was <a href="http://blogs.msdn.com/b/dsyme/archive/2011/03/15/net-c-generics-history-some-photos-from-feb-1999.aspx">instrumental in getting generics into C# and .NET</a>. Had it not been for his and his Cambridge colleagues' effort, we wouldn't have generics today, or we would have the subpar generics that Java has. (Okay, so this point isn't strictly about F#.)
      </li>
      <li>
        F# has had async workflows <a href="http://blogs.msdn.com/b/dsyme/archive/2007/10/11/introducing-f-asynchronous-workflows.aspx">since 2007</a>. In F#, this is simply one of many implementations of a more general language feature called <a href="https://msdn.microsoft.com/en-us/library/dd233182.aspx">Computation Expressions</a> - other common examples are <a href="https://msdn.microsoft.com/en-us/library/dd233209.aspx">Sequence Expressions</a> and <a href="https://msdn.microsoft.com/en-us/library/hh225374.aspx">Query Expressions</a>, but you can also create your own. When async/await was added to C# in 2012, it was a port of that particular implementation, but turned into a one-shot language feature.
      </li>
      <li>
        C# 6 gets <a href="http://blogs.msdn.com/b/csharpfaq/archive/2014/11/20/new-features-in-c-6.aspx">a lot of small language features</a>, some of which F# already has: auto-property initializers, exception filters, expression-bodied function members...
      </li>
      <li>
        For C# 7, <a href="https://github.com/dotnet/roslyn/issues/98">the design team is considering many Functional language features</a> that F# already has: pattern matching, records, immutability, tuples...
      </li>
    </ul>
    <strong>There's nothing wrong with this.</strong> F# is a great language, so obviously it makes sense to look there for inspiration. Some features also go the other way, such as F# Query Expressions, which were inspired by LINQ.
  </p>
  <p>
    It's not some hidden cabal that I'm trying to expose, either. <a href="http://www.dotnetrocks.com/default.aspx?showNum=935">Mads Torgersen has been quite open about this relationship</a>.
  </p>
  <h3 id="5412866cca9348789ebc0a183adaefc7">
    Why care about F#, then? <a href="#5412866cca9348789ebc0a183adaefc7" title="permalink">#</a>
  </h3>
  <p>
    A common reaction to all of this seems to be that if C# eventually gets all the best F# features, there's no reason to care about F#. Just stick with C#, and get those features in the future.
  </p>
  <p>
    The most obvious answer to such statements is that F# already has those features, while you'll have to wait for a long time to get them in C#. While C# 6 gets a few features, they are hardly killer features. So perhaps you'll get the good F# features in C#, but they could be years away, and some features might be postponed to later versions again.
  </p>
  <p>
    In my experience, that argument mostly falls on deaf ears. Many programmers are content to wait, perhaps because they feel that the language choice is out of their hands anyway.
  </p>
  <h3 id="2c00c5e8c7fa4465abf65bf9762af46a">
    What F# features could C# get? <a href="#2c00c5e8c7fa4465abf65bf9762af46a" title="permalink">#</a>
  </h3>
  <p>
    Often, when F# enthusiasts attempt to sell the language to other programmers, they have a long list of language features that F# has, and that (e.g.) C# doesn't have. However, in the future, C# could hypothetically have those features too:
    <ul>
      <li>
        <strong>Records.</strong> C# could have those as well, and they're being considered for C# 7. Implementation-wise, F# records compile to immutable classes anyway.
      </li>
      <li>
        <strong>Discriminated Unions.</strong> Nothing in principle prevents C# from getting those. After all, F# Discriminated Unions compile to a class hierarchy.
      </li>
      <li>
        <strong>Pattern matching</strong> Also being considered for C# 7.
      </li>
      <li>
        <strong>No nulls.</strong> It's a common myth that F# doesn't have nulls. It does. It's even <a href="https://msdn.microsoft.com/en-us/library/dd233249.aspx">a keyword</a>. It's true that F# doesn't allow its <em>Functional</em> data types (records, unions, tuples, etc.) to have null values, but it's only a compiler trick. At run-time, these types can have null values too, and you can provide null values via Reflection. C# could get such a compiler trick as well.
      </li>
      <li>
        <strong>Immutability.</strong> F#'s immutability 'feature' is similar to how it deals with nulls. Lots of F# can be mutable (everything that interacts with C# code), but the special <em>Functional</em> data types can't. Again, it's mostly in how these specific data types are implemented under the hood that provides this feature, and C# could get that as well.
      </li>
      <li>
        <strong>Options.</strong> These are really just specialised Discriminated Unions, so C# could get those too.
      </li>
      <li>
        <strong>Object Expressions.</strong> Java has had those for years, so there's no reason C# couldn't get them as well.
      </li>
      <li>
        <strong>Partial Function Application.</strong> You <a href="/2014/03/10/solid-the-next-step-is-functional">can already do this in C# today, but the syntax for it is really awkward</a>. Thus, there's <em>no technical</em> reason C# can't have that, but the C# language designers would have to come up with a better syntax.
      </li>
      <li>
        <strong>Scripting.</strong> F# is great for scripting, but as the success of <a href="http://scriptcs.net">scriptcs</a> has shown, nothing prevents C# from being a scripting language either.
      </li>
      <li>
        <strong>REPL.</strong> A <a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> is a really nice tool, but scriptcs already comes with a REPL, again demonstrating that C# could have that too.
      </li>
    </ul>
    This list <em>in no way</em> implies that C# will get any or all of these features. While <a href="https://mvp.microsoft.com/en-us/mvp/Mark%20Seemann-5000205">I'm an MVP</a>, I have no inside insight; I'm only speculating. My point is that I see no fundamental reason C# couldn't eventually get those features.
  </p>
  <h3 id="147499af754b4cc8862bfa0762768549">
    What F# features can C# never get? <a href="#147499af754b4cc8862bfa0762768549" title="permalink">#</a>
  </h3>
  <p>
    There are a few F# features that many people point to as their favourite, that C# is unlikely to get. A couple of them are:
    <ul>
      <li>
        <strong>Type Providers.</strong> Someone that I completely trust on this issue told me quite authoritatively that "C# will <em>never</em> get Type Providers", and then laughed quietly. While I don't know enough about the technical details of Type Providers to be able to evaluate that statement, I trust this person completely on this issue.
      </li>
      <li>
        <strong>Units of Measure.</strong> Here, I simply have to confess ignorance. While I haven't seen talk about units of measure for C#, I have no idea whether it's doable or not.
      </li>
    </ul>
    These are some loved features of F# that look unlikely to be ported to C#, but there's one quality of F# that I'm absolutely convinced will <em>never</em> make it to C#, and this is <strong>one of the killer features of F#</strong>: it's what you <em>can't do</em> in the language.
  </p>
  <p>
    In a recent article, I explained how <a href="/2015/04/13/less-is-more-language-features">less is more when it comes to language features</a>. Many languages come with redundant features (often for historical reasons), but the fewer redundant features a language has, the better.
  </p>
  <p>
    The <strong>F# compiler doesn't allow circular dependencies</strong>. You can't use a type or a function before you've defined it. This may seem like a restriction, but is perhaps the most important quality of F#. Cyclic dependencies are closely correlated with coupling, and coupling is the deadliest maintainability killer of code bases.
  </p>
  <p>
    In C# and most other languages, you can define dependency cycles, and the compiler makes it easy for you. In F#, the compiler makes it impossible.
  </p>
  <p>
    <a href="http://fsharpforfunandprofit.com/posts/cycles-and-modularity-in-the-wild">Studies show that F# projects have fewer and smaller cycles</a>, and that <a href="http://evelinag.com/blog/2014/06-09-comparing-dependency-networks">there are types of cycles (motifs) you don't see at all in F# code bases</a>.
  </p>
  <p>
    The F# compiler protects you from making cycles. <strong>C# will never be able to do that</strong>, because it would be a <em>massive breaking change</em>: if the C# compiler was changed to protect you as well, most existing C# code wouldn't be able to compile.
  </p>
  <p>
    Microsoft has never been in the habit of introducing breaking changes, so I'm quite convinced that this will never happen.
  </p>
  <h3 id="63bfbeefb76b45c7ae99e91a4041282c">
    Summary <a href="#63bfbeefb76b45c7ae99e91a4041282c" title="permalink">#</a>
  </h3>
  <p>
    C# could, theoretically, get a lot of the features that F# has, but not the 'feature' that really matters: protection against coupling. Since coupling is one of the most common reasons for <a href="http://en.wikipedia.org/wiki/Software_rot">code rot</a>, this is one of the most compelling reasons to switch to F# today.
  </p>
  <p>
    F# is a great language, not only because of the features it has, but even more so because if the undesirable traits it <em>doesn't</em> have.
  </p>
</div>

<div id="comments">
<hr>
<h2 id="comments-header">Comments</h2>
  <div class="comment" id="c572bc4b29394f918192d5022ea2f93a">
    <div class="comment-author"><a href="http://enterprisecraftsmanship.com/">Vladimir Khorikov</a> <a href="#c572bc4b29394f918192d5022ea2f93a">#</a></div>
    <div class="comment-content">
      <p>I would say C# won't get non-nullable reference types either, even in the form of a compiler trick. It would either introduce too much of breaking changes or be very limited and thus not especially usefull.</p>
    </div>
    <div class="comment-date">2015-04-18 15:36 UTC</div>
  </div>
  <div class="comment" id="8dba4b8c735b4f759331f6064def16ad">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a> <a href="#8dba4b8c735b4f759331f6064def16ad">#</a></div>
    <div class="comment-content">
      <p>
        Vladimir, thank you for writing. You're probably correct. Many years ago, I overheard Anders Hejlsberg say that it wouldn't be possible to introduce non-nullable reference types into the .NET platform without massive breaking changes. I can't say I ever understood the reasoning behind this (nor was it ever explained to me), but when Anders Hejlsberg tells you that, you sort of have to accept it :)
      </p>
      <p>
        FWIW, there's a bit of discussion about non-nullable reference types in the <a href="https://github.com/dotnet/roslyn/issues/98">C# Design Meeting Notes for Jan 21, 2015</a>, but I have to admit that I didn't follow the link to Eric Lippert's blog :$
      </p>
    </div>
    <div class="comment-date">2015-04-18 18:57 UTC</div>
  </div>
</div>
