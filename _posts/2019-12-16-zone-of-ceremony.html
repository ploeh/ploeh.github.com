---
layout: post
title: "Zone of Ceremony"
description: "Static typing doesn't have to involve much ceremony."
date: 2019-12-16 9:51 UTC
tags: [Languages, Code, F#, Haskell]
image: "/content/binary/zone-of-ceremony.png"
image_alt: "A conceptual spectrum of typing, from dynamic on the left, to static on the right. There's a zone of ceremony slightly to the right of the middle with the languages C++, C#, and Java."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		I seem to get involved in long and passionate debates about static versus dynamic typing on a regular basis. I find myself clearly on the side of static typing, but this article isn't about the virtues of static versus dynamic typing. The purpose is to correct a common misconception about statically typed languages.
	</p>
	<h3 id="07df6b539dd24732bd2c1f0038a27a71">
		Ceremony <a href="#07df6b539dd24732bd2c1f0038a27a71" title="permalink">#</a>
	</h3>
	<p>
		People who favour dynamically typed languages over statically typed languages often emphasise that they find the lack of ceremony productive. That seems reasonable; only, it's a false dichotomy.
	</p>
	<p>
		Dynamically typed languages do seem to be light on ceremony, but you can't infer from that that statically typed languages have to require lots of ceremony. Unfortunately, all mainstream statically typed languages belong to the same family, and they <em>do</em> involve ceremony. I think that people extrapolate from what they know; they falsely conclude that all statically typed languages must come with the overhead of ceremony.
	</p>
	<p>
		It looks to me more as though there's an unfortunate <em>Zone of Ceremony</em>:
	</p>
	<p>
		<img src="/content/binary/zone-of-ceremony.png" alt="A conceptual spectrum of typing, from dynamic on the left, to static on the right. There's a zone of ceremony slightly to the right of the middle with the languages C++, C#, and Java.">
	</p>
	<p>
		Such a diagram can never be anything but a simplification, but I hope that it's illuminating. C++, Java, and C# are all languages that involve ceremony. To the right of them are what we could term the <em>trans-ceremonial languages</em>. These include <a href="https://fsharp.org">F#</a> and <a href="https://www.haskell.org">Haskell</a>.
	</p>
	<h3 id="32ff9013011b4c04a24e32d635b55ab2">
		Low ceremony of JavaScript <a href="#32ff9013011b4c04a24e32d635b55ab2" title="permalink">#</a>
	</h3>
	<p>
		Imagine that you're given a list of numbers, as well as a quantity. The quantity is a number to be consumed. You must remove elements from the left until you've consumed at least that quantity. Then return the rest of the list.
	</p>
	<p>
		<pre>&gt; consume ([1,2,3], 1);
[ 2, 3 ]
&gt; consume ([1,2,3], 2);
[ 3 ]
&gt; consume ([1,2,3], 3);
[ 3 ]
&gt; consume ([1,2,3], 4);
[]</pre>
	</p>
	<p>
		The first example consumes only the leading <code>1</code>, while both the second and the third example consumes both <code>1</code> and <code>2</code> because the sum of those values is <code>3</code>, and the requested quantity is <code>2</code> and <code>3</code>, respectively. The fourth example consumes all elements because the requested quantity is <code>4</code>, and you need both <code>1</code>, <code>2</code>, and <code>3</code> before the sum is large enough. You have to pick strictly from the left, so you can't decide to just take the elements <code>1</code> and <code>3</code>.
	</p>
	<p>
		In JavaScript, you could implement the <code>consume</code> function like this:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;consume&nbsp;=&nbsp;<span style="color:blue;">function</span>&nbsp;(source,&nbsp;quantity)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!source)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;[];
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;accumulator&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;result&nbsp;=&nbsp;[];
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">for</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;source.length;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;x&nbsp;=&nbsp;source[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(quantity&nbsp;&lt;=&nbsp;accumulator)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push(x);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accumulator&nbsp;+=&nbsp;x;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;result;
}</pre>
	</p>
	<p>
		I'm a terrible JavaScript programmer, so I'm sure that it could have been done more elegantly, but as far as I can tell, it gets the job done. I wrote some tests, and I have 17 passing test cases. The point isn't about how you write the function, but how much ceremony is required. In JavaScript you don't need to declare any types. Just name the function and its arguments, and you're ready to write code.
	</p>
	<h3 id="2b1bcebf36084abcae5bb231ca0ebe15">
		High ceremony of C# <a href="#2b1bcebf36084abcae5bb231ca0ebe15" title="permalink">#</a>
	</h3>
	<p>
		Contrast the JavaScript example with C#. The same function in C# would look like this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Enumerable</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;<span style="color:#74531f;">Consume</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">source</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">quantity</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">source</span>&nbsp;<span style="color:blue;">is</span>&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">yield</span>&nbsp;<span style="font-weight:bold;color:#8f08c4;">break</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">accumulator</span>&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">i</span>&nbsp;<span style="font-weight:bold;color:#8f08c4;">in</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">source</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">quantity</span>&nbsp;&lt;=&nbsp;<span style="font-weight:bold;color:#1f377f;">accumulator</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">yield</span>&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">i</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">accumulator</span>&nbsp;+=&nbsp;<span style="font-weight:bold;color:#1f377f;">i</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		Here you have to declare the type of each method argument, as well as the return type of the method. You also have to put the method in a class. This may not seem like much overhead, but if you later need to change the types, editing is required. This can affect downstream callers, so simple type changes ripple through code bases.
	</p>
	<p>
		It gets worse, though. The above <code>Consume</code> method only handles <code>int</code> values. What if you need to call the method with <code>long</code> arrays?
	</p>
	<p>
		You'd have to add an overload:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">long</span>&gt;&nbsp;<span style="color:#74531f;">Consume</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">long</span>&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">source</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">long</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">quantity</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">source</span>&nbsp;<span style="color:blue;">is</span>&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">yield</span>&nbsp;<span style="font-weight:bold;color:#8f08c4;">break</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">accumulator</span>&nbsp;=&nbsp;0L;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">i</span>&nbsp;<span style="font-weight:bold;color:#8f08c4;">in</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">source</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">quantity</span>&nbsp;&lt;=&nbsp;<span style="font-weight:bold;color:#1f377f;">accumulator</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">yield</span>&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">i</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">accumulator</span>&nbsp;+=&nbsp;<span style="font-weight:bold;color:#1f377f;">i</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		Do you need support for <code>short</code>? Add an overload. <code>decimal</code>? Add an overload. <code>byte</code>? Add an overload.
	</p>
	<p>
		No wonder people used to dynamic languages find this awkward.
	</p>
	<h3 id="bc9ab1e2693d41678a09cf843436c736">
		Low ceremony of F# <a href="#bc9ab1e2693d41678a09cf843436c736" title="permalink">#</a>
	</h3>
	<p>
		You can write the same functionality in F#:
	</p>
	<p>
		<pre><span style="color:blue;">let</span>&nbsp;<span style="color:blue;">inline</span>&nbsp;consume&nbsp;quantity&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;go&nbsp;(acc,&nbsp;xs)&nbsp;x&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;quantity&nbsp;&lt;=&nbsp;acc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;(acc,&nbsp;Seq.append&nbsp;xs&nbsp;(Seq.singleton&nbsp;x))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;(acc&nbsp;+&nbsp;x,&nbsp;xs)
&nbsp;&nbsp;&nbsp;&nbsp;Seq.fold&nbsp;go&nbsp;(LanguagePrimitives.GenericZero,&nbsp;Seq.empty)&nbsp;&gt;&gt;&nbsp;snd</pre>
	</p>
	<p>
		There's no type declaration in sight, but nonetheless the function is statically typed. It has this somewhat complicated type:
	</p>
	<p>
		<pre>quantity: ^a -&gt; (seq&lt; ^b&gt; -&gt; seq&lt; ^b&gt;)
  when ( ^a or  ^b) : (static member ( + ) :  ^a *  ^b -&gt;  ^a) and
        ^a : (static member get_Zero : -&gt;  ^a) and  ^a : comparison</pre>
	</p>
	<p>
		While this looks arcane, it means that it support sequences of any type that comes with a zero value and supports addition and comparison. You can call it with both 32-bit integers, decimals, and so on:
	</p>
	<p>
		<pre>&gt; consume 2 [1;2;3];;
val it : seq&lt;int&gt; = seq [3]

&gt; consume 2m [1m;2m;3m];;
val it : seq&lt;decimal&gt; = seq [3M]</pre>
	</p>
	<p>
		Static typing still means that you can't just call it with any type of value. An expression like <code>consume "foo" [true;false;true]</code> will not compile.
	</p>
	<p>
		You can explicitly declare types in F# (like you can in C#), but my experience is that if you don't, type changes tend to just propagate throughout your code base. Change a type of a function, and upstream callers generally just 'figure it out'. If you think of functions calling other functions as a graph, you often only have to adjust leaf nodes even when you change the type of something deep in your code base.
	</p>
	<h3 id="e360bba3f4954f6988fd1267c70b78e1">
		Low ceremony of Haskell <a href="#e360bba3f4954f6988fd1267c70b78e1" title="permalink">#</a>
	</h3>
	<p>
		Likewise, you can write the function in Haskell:
	</p>
	<p>
		<pre>consume&nbsp;quantity&nbsp;=&nbsp;<span style="color:blue;">reverse</span>&nbsp;.&nbsp;<span style="color:blue;">snd</span>&nbsp;.&nbsp;<span style="color:blue;">foldl</span>&nbsp;go&nbsp;(0,&nbsp;<span style="color:blue;">[]</span>)
&nbsp;&nbsp;<span style="color:blue;">where</span>
&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;(acc,&nbsp;ys)&nbsp;x&nbsp;=&nbsp;<span style="color:blue;">if</span>&nbsp;quantity&nbsp;&lt;=&nbsp;acc&nbsp;<span style="color:blue;">then</span>&nbsp;(acc,&nbsp;x:ys)&nbsp;<span style="color:blue;">else</span>&nbsp;(acc&nbsp;+&nbsp;x,&nbsp;ys)
</pre>
	</p>
	<p>
		Again, you don't have to explicitly declare any types. The compiler figures them out. You can ask GHCi about the function's type, and it'll tell you:
	</p>
	<p>
		<pre>&gt; :t consume
consume :: (Foldable t, Ord a, Num a) =&gt; a -&gt; t a -&gt; [a]</pre>
	</p>
	<p>
		It's more compact than the inferred F# type, but the idea is the same. It'll compile for any <code>Foldable</code> container <code>t</code> and any type <code>a</code> that belongs to the classes of types called <code>Ord</code> and <code>Num</code>. <code>Num</code> supports addition and <code>Ord</code> supports comparison.
	</p>
	<p>
		There's little ceremony involved with the types in Haskell or F#, yet both languages are statically typed. In fact, their type systems are more powerful than C#'s or Java's. They can express relationships between types that those languages can't.
	</p>
	<h3 id="d215cd3b1cd84ce3877dc88e8ce944be">
		Summary <a href="#d215cd3b1cd84ce3877dc88e8ce944be" title="permalink">#</a>
	</h3>
	<p>
		In debates about static versus dynamic typing, contributors often generalise from their experience with C++, Java, or C#. They dislike the amount of ceremony required in these languages, but falsely believe that it means that you can't have static types without ceremony.
	</p>
	<p>
		The statically typed mainstream languages seem to occupy a <em>Zone of Ceremony</em>.
	</p>
	<p>
		Static typing without ceremony is possible, as evidenced by languages like F# and Haskell. You could call such languages <em>trans-ceremonial languages</em>. They offer the best of both worlds: compile-time checking and little ceremony.
	</p>
</div>
