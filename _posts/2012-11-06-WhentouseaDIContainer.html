---
layout: post
tags: [Castle Windsor, Dependency Injection]
date: 2012-11-06 11:42:06 UTC
title: "When to use a DI Container"
description: "This post explains why a DI Container is useful with Convention over Configuration while Poor Man's DI might be a better fit for a more explicit Composition Root."
image: "/content/binary/usefulness-sophistication.png"
image_alt: "usefulness vs. sophistication"
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		<strong>Note</strong> (2018-07-18): Since I wrote this article, I've <a href="/2014/06/10/pure-di">retired the term <em>Poor Man's DI</em> in favour of <em>Pure DI</em></a>.
	</p>
	<p>
		It seems to me that lately there's been a backlash against DI Containers among alpha geeks. Many of the software leaders that I myself learn from seem to dismiss the entire concept of a DI Container, claiming that it's too complex, too 'magical', that it isn't a good architectural pattern, or that the derived value doesn't warrant the 'cost' (most, if not all, DI Containers are open source, so they are free in a monetary sense, but there's always a cost in learning curve etc.).
	</p>
	<p>
		This must have caused <a href="http://kozmic.pl">Krzysztof Koźmic</a> to write <a href="http://kozmic.pl/2012/10/23/ioc-container-solves-a-problem-you-might-not-have-but-its-a-nice-problem-to-have/">a nice article about what sort of problem a DI Container solves</a>. I agree with the article, but want to provide a different perspective here.
	</p>
	<p>
		In short, it makes sense to me to illustrate the tradeoffs of Poor Man's DI versus DI Containers in a diagram like this:</p>

	<p><img src="/content/binary/usefulness-sophistication.png" alt="usefulness vs. sophistication" border="0" height="454" width="661"></p>
	<p>
		The point of the diagram is that Poor Man's DI can be valuable because it's simple, while a DI Container can be either valuable or pointless depending on how it's used. However, when used in a sufficiently sophisticated way I consider a DI Container to offer the best value/cost ratio. When people criticize DI Containers as being pointless I suspect that what really happened was that they gave up before they were out of the <a href="http://en.wikipedia.org/wiki/Hype_cycle">Trough of Disillusionment</a>. Had they continued to learn, they might have arrived at a new Plateau of Productivity.
	</p>
	<p>
		<table border="1">
			<thead>
				<tr align="left" valign="top">
					<th>DI style</th>
					<th>Advantages</th>
					<th>Disadvantages</th>
				</tr>
			</thead>
			<tbody>
				<tr align="left" valign="top">
					<td>Poor Man's DI</td>
					<td>
						<ul>
							<li>Easy to learn</li>
							<li>Strongly typed</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>High maintenance</li>
						</ul>
					</td>
				</tr>
				<tr align="left" valign="top">
					<td>Explicit Register</td>
					<td>
					<br></td>
					<td>
						<ul>
							<li>Weakly typed</li>
						</ul>
					</td>
				</tr>
				<tr align="left" valign="top">
					<td>Convention over Configuration</td>
					<td>
						<ul>
							<li>Low maintenance</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>Hard to learn</li>
							<li>Weakly typed</li>
						</ul>
					</td>
				</tr>
			</tbody>
		</table>
	</p>
	<p>
		There are other, less important advantages and disadvantages of each approach, but here I'm focusing on three main axes that I consider important:
	</p>
	<p>
		<ul>
			<li>How easy is it to understand and learn?</li>
			<li>How soon will you get feedback if something is not right?</li>
			<li>How easy is it to maintain?</li>
		</ul>
	</p>
	<p>
		The major advantage of Poor Man's DI is that it's easy to learn. You don't have to learn the API of any DI Container (Unity, Autofac, Ninject, StructureMap, Castle Windsor, etc.) and while individual classes still use DI, once you find the <a href="/2011/07/28/CompositionRoot.aspx">Composition Root</a> it'll be evident what's going on and how object graphs are constructed. No 'magic' is involved.
	</p>
	<p>
		The second big advantage of Poor Man's DI is often overlooked: it's strongly typed. This is an advantage because <a href="/2011/04/29/FeedbackMechanismsAndTradeoffs.aspx">it provides the fastest feedback about correctness that you can get</a>. However, strong typing cuts both ways because it also means that every time you refactor a constructor, you will break the Composition Root. If you are sharing a library (Domain Model, Utility, Data Access component, etc.) between more than one application (unit of deployment), you may have more than one Composition Root to maintain. How much of a burden this is depends on how often you refactor constructors, but I've seen projects where this happens several times each day (keep in mind that <a href="/2011/02/28/InterfacesAreAccessModifiers.aspx">constructor are implementation details</a>).
	</p>
	<p>
		If you use a DI Container, but explicitly Register each and every component using the container's API, you lose the rapid feedback from strong typing. On the other hand, the maintenance burden is also likely to drop because of <em>Auto-wiring</em>. Still, you'll need to register each new class or interface when you introduce them, and you (and your team) still has to learn the specific API of that container. In my opinion, you lose more advantages than you gain.
	</p>
	<p>
		Ultimately, if you can wield a DI Container in a sufficiently sophisticated way, you can use it to define a set of conventions. These conventions define a rule set that your code should adhere to, and as long as you stick to those rules, <em>things just work</em>. The container drops to the background, and you rarely need to touch it. Yes, this is hard to learn, and is still weakly typed, but if done right, it enables you to focus on code that adds value instead of infrastructure. An additional advantage is that it creates a positive feedback mechanism forcing a team to produce code that is consistent with the conventions.
	</p>
	<h3 id="0c19d443c1ad4fd6a4c7883dcc9abb3c">
		Example: Poor Man's DI <a href="#0c19d443c1ad4fd6a4c7883dcc9abb3c" title="permalink">#</a>
	</h3>
	<p>
		The following example is part of my <a href="https://github.com/ploeh/Booking">Booking sample application</a>. It shows <a href="https://github.com/ploeh/Booking/blob/64b7b670fff9560d8947dd133ae54779d867a451/BookingDaemon/Program.cs">the state of the Ploeh.Samples.Booking.Daemon.Program class as it looks in the git tag <em>total-complexity</em> (git commit ID 64b7b670fff9560d8947dd133ae54779d867a451)</a>.
	</p>
	<p>
		<pre style="margin: 0px;"><span style="color: blue;">var</span> queueDirectory = 
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\Queue"</span>).CreateIfAbsent();
<span style="color: blue;">var</span> singleSourceOfTruthDirectory = 
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\SSoT"</span>).CreateIfAbsent();
<span style="color: blue;">var</span> viewStoreDirectory = 
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\ViewStore"</span>).CreateIfAbsent();
&nbsp;
<span style="color: blue;">var</span> extension = <span style="color: #a31515;">"txt"</span>;
&nbsp;
<span style="color: blue;">var</span> fileDateStore = <span style="color: blue;">new</span> <span style="color: #2b91af;">FileDateStore</span>(
&nbsp;&nbsp;&nbsp; singleSourceOfTruthDirectory,
&nbsp;&nbsp;&nbsp; extension);
&nbsp;
<span style="color: blue;">var</span> quickenings = <span style="color: blue;">new</span> <span style="color: #2b91af;">IQuickening</span>[]
{
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">RequestReservationCommand</span>.<span style="color: #2b91af;">Quickening</span>(),
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">ReservationAcceptedEvent</span>.<span style="color: #2b91af;">Quickening</span>(),
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">ReservationRejectedEvent</span>.<span style="color: #2b91af;">Quickening</span>(),
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">CapacityReservedEvent</span>.<span style="color: #2b91af;">Quickening</span>(),
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">SoldOutEvent</span>.<span style="color: #2b91af;">Quickening</span>()
};
&nbsp;
<span style="color: blue;">var</span> disposable = <span style="color: blue;">new</span> <span style="color: #2b91af;">CompositeDisposable</span>();
<span style="color: blue;">var</span> messageDispatcher = <span style="color: blue;">new</span> <span style="color: #2b91af;">Subject</span>&lt;<span style="color: blue;">object</span>&gt;();
disposable.Add(
&nbsp;&nbsp;&nbsp; messageDispatcher.Subscribe(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">Dispatcher</span>&lt;<span style="color: #2b91af;">RequestReservationCommand</span>&gt;(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">CapacityGate</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">JsonCapacityRepository</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fileDateStore,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fileDateStore,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; quickenings),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">JsonChannel</span>&lt;<span style="color: #2b91af;">ReservationAcceptedEvent</span>&gt;(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">FileQueueWriter</span>&lt;<span style="color: #2b91af;">ReservationAcceptedEvent</span>&gt;(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; queueDirectory,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; extension)),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">JsonChannel</span>&lt;<span style="color: #2b91af;">ReservationRejectedEvent</span>&gt;(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">FileQueueWriter</span>&lt;<span style="color: #2b91af;">ReservationRejectedEvent</span>&gt;(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; queueDirectory,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; extension)),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">JsonChannel</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">FileQueueWriter</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; queueDirectory,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; extension))))));
disposable.Add(
&nbsp;&nbsp;&nbsp; messageDispatcher.Subscribe(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">Dispatcher</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">MonthViewUpdater</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">FileMonthViewStore</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; viewStoreDirectory,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; extension)))));
&nbsp;
<span style="color: blue;">var</span> q = <span style="color: blue;">new</span> <span style="color: #2b91af;">QueueConsumer</span>(
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">FileQueue</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; queueDirectory,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; extension),
&nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">JsonStreamObserver</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; quickenings,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; messageDispatcher));
&nbsp;
RunUntilStopped(q);</pre>
	</p>
	<p>
		Yes, that's a lot of code. I deliberately chose a non-trivial example to highlight just how much stuff there might be. You don't have to read and understand all of this code to appreciate that it might require a bit of maintenance. It's a big object graph, with some shared subgraphs, and since it uses the <em>new</em> keyword to create all the objects, every time you change a constructor signature, you'll need to update this code, because it's not going to compile until you do.
	</p>
	<p>
		Still, there's no 'magical' tool (read: DI Container) involved, so it's pretty easy to understand what's going on here. As <a href="http://dannorth.net/">Dan North</a> put it once I saw him endorse this technique: <em>'new' is the new 'new'</em> :) Once you see how Explicit Register looks, you may appreciate why.
	</p>
	<h3 id="1bf4c3cc11564bccb1b79faa67cdd47b">
		Example: Explicit Register <a href="#1bf4c3cc11564bccb1b79faa67cdd47b" title="permalink">#</a>
	</h3>
	<p>
		The following example performs exactly the same work as the previous example, but now in a <a href="https://github.com/ploeh/Booking/blob/13fc576b729cdddd5ec53f1db907ec0a7d00836b/BookingDaemon/DaemonWindsorInstaller.cs">state (git tag: controllers-by-convention; commit ID: 13fc576b729cdddd5ec53f1db907ec0a7d00836b)</a> where it's being wired by <a href="http://docs.castleproject.org/Windsor.MainPage.ashx">Castle Windsor</a>. The name of this class is DaemonWindsorInstaller, and all components are explictly registered. Hang on to something.
	</p>
	<p>
		<pre style="margin: 0px;">container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">DirectoryInfo</span>&gt;()
&nbsp;&nbsp;&nbsp; .UsingFactoryMethod(() =&gt;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\Queue"</span>).CreateIfAbsent())
&nbsp;&nbsp;&nbsp; .Named(<span style="color: #a31515;">"queueDirectory"</span>));
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">DirectoryInfo</span>&gt;()
&nbsp;&nbsp;&nbsp; .UsingFactoryMethod(() =&gt;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\SSoT"</span>).CreateIfAbsent())
&nbsp;&nbsp;&nbsp; .Named(<span style="color: #a31515;">"ssotDirectory"</span>));
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">DirectoryInfo</span>&gt;()
&nbsp;&nbsp;&nbsp; .UsingFactoryMethod(() =&gt;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\ViewStore"</span>).CreateIfAbsent())
&nbsp;&nbsp;&nbsp; .Named(<span style="color: #a31515;">"viewStoreDirectory"</span>));&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IQueue</span>&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">FileQueue</span>&gt;()
&nbsp;&nbsp;&nbsp; .DependsOn(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnComponent(<span style="color: #a31515;">"directory"</span>, <span style="color: #a31515;">"queueDirectory"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnValue(<span style="color: #a31515;">"extension"</span>, <span style="color: #a31515;">"txt"</span>)));
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IStoreWriter</span>&lt;<span style="color: #2b91af;">DateTime</span>&gt;, <span style="color: #2b91af;">IStoreReader</span>&lt;<span style="color: #2b91af;">DateTime</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">FileDateStore</span>&gt;()
&nbsp;&nbsp;&nbsp; .DependsOn(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnComponent(<span style="color: #a31515;">"directory"</span>, <span style="color: #a31515;">"ssotDirectory"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnValue(<span style="color: #a31515;">"extension"</span>, <span style="color: #a31515;">"txt"</span>)));
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IStoreWriter</span>&lt;<span style="color: #2b91af;">ReservationAcceptedEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">FileQueueWriter</span>&lt;<span style="color: #2b91af;">ReservationAcceptedEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .DependsOn(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnComponent(<span style="color: #a31515;">"directory"</span>, <span style="color: #a31515;">"queueDirectory"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnValue(<span style="color: #a31515;">"extension"</span>, <span style="color: #a31515;">"txt"</span>)));
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IStoreWriter</span>&lt;<span style="color: #2b91af;">ReservationRejectedEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">FileQueueWriter</span>&lt;<span style="color: #2b91af;">ReservationRejectedEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .DependsOn(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnComponent(<span style="color: #a31515;">"directory"</span>, <span style="color: #a31515;">"queueDirectory"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnValue(<span style="color: #a31515;">"extension"</span>, <span style="color: #a31515;">"txt"</span>)));
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IStoreWriter</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">FileQueueWriter</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .DependsOn(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnComponent(<span style="color: #a31515;">"directory"</span>, <span style="color: #a31515;">"queueDirectory"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnValue(<span style="color: #a31515;">"extension"</span>, <span style="color: #a31515;">"txt"</span>)));
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IChannel</span>&lt;<span style="color: #2b91af;">ReservationAcceptedEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">JsonChannel</span>&lt;<span style="color: #2b91af;">ReservationAcceptedEvent</span>&gt;&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IChannel</span>&lt;<span style="color: #2b91af;">ReservationRejectedEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">JsonChannel</span>&lt;<span style="color: #2b91af;">ReservationRejectedEvent</span>&gt;&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IChannel</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">JsonChannel</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;&gt;());
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">ICapacityRepository</span>&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">JsonCapacityRepository</span>&gt;());
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IConsumer</span>&lt;<span style="color: #2b91af;">RequestReservationCommand</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">CapacityGate</span>&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IConsumer</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">MonthViewUpdater</span>&gt;());
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">Dispatcher</span>&lt;<span style="color: #2b91af;">RequestReservationCommand</span>&gt;&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">Dispatcher</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;&gt;());
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IObserver</span>&lt;<span style="color: #2b91af;">Stream</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">JsonStreamObserver</span>&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IObserver</span>&lt;<span style="color: #2b91af;">DateTime</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">FileMonthViewStore</span>&gt;()
&nbsp;&nbsp;&nbsp; .DependsOn(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnComponent(<span style="color: #a31515;">"directory"</span>, <span style="color: #a31515;">"viewStoreDirectory"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Dependency</span>.OnValue(<span style="color: #a31515;">"extension"</span>, <span style="color: #a31515;">"txt"</span>)));
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IObserver</span>&lt;<span style="color: blue;">object</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .UsingFactoryMethod(k =&gt;
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> messageDispatcher = <span style="color: blue;">new</span> <span style="color: #2b91af;">Subject</span>&lt;<span style="color: blue;">object</span>&gt;();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; messageDispatcher.Subscribe(k.Resolve&lt;<span style="color: #2b91af;">Dispatcher</span>&lt;<span style="color: #2b91af;">RequestReservationCommand</span>&gt;&gt;());
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; messageDispatcher.Subscribe(k.Resolve&lt;<span style="color: #2b91af;">Dispatcher</span>&lt;<span style="color: #2b91af;">SoldOutEvent</span>&gt;&gt;());
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> messageDispatcher;
&nbsp;&nbsp;&nbsp; }));
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IQuickening</span>&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">RequestReservationCommand</span>.<span style="color: #2b91af;">Quickening</span>&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IQuickening</span>&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">ReservationAcceptedEvent</span>.<span style="color: #2b91af;">Quickening</span>&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IQuickening</span>&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">ReservationRejectedEvent</span>.<span style="color: #2b91af;">Quickening</span>&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IQuickening</span>&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">CapacityReservedEvent</span>.<span style="color: #2b91af;">Quickening</span>&gt;());
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IQuickening</span>&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">SoldOutEvent</span>.<span style="color: #2b91af;">Quickening</span>&gt;());
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">QueueConsumer</span>&gt;());
&nbsp;
container.Kernel.Resolver.AddSubResolver(<span style="color: blue;">new</span> <span style="color: #2b91af;">CollectionResolver</span>(container.Kernel));</pre>
	</p>
	<p>
		This is actually more verbose than before - almost double the size of the Poor Man's DI example. To add spite to injury, this is no longer strongly typed in the sense that you'll no longer get any compiler errors if you change something, but a change to your classes can easily lead to a runtime exception, since something may not be correctly configured.
	</p>
	<p>
		This example uses the Registration API of Castle Windsor, but imagine the horror if you were to use XML configuration instead.
	</p>
	<p>
		Other DI Containers have similar Registration APIs (apart from those that <em>only</em> support XML), so this problem isn't isolated to Castle Windsor only. It's inherent in the Explicit Register style.
	</p>
	<p>
		I can't claim to be an expert in Java, but all I've ever heard and seen of DI Containers in Java (Spring, Guice, Pico), they don't seem to have Registration APIs much more sophisticated than that. In fact, many of them still seem to be heavily focused on XML Registration. If that's the case, it's no wonder many software thought leaders (like Dan North with his <em>'new' is the new 'new'</em> line) dismiss DI Containers as being essentially pointless. If there weren't a more sophisticated option, I would tend to agree.
	</p>
	<h3 id="18bf234f55a7492cb9ef1bc87a3b9742">
		Example: Convention over Configuration <a href="#18bf234f55a7492cb9ef1bc87a3b9742" title="permalink">#</a>
	</h3>
	<p>
		This is still the same example as before, but now <a href="https://github.com/ploeh/Booking/blob/0a7e6f246cacdbefc8f6933fc84b024774d02038/BookingDaemon/DaemonWindsorInstaller.cs">in a state (git tag: services-by-convention-in-daemon; git commit ID: 0a7e6f246cacdbefc8f6933fc84b024774d02038)</a> where almost the entire configuration is done by convention.
	</p>
	<p>
		<pre style="margin: 0px;">container.AddFacility&lt;<span style="color: #2b91af;">ConsumerConvention</span>&gt;();
&nbsp;
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">IObserver</span>&lt;<span style="color: blue;">object</span>&gt;&gt;()
&nbsp;&nbsp;&nbsp; .ImplementedBy&lt;<span style="color: #2b91af;">CompositeObserver</span>&lt;<span style="color: blue;">object</span>&gt;&gt;());
&nbsp;
container.Register(<span style="color: #2b91af;">Classes</span>
&nbsp;&nbsp;&nbsp; .FromAssemblyInDirectory(<span style="color: blue;">new</span> <span style="color: #2b91af;">AssemblyFilter</span>(<span style="color: #a31515;">"."</span>).FilterByName(an =&gt; an.Name.StartsWith(<span style="color: #a31515;">"Ploeh.Samples.Booking"</span>)))
&nbsp;&nbsp;&nbsp; .Where(t =&gt; !(t.IsGenericType &amp;&amp; t.GetGenericTypeDefinition() == <span style="color: blue;">typeof</span>(<span style="color: #2b91af;">Dispatcher</span>&lt;&gt;)))
&nbsp;&nbsp;&nbsp; .WithServiceAllInterfaces());
&nbsp;
container.Kernel.Resolver.AddSubResolver(<span style="color: blue;">new</span> <span style="color: #2b91af;">ExtensionConvention</span>());
container.Kernel.Resolver.AddSubResolver(<span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryConvention</span>(container.Kernel));
container.Kernel.Resolver.AddSubResolver(<span style="color: blue;">new</span> <span style="color: #2b91af;">CollectionResolver</span>(container.Kernel));
&nbsp;
<span style="color: blue;">#region</span> Manual configuration that requires maintenance
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">DirectoryInfo</span>&gt;()
&nbsp;&nbsp;&nbsp; .UsingFactoryMethod(() =&gt;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\Queue"</span>).CreateIfAbsent())
&nbsp;&nbsp;&nbsp; .Named(<span style="color: #a31515;">"queueDirectory"</span>));
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">DirectoryInfo</span>&gt;()
&nbsp;&nbsp;&nbsp; .UsingFactoryMethod(() =&gt;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\SSoT"</span>).CreateIfAbsent())
&nbsp;&nbsp;&nbsp; .Named(<span style="color: #a31515;">"ssotDirectory"</span>));
container.Register(<span style="color: #2b91af;">Component</span>
&nbsp;&nbsp;&nbsp; .For&lt;<span style="color: #2b91af;">DirectoryInfo</span>&gt;()
&nbsp;&nbsp;&nbsp; .UsingFactoryMethod(() =&gt;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">DirectoryInfo</span>(<span style="color: #a31515;">@"..\..\..\BookingWebUI\ViewStore"</span>).CreateIfAbsent())
&nbsp;&nbsp;&nbsp; .Named(<span style="color: #a31515;">"viewStoreDirectory"</span>));
<span style="color: blue;">#endregion</span></pre>
	</p>
	<p>
		It's pretty clear that this is a lot less verbose - and then I even left three explicit Register statements as a deliberate decision. Just because you decide to use Convention over Configuration doesn't mean that you have to stick to this principle 100 %.
	</p>
	<p>
		Compared to the previous example, this requires a lot less maintenance. While you are working with this code base, most of the time you can concentrate on adding new functionality to the software, and the conventions are just going to pick up your changes and new classes and interfaces. Personally, this is where I find the best tradeoff between the value provided by a DI Container versus the cost of figuring out how to implement the conventions. You should also keep in mind that once you've learned to use a particular DI Container like this, the cost goes down.
	</p>
	<h3 id="537bb32ea3b44263a98fcb039465aa5f">
		Summary <a href="#537bb32ea3b44263a98fcb039465aa5f" title="permalink">#</a>
	</h3>
	<p>
		Using a DI Container to compose object graphs by convention presents an unparalled opportunity to push infrastructure code to the background. However, if you're not prepared to go all the way, Poor Man's DI may actually be a better option. Don't use a DI Container just to use one. Understand the value and cost associated with it, and always keep in mind that Poor Man's DI is a valid alternative.
	</p>
</div>
	
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	<div class="comment" id="c78e679fcb5c49b6adeb59b2f4af5381">
		<div class="comment-author"><a href="http://www.cauthon.com">Darren Cauthon</a></div>
		<div class="comment-content">I'd offer a different suggestion:  Try writing a test for every line of code you write.  Then tell me how Poor Man's DI works out for you.<br>
	<br>
	Testing usually seems to be the pressure release for not using an IoC container in a static language.  Even if it's just a matter of not writing the tests for the overridden constructor, testing is usually thrown out.  And in a world without tests, Poor Man's DI (or not DI at all) is often the &quot;simpler&quot; solution.  Less lines of code, &quot;it just works,&quot; etc etc.  There are lots of options when you only look at the implementation without concern about how one is to provide automated verification against regressions.<br>
	<br>
	If using TDD or even just &quot;testing,&quot; an IoC container is always the simpler solution.  Unless, of course -- if you just switch to a language or framework that lets you do both.  *cough* ruby *cough* python *cough* dynamic languages *cough*</div>
		<div class="comment-date">2012-11-06 17:00 UTC</div>
	</div>
	<div class="comment" id="e76b311de6674a339cac7083095c74fa">
		<div class="comment-author">Daniel Hilgarth</div>
		<div class="comment-content">Very good article, thank you!<br>
	<br>
	<br>
	Just to add another perspective:<br>
	<br>
	I created some extension methods in one of my core libraries that registers everything that ends with Service, Factory, Provider etc. Additionally, I created some extension methods for special areas like NHibernate or AutoMapping.<br>
	<br>
	With these extension methods and a project that adheres to these conventions, my composition roots are very short and need virtually no maintenance.<br>
	<br>
	I have successfully used this approach in several mid to big sized projects. It just works, I wouldn't want to work without a DI container anymore as it would cost so much more time.</div>
		<div class="comment-date">2012-11-06 19:53 UTC</div>
	</div>
	<div class="comment" id="a1031875ea2049dfa8c78f6bd2428f69">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">Darren, thank you for your comment. How do you think TDD fits into this discussion? Which overloaded constructors? If you examine the git repo behind these samples, you should find that I didn't change the production code between the three examples. It's the same production code - the same classes, the same constructors, etc. - just wired in three different ways.</div>
		<div class="comment-date">2012-11-06 20:52 UTC</div>
	</div>
	<div class="comment" id="39980ec8761a4fa89b7dd752fbda1cdd">
		<div class="comment-author"><a href="http://www.cauthon.com">Darren Cauthon</a></div>
		<div class="comment-content">Every time I've heard of Poor Man's DI, it's always described the practice of creating two constructors:  <br>
	<br>
	1.)  A constructor with no arguments.  Dependencies are initialized in the constructor.  This constructor can be used to instantiate the object like &quot;myThing = new MyThing();&quot;  This is not using DI at all.  <br>
	<br>
	2.)  A constructor with arguments for each dependency.  Dependencies are passed in.  This constructor is used for testing, since it actually uses DI.<br>
	<br>
	This &quot;Poor Man's DI&quot; is a concept because it's a cheap way to get DI into a class that may not have originally been written to support DI.  In a way, it seems to give devs the best of both worlds.  Users can still instantiate the class simply, but users can also test it.  It sounds fine, but it has some issues because the class is still bound to its dependencies and because the implementation uses different code than the tests.<br>
	<br>
	Looking deeper at your example, I see that's not what your &quot;Poor Man's DI&quot; example is.  Your way is fully testable, but I don't think its deserving of the extra &quot;Poor Man's DI&quot; moniker because it's just hand-rolled class instantiation.  Or to put it another way:  If your code is an example of &quot;Poor Man's DI,&quot; then wouldn't any DI that wasn't handled through an IoC container?  You are just creating objects with code -- nothing special.  (or wrong, either)<br>
	<br>
	If that's what &quot;Poor Man's DI&quot; means, there should probably be a new phrase to identify the practice that I've seen the phrase tied to -- as it's a &quot;special&quot; and unique practice.  (Take that however you will. :) )</div>
		<div class="comment-date">2012-11-07 01:02 UTC</div>
	</div>
	<div class="comment" id="bc837668fa774099b29ed33ae301e151">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">Darren, I'll refer you to <a href="http://stackoverflow.com/a/7102651/126014">this answer</a> for further details on the terminology choice. You do have a point, but I'm sticking to the terminology from <a href="http://amzn.to/12p90MG">my book</a>.</div>
		<div class="comment-date">2012-11-07 08:17 UTC</div>
	</div>
	<div class="comment" id="f498d27db66841a79155e9a825f51509">
		<div class="comment-author"><a href="http://www.cauthon.com">Darren Cauthon</a></div>
		<div class="comment-content">I guess people can call things whatever they want.  I've seen &amp; heard many references to the two-constructor pattern as Poor Man's DI and for a long time, but this is the first time I've seen the phrase used in your way.  It's also the basic first time I've seen basic class instantiation given a special name.  <br>
	<br>
	Now that I think about it,the concept of &quot;Poor Man's DI&quot; and &quot;Bastard Injection&quot; seem to refer to different things.  Given your definition, Poor Man's DI basically seems to mean that I don't use an IoC container.  It's a concept defining the method in which the object is created.  But Bastard Injection refers to what I think would be the more common use of &quot;Poor Man's DI,&quot; the practice of creating two constructors.  It's a concept defining the method in which the class itself is written.   I guess, then, it's possible for me to use Bastard Injection with Poor Man's DI, so long as I don't call the default constructor?  <br>
	<br>
	As one more side note:  I really don't like the name &quot;Bastard Injection&quot; due to the coarse language.  I know it's an anti-pattern, but &quot;bastard&quot; is a word I'd never ever accept from myself or other developers in a professional setting, especially with a client.  I just asked my wife, an public elementary school teacher and librarian, and she said that word would not be accepted in her class or at any school she's been at.  I don't think it's helpful to give PG13-level words to programming concepts. :)</div>
		<div class="comment-date">2012-11-07 13:04 UTC</div>
	</div>
	<div class="comment" id="79a7065cc57b47acbc9683b61a86215f">
		<div class="comment-author"><a href="http://www.truewill.net/myblog/index.php">Bill Sorensen</a></div>
		<div class="comment-content">Another thoughtful article; thank you!<br>
	<br>
	How do considerations of lifetime management factor in? I may want Singleton here, Transient there, etc. That would seem to favor Explicit Register.<br>
	<br>
	There's also the option of integration-testing the Composition Root to provide some type-checking.</div>
		<div class="comment-date">2012-11-09 18:51 UTC</div>
	</div>
	<div class="comment" id="30b3d1997173457fa8ccf44b7902f558">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">Bill, thanks for your comment.<br>
	<br>
	When it comes to lifetime management, there are answers on more than one level.<br>
	<br>
	On the pragmatic level, I've often found that in reality, most of my graphs tend to need to be Transient (or Per Graph) because some commonly used leaf node must be Transient (or Per Graph) for whatever reason. Once that happens, if most (say: more than 75%) of all objects are already Transient, does it really matter if a few more are also Transient? Yes, it could have been more efficient, but if you profile your app, you're most likely to discover that your bottleneck is somewhere else entirely.<br>
	<br>
	On a more explicit level, it would be possible to define a convention that picks up a hint about the desired lifetime from the type itself. You could for example call a service &quot;ThreadSafeFoo&quot; to hint that Singleton would be appropriate - or perhaps you could adorn it with a [ThreadSafe] attribute...<br>
	<br>
	Testing the container itself <a href="/2011/12/21/TestingContainerConfigurations.aspx">I don't find particularly useful</a>, but a set of smoke tests of the entire app can be helpful.</div>
		<div class="comment-date">2012-11-11 18:03 UTC</div>
	</div>
	<div class="comment" id="c4311b858daf4376ba01bb886460ad05">
		<div class="comment-author"><a href="http://arialdomartini.wordpress.com">Arialdo Martini</a></div>
		<div class="comment-content">Good points, Mark, original perspective.<br />
	I may be wrong, but reading your post I understand that the goal of a DI Container is to compose object graphs. This is undoubtedly true. Yet I think that this is just one of DI Containers' goals, and possibly not even the main one.<br /><br />
	I'm sure you already know the amazing post <a href="http://nblumhardt.com/2011/01/an-autofac-lifetime-primer/">An Autofac Lifetime Primer</a> by Nicholas Blumhardt. It is about AutoFac, but it covers principles that are common to all the CI Containers.<br/>
	Reading Nicholas post what I get is that a CI Container is a tool whose main goal is to manage resources lifetimes. Nicholas defines a resource as "<i>anything with acquisition and release phases in its lifecycle</i>". IoC Containers "<i>provide a good solution to the resource management problem</i>" and "<i>to do this, they need to take ownership of the disposable components that they create</i>". In other words, not only do DI Containers compose object graphs, but they also take care of the lifecycle of objects they created. Nicholas post is very detailed in explaining how and why a DI Container must track resources and guarantee that their disposal is properly managed.<br />
	This is an excerpt I find particurarly significant:<br/><br/>

	"[...] you need to find a strategy to ensure resources are disposed when they’re no longer required. The most widely-attempted one is based around the idea that whatever object acquires the resource should also release it. I pejoratively call it “ad-hoc” because it doesn’t work consistently. Eventually you’ll come up against one (and likely more) of the following issues:<br/>

	<strong>Sharing</strong>: When multiple independent components share a resource, it is very hard to figure out when none of them requires it any more. Either a third party will have to know about all of the potential users of the resource, or the users will have to collaborate. Either way, things get hard fast.<br/>

	<strong>Cascading Changes</strong>: Let’s say we have three components – A uses B which uses C. If no resources are involved, then no thought needs to be given to how resource ownership or release works. But, if the application changes so that C must now own a disposable resource, then both A and B will probably have to change to signal appropriately (via disposal) when that resource is no longer needed. The more components involved, the nastier this one is to unravel."<br/><br/>

	CI Containers solve these problems.<br/>
	Poor Man (or Pure) CI solves the compose phase only. But the CI should also take care of resource disposal, or it would not provide any Unit of Work and possibly lead to memory leaks or NullPointerExceptions at runtime.  What a basic Por Man implementation provides is just an Instance Per Dependency Scope (every request gets a new instance). With few modificatios, it could provide a Single Instance Scope (that is, a Singleton). But you might agree that managing nested scopes, shared dependencies, instances per web request and a proper disposal management with a Poor Man CI is all but a simple task.<br/><br/>
	So, I'm not sure the distinction between Poor Man and DI Containers is only a matter of Convention over Configuration. I got to the conclusion that the main goal of a DI Container is lifecycle management, much more than object graph composition.<br/><br/>
	What do you think?


	    </div>
		<div class="comment-date">2015-08-18 7:06 UTC</div>
	</div>
	<div class="comment" id="59fbde8a85c74fad8f614dc470458eb9">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>Arialdo, thank you for writing.</p>
			<p>
				Like you, I used to think that lifetime management was an strong motivation to use a DI Container; there's an entire chapter about lifetime management in <a href="http://amzn.to/12p90MG">my book</a>.
			</p>
			<p>
				There may be cases where that's true, but these days I prefer the <a href="/2014/06/03/compile-time-lifetime-matching">the explicit lifetime matching I get from Pure DI</a>.
			</p>
			<p>
				While you can make lifetime management quite complicated, I prefer to keep it simple, so in practice, I only use the Singleton and Transient lifetime styles. Additionally, I prefer to design my components so that they aren't disposable. If I <em>must</em> use a disposable third-party object, my next priority would be to use a <a href="/2014/08/24/decoraptor">Decoraptor</a>, and add <a href="/2014/08/25/decommissioning-decoraptors">decommissioning support</a> if necessary. Only if none of that is possible will I begin to look at disposal from the Composition Root.
			</p>
			<p>
				Usually, when you only use Singleton and Transient, manual disposal from the Composition Root is easy. There's no practical reason to dispose of the Singletons, so you only need to dispose of the Transient objects. How you do that varies from framework to framework, but in ASP.NET Web API, for example, <a href="/2012/09/28/DependencyInjectionandLifetimeManagementwithASP.NETWebAPI">it's easy</a>.
			</p>
		</div>
		<div class="comment-date">2015-08-18 08:41 UTC</div>
	</div>
</div>
