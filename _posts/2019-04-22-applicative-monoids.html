---
layout: post
title: "Applicative monoids"
description: "An applicative functor containing monoidal values itself forms a monoid."
date: 2019-04-22 5:36 UTC
tags: [Software Design, Haskell]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		This article is an instalment in <a href="/2018/10/01/applicative-functors">an article series about applicative functors</a>. An applicative functor is a <a href="https://bartoszmilewski.com/2014/01/14/functors-are-containers">data container</a> that supports combinations. If an applicative functor contains values of a type that gives rise to a <a href="/2017/10/06/monoids">monoid</a>, then the <a href="/2018/03/22/functors">functor</a> itself forms a monoid.
	</p>
	<p>
		In a previous article you learned that <a href="/2019/04/15/lazy-monoids">lazy computations of monoids remain monoids</a>. Furthermore, <a href="/2018/12/17/the-lazy-applicative-functor">a lazy computation is an applicative functor</a>, and it turns out that the result generalises. The result regarding lazy computation is just a special case.
	</p>
	<h3 id="3c6acb0da15b4ae8b78f5d8879b7efe3">
		Monap <a href="#3c6acb0da15b4ae8b78f5d8879b7efe3" title="permalink">#</a>
	</h3>
	<p>
		Since version 4.11 of <a href="https://www.haskell.org">Haskell</a>'s <em>base</em> library, <code>Monoid</code> is a subset of <code>Semigroup</code>, so in order to create a <code>Monoid</code> instance, you must first define a <code>Semigroup</code> instance.
	</p>
	<p>
		In order to escape the need for flexible contexts, you'll have to define a wrapper <code>newtype</code> that'll be the instance. What should you call it? It's going to be an applicative functor of monoids, so perhaps something like <em>ApplicativeMonoid?</em> Nah, that's too long. <em>AppMon</em>, then? Sure, but how about flipping the terms: <em>MonApp?</em> That's better. Let's drop the last <em>p</em> and dispense with the <a href="https://en.wikipedia.org/wiki/Camel_case">Pascal case</a>: <em>Monap</em>.
	</p>
	<p>
		<em>Monap</em> almost looks like <em>Monad</em>, only with the last letter rotated half a revolution. This should allow for maximum confusion.
	</p>
	<p>
		To be clear, I normally don't advocate for droll word play when writing production code, but I occasionally do it in articles and presentations. The <em>Monap</em> in this article exists only to illustrate a point. It's not intended to be used. Furthermore, this article doesn't discuss monads at all, so the risk of confusion should, hopefully, be minimised. I may, however, regret this decision...
	</p>
	<h3 id="fb2568655a314bba8e417d06317b2690">
		Applicative semigroup <a href="#fb2568655a314bba8e417d06317b2690" title="permalink">#</a>
	</h3>
	<p>
		First, introduce the wrapper <code>newtype</code>:
	</p>
	<p>
		<pre><span style="color:blue;">newtype</span>&nbsp;Monap&nbsp;f&nbsp;a&nbsp;=&nbsp;Monap&nbsp;{&nbsp;runMonap&nbsp;::&nbsp;f&nbsp;a&nbsp;}&nbsp;<span style="color:blue;">deriving</span>&nbsp;(<span style="color:#2b91af;">Show</span>,&nbsp;<span style="color:#2b91af;">Eq</span>)</pre>
	</p>
	<p>
		This only states that there's a type called <code>Monap</code> that wraps some higher-kinded type <code>f a</code>; that is, a container <code>f</code> of values of the type <code>a</code>. The intent is that <code>f</code> is an applicative functor, hence the use of the letter <em>f</em>, but the type itself doesn't constrain <code>f</code> to any type class.
	</p>
	<p>
		The <code>Semigroup</code> instance does, though:
	</p>
	<p>
		<pre><span style="color:blue;">instance</span>&nbsp;(<span style="color:blue;">Applicative</span>&nbsp;f,&nbsp;<span style="color:blue;">Semigroup</span>&nbsp;a)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;<span style="color:blue;">Semigroup</span>&nbsp;(<span style="color:blue;">Monap</span>&nbsp;f&nbsp;a)&nbsp;<span style="color:blue;">where</span>
&nbsp;&nbsp;(Monap&nbsp;x)&nbsp;&lt;&gt;&nbsp;(Monap&nbsp;y)&nbsp;=&nbsp;Monap&nbsp;$&nbsp;liftA2&nbsp;<span style="color:#2b91af;">(&lt;&gt;)</span>&nbsp;x&nbsp;y
</pre>
	</p>
	<p>
		This states that when <code>f</code> is a <code>Applicative</code> instance, and <code>a</code> is a <code>Semigroup</code> instance, then <code>Monap f a</code> is also a <code>Semigroup</code> instance.
	</p>
	<p>
		Here's an example of combining two applicative <a href="/2017/11/27/semigroups">semigroups</a>:
	</p>
	<p>
		<pre>λ&gt; Monap (Just (Max 42)) &lt;&gt; Monap (Just (Max 1337))
Monap {runMonap = Just (Max {getMax = 1337})}</pre>
	</p>
	<p>
		This example uses the <code>Max</code> semigroup container, and <code>Maybe</code> as the applicative functor. For <code>Max</code>, the <code>&lt;&gt;</code> operator returns the value that contains the highest value, which in this case is 1337.
	</p>
	<p>
		It even works when the applicative functor in question is <code>IO</code>:
	</p>
	<p>
		<pre>λ&gt; runMonap $ Monap (Sum &lt;$&gt; randomIO @Word8) &lt;&gt; Monap (Sum &lt;$&gt; randomIO @Word8)
Sum {getSum = 165}</pre>
	</p>
	<p>
		This example uses <code>randomIO</code> to generate two random values. It uses the <code>TypeApplications</code> GHC extension to make <code>randomIO</code> generate <code>Word8</code> values. Each random number is projected into the <code>Sum</code> container, which means that <code>&lt;&gt;</code> will add the numbers together. In the above example, the result is 165, but if you evaluate the expression a second time, you'll most likely get another result:
	</p>
	<p>
		<pre>λ&gt; runMonap $ Monap (Sum &lt;$&gt; randomIO @Word8) &lt;&gt; Monap (Sum &lt;$&gt; randomIO @Word8)
Sum {getSum = 246}</pre>
	</p>
	<p>
		You can also use linked list (<code>[]</code>) as the applicative functor. In this case, the result may be surprising (depending on what you expect):
	</p>
	<p>
		<pre>λ&gt; Monap [Product 2, Product 3] &lt;&gt; Monap [Product 4, Product 5, Product 6]
Monap {runMonap = [Product {getProduct = 8},Product {getProduct = 10},Product {getProduct = 12},
                   Product {getProduct = 12},Product {getProduct = 15},Product {getProduct = 18}]}</pre>
	</p>
	<p>
		Notice that we get all the combinations of products: <em>2</em> multiplied with each element in the second list, followed by <em>3</em> multiplied by each of the elements in the second list. This shouldn't be that startling, though, since you've already, previously in this article series, seen several examples of how an applicative functor implies combinations.
	</p>
	<h3 id="33d4ff4f0fbf4e3cbf4d802b0f287f63">
		Applicative monoid <a href="#33d4ff4f0fbf4e3cbf4d802b0f287f63" title="permalink">#</a>
	</h3>
	<p>
		With the <code>Semigroup</code> instance in place, you can now add the <code>Monoid</code> instance:
	</p>
	<p>
		<pre><span style="color:blue;">instance</span>&nbsp;(<span style="color:blue;">Applicative</span>&nbsp;f,&nbsp;<span style="color:blue;">Monoid</span>&nbsp;a)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;<span style="color:blue;">Monoid</span>&nbsp;(<span style="color:blue;">Monap</span>&nbsp;f&nbsp;a)&nbsp;<span style="color:blue;">where</span>
&nbsp;&nbsp;mempty&nbsp;=&nbsp;Monap&nbsp;$&nbsp;pure&nbsp;$&nbsp;mempty
</pre>
	</p>
	<p>
		This is straightforward: you take the identity (<code>mempty</code>) of the monoid <code>a</code>, promote it to the applicative functor <code>f</code> with <code>pure</code>, and finally put that value into the <code>Monap</code> wrapper.
	</p>
	<p>
		This works fine as well:
	</p>
	<p>
		<pre>λ&gt; mempty :: Monap Maybe (Sum Integer)
Monap {runMonap = Just (Sum {getSum = 0})}

λ&gt; mempty :: Monap [] (Product Word8)
Monap {runMonap = [Product {getProduct = 1}]}</pre>
	</p>
	<p>
		The identity laws also seem to hold:
	</p>
	<p>
		<pre>λ&gt; Monap (Right mempty) &lt;&gt; Monap (Right (Sum 2112))
Monap {runMonap = Right (Sum {getSum = 2112})}

λ&gt; Monap ("foo", All False) &lt;&gt; Monap mempty
Monap {runMonap = ("foo",All {getAll = False})}</pre>
	</p>
	<p>
		The last, right-identity example is interesting, because the applicative functor in question is a tuple. Tuples are <code>Applicative</code> instances when the first, or left, element is a <code>Monoid</code> instance. In other words, <code>f</code> is, in this case, <code>(,) String</code>. The <code>Monoid</code> instance that <code>Monap</code> sees as <code>a</code>, on the other hand, is <code>All</code>.
	</p>
	<p>
		Since <a href="/2017/10/30/tuple-monoids">tuples of monoids are themselves monoids</a>, however, I can get away with writing <code>Monap mempty</code> on the right-hand side, instead of the more elaborate template the other examples use:
	</p>
	<p>
		<pre>λ&gt; Monap ("foo", All False) &lt;&gt; Monap ("", mempty)
Monap {runMonap = ("foo",All {getAll = False})}</pre>
	</p>
	<p>
		or perhaps even:
	</p>
	<p>
		<pre>λ&gt; Monap ("foo", All False) &lt;&gt; Monap (mempty, mempty)
Monap {runMonap = ("foo",All {getAll = False})}</pre>
	</p>
	<p>
		Ultimately, all three alternatives mean the same.
	</p>
	<h3 id="6b484b60d19b4ef4a3716ceaa693cb8b">
		Associativity <a href="#6b484b60d19b4ef4a3716ceaa693cb8b" title="permalink">#</a>
	</h3>
	<p>
		As usual, I'm not going to do the work of formally proving that the monoid laws hold for the <code>Monap</code> instances, but I'd like to share some QuickCheck properties that indicate that they do, starting with a property that verifies associativity:
	</p>
	<p>
		<pre><span style="color:#2b91af;">assocLaw</span>&nbsp;::&nbsp;(<span style="color:blue;">Eq</span>&nbsp;a,&nbsp;<span style="color:blue;">Show</span>&nbsp;a,&nbsp;<span style="color:blue;">Semigroup</span>&nbsp;a)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Property</span>
assocLaw&nbsp;x&nbsp;y&nbsp;z&nbsp;=&nbsp;(x&nbsp;&lt;&gt;&nbsp;y)&nbsp;&lt;&gt;&nbsp;z&nbsp;===&nbsp;x&nbsp;&lt;&gt;&nbsp;(y&nbsp;&lt;&gt;&nbsp;z)</pre>
	</p>
	<p>
		This property is entirely generic. It'll verify associativity for any <code>Semigroup a</code>, not only for <code>Monap</code>. You can, however, run it for various <code>Monap</code> types, as well. You'll see how this is done a little later.
	</p>
	<h3 id="51973eba155f418e8903d37f6d3938d2">
		Identity <a href="#51973eba155f418e8903d37f6d3938d2" title="permalink">#</a>
	</h3>
	<p>
		Likewise, you can write two properties that check left and right identity, respectively.
	</p>
	<p>
		<pre><span style="color:#2b91af;">leftIdLaw</span>&nbsp;::&nbsp;(<span style="color:blue;">Eq</span>&nbsp;a,&nbsp;<span style="color:blue;">Show</span>&nbsp;a,&nbsp;<span style="color:blue;">Monoid</span>&nbsp;a)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Property</span>
leftIdLaw&nbsp;x&nbsp;=&nbsp;x&nbsp;===&nbsp;mempty&nbsp;&lt;&gt;&nbsp;x

<span style="color:#2b91af;">rightIdLaw</span>&nbsp;::&nbsp;(<span style="color:blue;">Eq</span>&nbsp;a,&nbsp;<span style="color:blue;">Show</span>&nbsp;a,&nbsp;<span style="color:blue;">Monoid</span>&nbsp;a)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Property</span>
rightIdLaw&nbsp;x&nbsp;=&nbsp;x&nbsp;===&nbsp;x&nbsp;&lt;&gt;&nbsp;mempty
</pre>
	</p>
	<p>
		Again, this is entirely generic. These properties can be used to test the identity laws for any monoid, including <code>Monap</code>.
	</p>
	<h3 id="0cc5968e519c48a0816574e1dc1667fc">
		Properties <a href="#0cc5968e519c48a0816574e1dc1667fc" title="permalink">#</a>
	</h3>
	<p>
		You can run each of these properties multiple time, for various different functors and monoids. As <code>Applicative</code> instances, I've used <code>Maybe</code>, <code>[]</code>, <code>(,) Any</code>, and <code>Identity</code>. As <code>Monoid</code> instances, I've used <code>String</code>, <code>Sum Integer</code>, <code>Max Int16</code>, and <code>[Float]</code>. Notice that a list (<code>[]</code>) is both an applicative functor as well as a monoid. In this test set, I've used it in both roles.
	</p>
	<p>
		<pre>tests&nbsp;=
&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;testGroup&nbsp;<span style="color:#a31515;">&quot;Properties&quot;</span>&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Associativity&nbsp;law,&nbsp;Maybe&nbsp;String&quot;</span>&nbsp;(assocLaw&nbsp;@(Monap&nbsp;Maybe&nbsp;String)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Left&nbsp;identity&nbsp;law,&nbsp;Maybe&nbsp;String&quot;</span>&nbsp;(leftIdLaw&nbsp;@(Monap&nbsp;Maybe&nbsp;String)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Right&nbsp;identity&nbsp;law,&nbsp;Maybe&nbsp;String&quot;</span>&nbsp;(rightIdLaw&nbsp;@(Monap&nbsp;Maybe&nbsp;String)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Associativity&nbsp;law,&nbsp;[Sum&nbsp;Integer]&quot;</span>&nbsp;(assocLaw&nbsp;@(Monap&nbsp;<span style="color:blue;">[]</span>&nbsp;(Sum&nbsp;Integer))),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Left&nbsp;identity&nbsp;law,&nbsp;[Sum&nbsp;Integer]&quot;</span>&nbsp;(leftIdLaw&nbsp;@(Monap&nbsp;<span style="color:blue;">[]</span>&nbsp;(Sum&nbsp;Integer))),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Right&nbsp;identity&nbsp;law,&nbsp;[Sum&nbsp;Integer]&quot;</span>&nbsp;(rightIdLaw&nbsp;@(Monap&nbsp;<span style="color:blue;">[]</span>&nbsp;(Sum&nbsp;Integer))),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Associativity&nbsp;law,&nbsp;(Any,&nbsp;Max&nbsp;Int8)&quot;</span>&nbsp;(assocLaw&nbsp;@(Monap&nbsp;(<span style="color:#2b91af;">(,)</span>&nbsp;Any)&nbsp;(Max&nbsp;Int8))),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Left&nbsp;identity&nbsp;law,&nbsp;(Any,&nbsp;Max&nbsp;Int8)&quot;</span>&nbsp;(leftIdLaw&nbsp;@(Monap&nbsp;(<span style="color:#2b91af;">(,)</span>&nbsp;Any)&nbsp;(Max&nbsp;Int8))),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Right&nbsp;identity&nbsp;law,&nbsp;(Any,&nbsp;Max&nbsp;Int8)&quot;</span>&nbsp;(rightIdLaw&nbsp;@(Monap&nbsp;(<span style="color:#2b91af;">(,)</span>&nbsp;Any)&nbsp;(Max&nbsp;Int8))),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Associativity&nbsp;law,&nbsp;Identity&nbsp;[Float]&quot;</span>&nbsp;(assocLaw&nbsp;@(Monap&nbsp;Identity&nbsp;[Float])),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Left&nbsp;identity&nbsp;law,&nbsp;Identity&nbsp;[Float]&quot;</span>&nbsp;(leftIdLaw&nbsp;@(Monap&nbsp;Identity&nbsp;[Float])),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testProperty&nbsp;<span style="color:#a31515;">&quot;Right&nbsp;identity&nbsp;law,&nbsp;Identity&nbsp;[Float]&quot;</span>&nbsp;(rightIdLaw&nbsp;@(Monap&nbsp;Identity&nbsp;[Float]))
&nbsp;&nbsp;&nbsp;&nbsp;]
&nbsp;&nbsp;]
</pre>
	</p>
	<p>
		All of these properties pass.
	</p>
	<h3 id="af35f2986a734a16be80590c86d0432d">
		Summary <a href="#af35f2986a734a16be80590c86d0432d" title="permalink">#</a>
	</h3>
	<p>
		It seems that any applicative functor that contains monoidal values itself forms a monoid. The <code>Monap</code> type presented in this article only exists to demonstrate this conjecture; it's not intended to be <em>used</em>.
	</p>
	<p>
		If it holds, I think it's an interesting result, because it further enables you to reason about the properties of complex systems, based on the properties of simpler systems.
	</p>
	<p>
		<strong>Next: </strong> <a href="/2018/12/24/bifunctors">Bifunctors</a>.
	</p>
</div>

<div id="comments">
  <hr>
  <h2 id="comments-header">
    Comments
  </h2>
  <div class="comment" id="9a3acf3cf4174e178dc9349e11fee488">
    <div class="comment-author">Tyson Williams</div>
    <div class="comment-content">
      <blockquote>
	      It seems that any applicative functor that contains monoidal values itself forms a monoid.
	  </blockquote
	  <p>
	  </p>
	      Is it necessary for the functor to be applicative?  Do know of a functor that contains monoidal values for which itself does <em>not</em> form a monoid?
    </div>
    <div class="comment-date">2019-05-13 11:28 UTC</div>
  </div>
</div>
