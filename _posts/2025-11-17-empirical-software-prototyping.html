---
layout: post
title: "Empirical software prototyping"
description: "How do you add tests to a proof-of-concept? Should you?"
date: 2025-11-17 8:38 UTC
tags: [Unit Testing]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        This is the second article in a small series on <a href="/2025/10/27/empirical-test-after-development">empirical test-after development</a>. I'll try to answer an occasionally-asked question: Should one use test-driven development (TDD) for prototyping?
    </p>
    <p>
        There are variations on this question, but it tends to come up when discussing TDD. Some <a href="https://x.com/hillelogram/status/1445435617047990273">software thought leaders</a> proclaim that you should always take advantage of TDD when writing code. The short response is that there are exceptions to that rule. Those thought leaders know that, too, but they choose to communicate the way that they do in order to make a point. I don't blame them, and I use a similar style of communication from time to time. If you hedge every sentence you utter with qualifications, the message often disappears in unclear language. Thus, when someone admonishes that you should always follow TDD, what they really mean (I suppose; I'm not a telepath) is that you should predominantly use TDD. More than 80% of the time.
    </p>
    <p>
        This is a common teaching tool. A competent teacher takes into account the skill level of a student. A new learner has to start with the basics before advanced topics. Early in the learning process, there's no room for sophistication. Even when a teacher understands that there are exceptions, he or she starts with a general rule, like 'you should always do TDD'.
    </p>
    <p>
        While this may seem like a digression, this detour answers most of the questions related to software prototyping. People find it difficult to apply TDD when developing a prototype. I do, too. So don't.
    </p>
    <h3 id="873f1d7273e94b7eb9028fde1d75d890">
        Prototyping or proof-of-concept? <a href="#873f1d7273e94b7eb9028fde1d75d890">#</a>
    </h3>
    <p>
        I've already committed the sin of using <em>prototype</em> and <em>proof-of-concept</em> interchangeably. This only reflects how I use these terms in conversation. While I'm aware that the internet offers articles to help me distinguish, I find the differences too subtle to be of use when communicating with other people. Even if I learn the fine details that separate one from the other, I can't be sure that the person I'm talking to shares that understanding.
    </p>
    <p>
        Since <em>prototype</em> is easier to say, I tend to use that term more than <em>proof-of-concept</em>. In any case, a prototype in this context is an exploration of an idea. You surmise that it's possible to do something in a certain way, but you're not sure. Before committing to the uncertain idea, you develop an isolated code base to vet the concept.
    </p>
    <p>
        This could be an idea for an algorithm, use of a new technology such as a framework or reusable library, a different cloud platform, or even a new programming language.
    </p>
    <p>
        Such exploration is already challenging in itself. How is the API of the library structured? Should you call <code>IsFooble</code> or <code>HasFooble</code> here? How do you write a <code>for</code> loop in <a href="https://en.wikipedia.org/wiki/APL_(programming_language)">APL</a>? How does one even compile a <a href="https://www.java.com">Java</a> program? How do you programmatically provision new resources in <a href="https://learn.microsoft.com/en-us/fabric/fundamentals/microsoft-fabric-overview">Microsoft Fabric</a>? How do you convert a <a href="https://en.wikipedia.org/wiki/JPEG">JPG</a> file to <a href="https://en.wikipedia.org/wiki/PDF">PDF</a> on the server?
    </p>
    <p>
        There are plenty of questions like these where you don't even know the shape of things. The point of the exercise is often to figure those things out. When you don't know how APIs are organized, or which technologies are available to you, writing tests first is difficult. No wonder people sometimes ask me about this.
    </p>
    <h3 id="33bc345c3bb34ca795532ab0b13e4f19">
        Code to throw away <a href="#33bc345c3bb34ca795532ab0b13e4f19">#</a>
    </h3>
    <p>
        The very nature of a prototype is that it's an experiment designed to explore an idea. The safest way to engage with a prototype is to create an isolated code base for that particular purpose. A prototype is not an <a href="https://en.wikipedia.org/wiki/Minimum_viable_product">MVP</a> or an early version of the product. It is a deliberately unstructured exploration of what's possible. The entire purpose of a prototype is to <em>learn</em>. Often the exploration process is time-boxed.
    </p>
    <p>
        If the prototype turns out to be successful, you may proceed to implement the idea in your production code base. Even if you didn't use TDD for the prototype, you should now have learned enough that you can apply TDD for the production implementation.
    </p>
    <p>
        The most common obstacle to this chain of events, I understand, is that 'bosses' demand that a successful prototype be put into production. Try to resist such demands. It often helps planning for this from the outset. If you can, do the prototype in a way that effectively prevents such predictable demands. If you're exploring the viability of a new algorithm, write it in an alternative programming language. For example, I've written prototypes in <a href="https://www.haskell.org/">Haskell</a>, which very effectively prevents demands that the code be put into production.
    </p>
    <p>
        If your organization is a little behind the cutting edge, you can also write the prototype in a newer version of your language or run-time. Use functional programming if you normally use object-oriented design. Or you may pick an auxiliary technology incompatible with how you normally do things: Use the 'wrong' JSON serializer library, an in-memory database, write a command-line program if you need a GUI, or vice versa.
    </p>
    <p>
        You're the technical expert. <a href="/2019/03/18/the-programmer-as-decision-maker">Make technical decisions</a>. Surely, you can come up with something that sounds convincing enough to a non-technical stakeholder to prevent putting the prototype into production.
    </p>
    <p>
        To be sure we're on firm moral ground here: I'm not advocating that you should be dishonest, or work against the interests of your organization. Rather, I suggest that you act politically. Understand what motivates other people. Non-technical stakeholders usually don't have the insight to understand why a successful prototype shouldn't be promoted to production code. Unfortunately, they often view programmers as typists, and with that view, it seems wasteful to repeat the work of typing in the prototype code. <a href="/2018/09/17/typing-is-not-a-programming-bottleneck">Typing, however, is not a bottleneck</a>, but it can be hard to convince other people of this.
    </p>
    <p>
        If all else fails, and you're forced to promote the prototype to production code, you now have a piece of legacy code on hand, in which case the techniques outlined in <a href="/2025/11/03/empirical-characterization-testing">the previous article</a> should prove useful.
    </p>
    <h3 id="92448892cad9447dab00ef4e1e82bcff">
        Prototyping in existing code bases <a href="#92448892cad9447dab00ef4e1e82bcff">#</a>
    </h3>
    <p>
        A special case occurs when you need to do a prototype in an existing code base. You already have a big, complicated system, and you would like to explore whether a particular idea is applicable in that context. Perhaps data access is currently too slow, and you have an idea of how to speed things up, for example by <a href="/2022/02/14/a-conditional-sandwich-example">speculative prefetching</a>. When the problem is one of performance, you'll need to <a href="https://ericlippert.com/2012/12/17/performance-rant/">measure</a> in a realistic environment. This may prevent you from creating an isolated prototype code base.
    </p>
    <p>
        In such cases, use Git to your advantage. Make a new prototype branch and work there. You may deliberately choose to make it a long-lived <a href="https://martinfowler.com/bliki/FeatureBranch.html">feature branch</a>. Once the prototype is done, the code may now be so out of sync with <em>master</em> that 'merge conflicts' sounds like a plausible excuse to a non-technical stakeholder. As above, be political.
    </p>
    <p>
        In any case, don't merge the prototype branch, even if you could. Instead, use the knowledge gained during the prototype work to re-implement the new idea, this time using empirical software engineering techniques like TDD.
    </p>
    <h3 id="1533c57419f64e149a4aec070eb8f714">
        Conclusion <a href="#1533c57419f64e149a4aec070eb8f714">#</a>
    </h3>
    <p>
        Prototyping is usually antithetical to TDD. On the other hand, TDD is an effective empirical method for software development. Without it, you have to seek other answers to the question: How do we know that this works?
    </p>
    <p>
        Due to the explorative nature of prototyping, testing of the prototype tends to be explorative as well. Start up the prototype, poke at it, see if it behaves as expected. While you do gain a limited amount of empirical knowledge from such a process, it's unsystematic and non-repeatable, so little <em>corroboration</em> of hypothesis takes place. Therefore, once the prototype work is done, it's important to proceed on firmer footing if the prototype was successful.
    </p>
    <p>
        The safest way is to put the prototype to the side, but use the knowledge to test-drive the production version of the idea. This may require a bit of political manoeuvring. If that fails, and you're forced to promote the prototype to production use, you may use the techniques for adding <a href="/2025/11/03/empirical-characterization-testing">empirical Characterization Tests</a>.
    </p>
</div>