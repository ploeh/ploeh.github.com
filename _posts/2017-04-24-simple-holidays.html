---
layout: post
title: "Simple holidays"
date: 2017-04-24 13:42 UTC
tags: [Software Design, Architecture]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>A story about arriving at the simplest solution that could possibly work.</em>
	</p>
	<p>
		The Zen of Python states: <a href="https://www.python.org/dev/peps/pep-0020">Simple is better than complex</a>. If I've met a programmer who disagrees with that, I'm not aware of it. It's hardly a controversial assertion, but what does 'simplicity' mean? Can you even identify a simple solution?
	</p>
	<p>
		I often see software developers defaulting to complex solutions, because a simpler solution isn't immediately obvious. In retrospect, a simple solution often <em>is</em> obvious, but only once you've found it. Until then, it's elusive.
	</p>
	<p>
		I'd like to share a story in which I arrived at a simple solution after several false starts. I hope it can be an inspiration.
	</p>
	<p>
		<strong>Dutch holidays</strong>
	</p>
	<p>
		Recently, I had to write some code that takes into account Dutch holidays. (In order to address any confusion that could arise from this: No, I'm not Dutch, I'm Danish, but currently, I'm doing some work on a system targeting a market in the Netherlands.) Specifically, given a date, I had to find the latest possible Dutch bank day on or before that date.
	</p>
	<p>
		For normal week days (Monday to Friday), it's easy, because such a date is already a bank date. In other words, in that case, you can simply return the input date. Also, in normal weeks, given a Saturday or Sunday, you should return the preceding Friday. The problem is, however, that some Fridays are holidays, and therefore not bank days.
	</p>
	<p>
		Like many other countries, the Netherlands have complicated rules for determining official holidays. Here are some tricky parts:
		<ul>
			<li>
				Some holidays always fall on the same date. One example is <em>Bevrijdingsdag (Liberation Day)</em>, which always falls on May 5. This holiday celebrates a historic event (the end of World War II in Europe), so if you wanted to calculate bank holidays in the past, you'd have to figure out in which year this became a public holiday. Surely, at least, it must have been 1945 or later.</li>
			<li>
				Some holidays fall on specific week days. The most prominent example is Easter, where <em>Goede Vrijdag (Good Friday)</em> always (as the name implies) falls on a Friday. Which Friday exactly can be calculated using a complicated algorithm.
			</li>
			<li>
				One holiday (<em>Koningsdag (King's Day)</em>) celebrates the king's birthday. The date is determined by the currently reigning monarch's birthday, and it's called <em>Queen's Day</em> when the reigning monarch is a queen. Obviously, the exact date changes depending on who's king or queen, and you can't predict when it's going to change. And what will happen if the current monarch abdicates or dies <em>before</em> his or her birthday, but <em>after</em> the new monarch's birthday? Does that mean that there will be no such holiday that year? Or what about the converse? Could there be <em>two</em> such holidays if a monarch abdicates <em>after</em> his or her birthday, and the new monarch's birthday falls later the same year?
			</li>
		</ul>
		Such problems aren't particular to the Netherlands. In Denmark, we can find similar examples, as I think you can do in many other countries. Ultimately, what constitutes an official holiday is a political decision.
	</p>
	<p>
		Figuring out if a date is a bank day, then, is what you might call an 'interesting' problem. How would you solve it? Before you read on, take a moment to consider how you'd attempt to solve the problem. If you will, you can consider the test cases immediately below to get a better sense of the problem.
	</p>
	<p>
		<strong>Test cases</strong>
	</p>
	<p>
		Here's a small set of test cases that I wrote in order to describe the problem:
		<table>
			<thead>
				<tr>
					<th>Test case</th>
					<th>Input date</th>
					<th>Expected output</th>
				</tr>
			</thead>
			<tbody>
				<tr><td>Monday</td><td>2017-03-06</td><td>2017-03-06</td></tr>
				<tr><td>Tuesday</td><td>2017-03-07</td><td>2017-03-07</td></tr>
				<tr><td>Wednesday</td><td>2017-03-08</td><td>2017-03-08</td></tr>
				<tr><td>Thursday</td><td>2017-03-09</td><td>2017-03-09</td></tr>
				<tr><td>Friday</td><td>2017-03-10</td><td>2017-03-10</td></tr>
				<tr><td>Saturday</td><td>2017-03-11</td><td>2017-03-10</td></tr>
				<tr><td>Sunday</td><td>2017-03-12</td><td>2017-03-10</td></tr>
				<tr><td>Good Friday</td><td>2017-04-14</td><td>2017-04-13</td></tr>
				<tr><td>Saturday after Good Friday</td><td>2017-04-15</td><td>2017-04-13</td></tr>
				<tr><td>Sunday after Good Friday</td><td>2017-04-16</td><td>2017-04-13</td></tr>
				<tr><td>Easter Monday</td><td>2017-04-17</td><td>2017-04-13</td></tr>
				<tr><td>Ascension Day - Thursday</td><td>2017-05-25</td><td>2017-05-24</td></tr>
				<tr><td>Whit Monday</td><td>2110-05-26</td><td>2110-05-23</td></tr>
				<tr><td>Liberation Day</td><td>9713-05-05</td><td>9713-05-04</td></tr>
			</tbody>
		</table>
		You'll notice that while I wrote most of my test cases in the near future (they're actually already in the past, now), I also added some far future dates for good measure. This assumes that the Netherlands will still celebrate Christian religious holidays in a hundred years from now, or their liberation day in 9713. That the Netherlands still exist then as the country we know today is a more than dubious assumption.
	</p>
	<p>
		<strong>Option: query a third-party service</strong>
	</p>
	<p>
		How would you solve the problem? The first solution that occurred to me was to use a third-party service. My guess is that most developers would consider this option. After all, it's essentially third-part data. The official holidays are determined by a third party, in this case the Dutch state. Surely, some Dutch official organisation would publish the list of official holidays somewhere. Perhaps, if you're lucky, there's even an on-line service you can query in order to download the list of holidays in some machine-readable format.
	</p>
	<p>
		There are, however, problems with this alternative: if you query such a service each time you need to find an appropriate bank date, how are you going to handle network errors? What if the third-part service is (temporarily) unavailable?
	</p>
	<p>
		Since I'm trying to figure out bank dates, you may already have guessed that I'm handling money, so it's not desirable to simple throw an exception and say that a caller would have to try again later. This could lead to loss of revenue.
	</p>
	<p>
		Querying a third-party service <em>every time</em> you need to figure out a Dutch bank holiday is out of the question for that reason. It's also likely to be inefficient.
	</p>
	<p>
		<strong>Option: cache third-party data</strong>
	</p>
	<p>
		Public holidays rarely change, so your next attempt could be a variation of the previous. Use third-party data, but instead of querying a third-party service every time you need the information, cache it.
	</p>
	<p>
		The problem with caching is that you're not guaranteed that the data you seek is in the cache. At application start, caches are usually empty. You'd have to rely on making one good query to the third-party data source in order to put the data in the cache. Only if that succeeds can you use the cache. This, again, leaves you vulnerable to the normal failure modes of distributed computing. If you can't reach the third-party data source, you have nothing to put in the cache.
	</p>
	<p>
		This can be a problem at application start, or when the cache data expires.
	</p>
	<p>
		Using a cache <em>reduces</em> the risk that the data is unavailable, but it doesn't eliminate it. It also adds complexity in the form of a cache that has to be configured and managed. Granted, you can use a reusable cache library or service to minimise that cost, so it may not be a big deal. Still, when making a decision about application architecture, I think it helps to explicitly identify advantages and disadvantages.
	</p>
	<p>
		Using a cache felt better to me, but I still wasn't happy. Too many things could go wrong.
	</p>
	<p>
		<strong>Option: persistent cache</strong>
	</p>
	<p>
		An incremental improvement on the previous option would be to write the cache data to persistent storage. This takes care of the issue with the cache being empty at application start-up. You can even deal with cache expiry by keep using stale data if you can't reach the 'official' source of the data.
	</p>
	<p>
		It leaves me a bit concerned, though, because if you allow the system to continue working with stale data, perhaps the application could enter a state where the data <em>never</em> updates. This could happen if the official data source moves, or changes format. In such a case, your application would keep trying to refresh the cache, and it would permanently fail. It would permanently run with stale data. Would you ever discover that problem?
	</p>
	<p>
		My concern is that the application could silently fail. You could counter that by logging a warning somewhere, but that would introduce a permanent burden on the team responsible for operating the application. This isn't impossible, but it does constitute an extra complexity. This alternative still didn't feel good to me.
	</p>
	<p>
		<strong>Option: cron</strong>
	</p>
	<p>
		Because I wasn't happy with any of the above alternatives, I started looking for different approaches to the problem. For a short while, I considered using a .NET implementation of <a href="https://en.wikipedia.org/wiki/Cron">cron</a>, with a crontab file. As far as I can tell, though there's no easy way to define Easter using cron, so I quickly abandoned that line of inquiry.
	</p>
	<p>
		<strong>Option: Nager.Date</strong>
	</p>
	<p>
		I wasn't entirely done with idea of calculating holidays on the fly. While calculating Easter is complicated, it can be done; there <em>is</em> a well-defined algorithm for it. Whenever I run into a general problem like this, I assume that someone has already done the required work, and this is also the case here. I quickly found an open source library called <a href="https://github.com/tinohager/Nager.Date">Nager.Date</a>; I'm sure that there are other alternatives, but Nager.Date looks like it's more than good enough.
	</p>
	<p>
		Such a library would be able to calculate all holidays for a given year, based on the algorithms embedded in it. That looked really promising.
	</p>
	<p>
		And yet... again, I was concerned. Official holidays are, as we've already established, politically decided. Using an algorithmic approach is <em>fundamentally</em> wrong, because that's not really how the holidays are determined. Holidays are defined by decree; it just so happens that some of the decrees take the form of an algorithm (such as Easter).
	</p>
	<p>
		What would happen if the Dutch state decides to add a new holiday? Or to take one away? Of when a new monarch is crowned? In order to handle such changes, we'd now have to hope that Nager.Date would be updated. We could try to make that more likely to happen by sending a pull request, but we'd still be vulnerable to a third party. What if the maintainer of Nager.Date is on vacation?
	</p>
	<p>
		Even if you can get a change into a library like Nager.Date, how is the algorithmic approach going to deal with historic dates? If the monarch changes, you can update the library, but does it correctly handle dates in the past, where the King's Day was different?
	</p>
	<p>
		Using an algorithm to determine a holiday seemed promising, but ultimately, I decided that I didn't like this option either.
	</p>
	<p>
		<strong>Option: configuration file</strong>
	</p>
	<p>
		My main concern about using an algorithm is that it'd make it difficult to handle arbitrary changes and exceptional cases. If we'd use a configuration file, on the other hand, we could always edit the configuration file in order to add or remove holidays for a given year.
	</p>
	<p>
		In essence, I was envisioning a configuration file that simply contained a list of holidays for each year.
	</p>
	<p>
		That sounds fairly simple and maintainable, but from where should the data come?
	</p>
	<p>
		You could probably download a list of official holidays for the next few years, like 2017, 2018, 2019, and so on, but the list would be finite, and probably not cover more than a few years into the future.
	</p>
	<p>
		What if, for example, I'd only be able to find an official list that goes to 2020? What will happen, then, when our application enters 2021? To the rest of the code base, it'd look like there were no holidays in 2021.
	</p>
	<p>
		At this time we can expect that new official lists have been published, so a programmer could obtain such a list and update the configuration file when it's time. This, unfortunately, is easy to forget. Four years in the future, perhaps none of the original programmers are left. It's more than likely that no one will remember to do this.
	</p>
	<p>
		<strong>Option: algorithm-generated configuration file</strong>
	</p>
	<p>
		The problem that the configuration data could 'run out' can be addressed by initialising the configuration file with data generated algorithmically. You could, for example, ask Nager.Date to generate all the holidays for the next many years. In fact, the year 9999 is the maximum year handled by .NET's <code>System.DateTime</code>, so you could ask it to generate all the holidays until 9999.
	</p>
	<p>
		That sounds like a lot, but it's only about half a megabyte of data...
	</p>
	<p>
		This solves the problem of 'running out' of holiday data, but still enables you to edit the holiday data when it changes in the future. For example, if the King's Day changes in 2031, you can change all the King's Day values from 2031 onward, while retaining the correct values for the previous years.
	</p>
	<p>
		This seems promising...
	</p>
	<p>
		<strong>Option: hard-coded holidays</strong>
	</p>
	<p>
		I almost decided to use the previous, configuration-based solution, and I was getting ready to invent a configuration file format, and a reader for it, and so on. Then I recalled <a href="http://mikehadlow.blogspot.com">Mike Hadlow</a>'s article about the <a href="http://mikehadlow.blogspot.com/2012/05/configuration-complexity-clock.html">configuration complexity clock</a>.
	</p>
	<p>
		I'm fairly certain that the only people who would be editing a hypothetical holiday configuration file would be programmers. In that case, why put the configuration in a proprietary format? Why deal with the hassle of reading and parsing such a file? Why not put the data in code?
	</p>
	<p>
		That's what I decided to do.
	</p>
	<p>
		It's not a perfect solution. It's still necessary to go and change that code file when the holiday rules change. For example, when the King's Day changes, you'd have to edit the file.
	</p>
	<p>
		Still, it's the <em>simplest</em> solution I could come up with. It has no moving parts, and uses a 'best effort' approach in order to guarantee that holidays will always be present. If you can come up with a better alternative, please leave a comment.
	</p>
	<p>
		<strong>Data generation</strong>
	</p>
	<p>
		Nager.Date seemed useful for generating the initial set of holidays, so I wrote a small F# script that generated the necessary C# code snippets:
	</p>
	<p>
		<pre><span style="color:blue;">#r</span>&nbsp;<span style="color:#a31515;">@&quot;packages/Nager.Date.1.3.0/lib/net45/Nager.Date.dll&quot;</span>
 
<span style="color:blue;">open</span>&nbsp;System.IO
<span style="color:blue;">open</span>&nbsp;Nager.Date
 
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">formatHoliday</span>&nbsp;(h&nbsp;:&nbsp;Model.<span style="color:teal;">PublicHoliday</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;y,&nbsp;m,&nbsp;d&nbsp;=&nbsp;h.Date.Year,&nbsp;h.Date.Month,&nbsp;h.Date.Day
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">sprintf</span>&nbsp;<span style="color:#a31515;">&quot;new&nbsp;DateTime(</span><span style="color:teal;">%i</span><span style="color:#a31515;">,&nbsp;</span><span style="color:teal;">%2i</span><span style="color:#a31515;">,&nbsp;</span><span style="color:teal;">%2i</span><span style="color:#a31515;">),&nbsp;//&nbsp;</span><span style="color:teal;">%s</span><span style="color:#a31515;">/</span><span style="color:teal;">%s</span><span style="color:#a31515;">&quot;</span>&nbsp;y&nbsp;m&nbsp;d&nbsp;h.Name&nbsp;h.LocalName
 
<span style="color:blue;">let</span>&nbsp;holidays&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;[2017..9999]
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:teal;">Seq</span>.<span style="color:navy;">collect</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;y&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:teal;">DateSystem</span>.<span style="color:navy;">GetPublicHoliday</span>&nbsp;(<span style="color:teal;">CountryCode</span>.NL,&nbsp;y))
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:teal;">Seq</span>.<span style="color:navy;">map</span>&nbsp;<span style="color:navy;">formatHoliday</span>
 
<span style="color:teal;">File</span>.<span style="color:navy;">WriteAllLines</span>&nbsp;(<span style="color:blue;">__SOURCE_DIRECTORY__</span>&nbsp;+&nbsp;<span style="color:#a31515;">&quot;/dutch-holidays.txt&quot;</span>,&nbsp;holidays)</pre>
	</p>
	<p>
		This script simply asks Nager.Date to calculate all Dutch holidays for the years 2017 to 9999, format them as C# code snippets, and write the lines to a text file. The size of that file is 4 MB, because the auto-generated code comments also take up some space.
	</p>
	<p>
		<strong>First implementation attempt</strong>
	</p>
	<p>
		The next thing I did was to copy the text from <code>dutch-holidays.txt</code> to a C# code file, which I had already prepared with a class and a few methods that would query my generated data. The result looked like this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">DateTimeExtensions</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">DateTimeOffset</span>&nbsp;AdjustToLatestPrecedingDutchBankDay(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">DateTimeOffset</span>&nbsp;value)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;candidate&nbsp;=&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">while</span>&nbsp;(!(IsDutchBankDay(candidate.DateTime)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidate&nbsp;=&nbsp;candidate.AddDays(-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;candidate;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;IsDutchBankDay(<span style="color:#2b91af;">DateTime</span>&nbsp;date)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(date.DayOfWeek&nbsp;==&nbsp;<span style="color:#2b91af;">DayOfWeek</span>.Saturday)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(date.DayOfWeek&nbsp;==&nbsp;<span style="color:#2b91af;">DayOfWeek</span>.Sunday)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(dutchHolidays.Contains(date.Date))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">#region</span>&nbsp;Dutch&nbsp;holidays
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">DateTime</span>[]&nbsp;dutchHolidays&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;&nbsp;1,&nbsp;&nbsp;1),&nbsp;<span style="color:green;">//&nbsp;New&nbsp;Year&#39;s&nbsp;Day/Nieuwjaarsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;&nbsp;4,&nbsp;14),&nbsp;<span style="color:green;">//&nbsp;Good&nbsp;Friday/Goede&nbsp;Vrijdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;&nbsp;4,&nbsp;17),&nbsp;<span style="color:green;">//&nbsp;Easter&nbsp;Monday/&nbsp;Pasen</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;&nbsp;4,&nbsp;27),&nbsp;<span style="color:green;">//&nbsp;King&#39;s&nbsp;Day/Koningsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;&nbsp;5,&nbsp;&nbsp;5),&nbsp;<span style="color:green;">//&nbsp;Liberation&nbsp;Day/Bevrijdingsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;&nbsp;5,&nbsp;25),&nbsp;<span style="color:green;">//&nbsp;Ascension&nbsp;Day/Hemelvaartsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;&nbsp;6,&nbsp;&nbsp;5),&nbsp;<span style="color:green;">//&nbsp;Whit&nbsp;Monday/Pinksteren</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;12,&nbsp;25),&nbsp;<span style="color:green;">//&nbsp;Christmas&nbsp;Day/Eerste&nbsp;kerstdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2017,&nbsp;12,&nbsp;26),&nbsp;<span style="color:green;">//&nbsp;St.&nbsp;Stephen&#39;s&nbsp;Day/Tweede&nbsp;kerstdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;&nbsp;1,&nbsp;&nbsp;1),&nbsp;<span style="color:green;">//&nbsp;New&nbsp;Year&#39;s&nbsp;Day/Nieuwjaarsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;&nbsp;3,&nbsp;30),&nbsp;<span style="color:green;">//&nbsp;Good&nbsp;Friday/Goede&nbsp;Vrijdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Lots&nbsp;and&nbsp;lots&nbsp;of&nbsp;dates...</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(9999,&nbsp;&nbsp;5,&nbsp;&nbsp;6),&nbsp;<span style="color:green;">//&nbsp;Ascension&nbsp;Day/Hemelvaartsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(9999,&nbsp;&nbsp;5,&nbsp;17),&nbsp;<span style="color:green;">//&nbsp;Whit&nbsp;Monday/Pinksteren</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(9999,&nbsp;12,&nbsp;25),&nbsp;<span style="color:green;">//&nbsp;Christmas&nbsp;Day/Eerste&nbsp;kerstdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(9999,&nbsp;12,&nbsp;26),&nbsp;<span style="color:green;">//&nbsp;St.&nbsp;Stephen&#39;s&nbsp;Day/Tweede&nbsp;kerstdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">#endregion</span>
}</pre>
	</p>
	<p>
		My old computer isn't happy about having to compile 71,918 lines of C# in a single file, but it's doable, and as far as I can tell, Visual Studio caches the result of compilation, so as long as I don't change the file, there's little adverse effect.
	</p>
	<p>
		<strong>Unit tests</strong>
	</p>
	<p>
		In order to verify that the implementation works, I wrote this parametrised test:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">DateTimeExtensionsTests</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">Theory</span>]
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-03-06&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-03-06&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Monday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-03-07&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-03-07&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Tuesday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-03-08&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-03-08&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Wednesday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-03-09&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-03-09&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Thursday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-03-10&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-03-10&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Friday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-03-11&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-03-10&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Saturday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-03-12&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-03-10&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Sunday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-04-14&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-04-13&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Good&nbsp;Friday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-04-15&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-04-13&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Saturday&nbsp;after&nbsp;Good&nbsp;Friday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-04-16&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-04-13&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Sunday&nbsp;after&nbsp;Good&nbsp;Friday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-04-17&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-04-13&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Easter&nbsp;Monday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2017-05-25&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2017-05-24&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Ascension&nbsp;Day&nbsp;-&nbsp;Thursday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2110-05-26&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2110-05-23&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Whit&nbsp;Monday</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;9713-05-05&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;9713-05-04&quot;</span>)]&nbsp;<span style="color:green;">//&nbsp;Liberation&nbsp;Day</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;AdjustToLatestPrecedingDutchBankDayReturnsCorrectResult(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;sutS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;expectedS)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;<span style="color:#2b91af;">DateTimeOffset</span>.Parse(sutS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;sut.AdjustToLatestPrecedingDutchBankDay();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(<span style="color:#2b91af;">DateTimeOffset</span>.Parse(expectedS),&nbsp;actual);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		All test cases pass. This works in <code>[Theory]</code>, but unfortunately, it turns out, it doesn't work in practice.
	</p>
	<p>
		When used in an ASP.NET Web API application, <code>AdjustToLatestPrecedingDutchBankDay</code> throws a <code>StackOverflowException</code>. It took me a while to figure out why, but it turns out that the stack size is smaller in IIS than when you run a 'normal' .NET process, such as an automated test.
	</p>
	<p>
		<code>System.DateTime</code> is a value type, and as far as I can tell, it uses some stack space during initialisation. When the <code>DateTimeExtensions</code> class is first used, the static <code>dutchHolidays</code> array is initialised, and that uses enough stack space to exhaust the stack when running in IIS.
	</p>
	<p>
		<strong>Final implementation</strong>
	</p>
	<p>
		The stack space problem seems to be related to <code>DateTime</code> initialisation. If I store a similar number of 64-bit integers in an array, it seems that there's no problem.
	</p>
	<p>
		First, I had to modify the <code>formatHoliday</code> function:
	</p>
	<p>
		<pre><span style="color:blue;">let</span>&nbsp;<span style="color:navy;">formatHoliday</span>&nbsp;(h&nbsp;:&nbsp;Model.PublicHoliday)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;t,&nbsp;y,&nbsp;m,&nbsp;d&nbsp;=&nbsp;h.Date.Ticks,&nbsp;h.Date.Year,&nbsp;h.Date.Month,&nbsp;h.Date.Day
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">sprintf</span>&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:teal;">%19i</span><span style="color:#a31515;">L,&nbsp;//&nbsp;</span><span style="color:teal;">%i</span><span style="color:#a31515;">-</span><span style="color:teal;">%02i</span><span style="color:#a31515;">-</span><span style="color:teal;">%02i</span><span style="color:#a31515;">,&nbsp;</span><span style="color:teal;">%s</span><span style="color:#a31515;">/</span><span style="color:teal;">%s</span><span style="color:#a31515;">&quot;</span>&nbsp;t&nbsp;y&nbsp;m&nbsp;d&nbsp;h.Name&nbsp;h.LocalName</pre>
	</p>
	<p>
		This enabled me to generate a new file with C# code fragments, but now containing ticks instead of <code>DateTime</code> values. Copying those C# fragments into my file gave me this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">DateTimeExtensions</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">DateTimeOffset</span>&nbsp;AdjustToLatestPrecedingDutchBankDay(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">DateTimeOffset</span>&nbsp;value)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;candidate&nbsp;=&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">while</span>&nbsp;(!(IsDutchBankDay(candidate.DateTime)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidate&nbsp;=&nbsp;candidate.AddDays(-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;candidate;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;IsDutchBankDay(<span style="color:#2b91af;">DateTime</span>&nbsp;date)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(date.DayOfWeek&nbsp;==&nbsp;<span style="color:#2b91af;">DayOfWeek</span>.Saturday)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(date.DayOfWeek&nbsp;==&nbsp;<span style="color:#2b91af;">DayOfWeek</span>.Sunday)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(dutchHolidays.Contains(date.Date.Ticks))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">#region</span>&nbsp;Dutch&nbsp;holidays
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">long</span>[]&nbsp;dutchHolidays&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636188256000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-01-01,&nbsp;New&nbsp;Year&#39;s&nbsp;Day/Nieuwjaarsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636277248000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-04-14,&nbsp;Good&nbsp;Friday/Goede&nbsp;Vrijdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636279840000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-04-17,&nbsp;Easter&nbsp;Monday/&nbsp;Pasen</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636288480000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-04-27,&nbsp;King&#39;s&nbsp;Day/Koningsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636295392000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-05-05,&nbsp;Liberation&nbsp;Day/Bevrijdingsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636312672000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-05-25,&nbsp;Ascension&nbsp;Day/Hemelvaartsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636322176000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-06-05,&nbsp;Whit&nbsp;Monday/Pinksteren</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636497568000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-12-25,&nbsp;Christmas&nbsp;Day/Eerste&nbsp;kerstdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636498432000000000L,&nbsp;<span style="color:green;">//&nbsp;2017-12-26,&nbsp;St.&nbsp;Stephen&#39;s&nbsp;Day/Tweede&nbsp;kerstdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636503616000000000L,&nbsp;<span style="color:green;">//&nbsp;2018-01-01,&nbsp;New&nbsp;Year&#39;s&nbsp;Day/Nieuwjaarsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;636579648000000000L,&nbsp;<span style="color:green;">//&nbsp;2018-03-30,&nbsp;Good&nbsp;Friday/Goede&nbsp;Vrijdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Lots&nbsp;and&nbsp;lots&nbsp;of&nbsp;dates...</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3155171616000000000L,&nbsp;<span style="color:green;">//&nbsp;9999-05-06,&nbsp;Ascension&nbsp;Day/Hemelvaartsdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3155181120000000000L,&nbsp;<span style="color:green;">//&nbsp;9999-05-17,&nbsp;Whit&nbsp;Monday/Pinksteren</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3155372928000000000L,&nbsp;<span style="color:green;">//&nbsp;9999-12-25,&nbsp;Christmas&nbsp;Day/Eerste&nbsp;kerstdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3155373792000000000L,&nbsp;<span style="color:green;">//&nbsp;9999-12-26,&nbsp;St.&nbsp;Stephen&#39;s&nbsp;Day/Tweede&nbsp;kerstdag</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">#endregion</span>
}</pre>
	</p>
	<p>
		That implementation still passes all tests, <em>and</em> works at in practice as well.
	</p>
	<p>
		<strong>Conclusion</strong>
	</p>
	<p>
		It took me some time to find a satisfactory solution. I had more than once false start, until I ultimately arrived at the solution I've described here. I consider it simple because it's self-contained, deterministic, easy to understand, and fairly easy to maintain. I even left a comment in the code (not shown here) that described how to recreate the configuration data using the F# script shown here.
	</p>
	<p>
		The first solution that comes into your mind may not be the simplest solution, but if you take some time to consider alternatives, you may save yourself and your colleagues some future grief.
	</p>
</div>

<div id="comments">
<hr>
<h2 id="comments-header">
	Comments
</h2>
  <div class="comment">
    <div class="comment-author"><a href="http://stackoverflow.com/users/861565/jadarnel27">jadarnel27</a></div>
    <div class="comment-content">
      <p>
	      What do you think about creating an "admin page" that would allow users to configure the bank holidays themselves (which would then be persisted in the application database)?  This moves the burden of correctness to the administrators of the application, who I'm sure are highly motivated to get this right - as well as maintain it.  It also removes the need for a deployment in the face of changing holidays.
      </p>
      <p>
	      For the sake of convenience, you could still "seed" the database with the values generated by your F# script
      </p>
    </div>
    <div class="comment-date">2017-04-25 20:00 UTC</div>
  </div>

  <div class="comment">
    <div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
      	jadarnel27, thank you for writing. Your suggestion could be an option as well, but is hardly the simplest solution. In order to implement that, I'd need to add an administration web site for my application, program the user interface, connect the administration site and my original application (a REST API) to a persistent data source, write code for input validation, etcetera.
      </p>
      <p>
      	Apart from all that work, the bank holidays would have to be stored in an out-of-process data store, such as a database or NoSQL data store, because the REST API that needs this feature is running in a server farm. This adds latency to each lookup, as well as a potential error source. What should happen if the connection to the data store is broken? Additionally, such a data store should be backed up, so we'd also need to establish an operational procedure to ensure that that happens.
      </p>
      <p>
      	It was never a requirement that the owners of the application should be able to administer this themselves. It's certainly an option, but it's so much more complex than the solution outlined above that I think one should start by making a return-on-investment analysis.
      </p>
    </div>
    <div class="comment-date">2017-04-26 7:55 UTC</div>
  </div>
  <div class="comment">
    <div class="comment-author"><a href="http://www.lefdal.cc/info">Alf KÃ¥re Lefdal</a></div>
    <div class="comment-content">
      <p>
	Another option: Calculate the holidays! I think you might find som useful code in my 
	<a href="https://github.com/aklefdal/HolidaysApi/tree/master/HolidaysApi">HolidaysAPI</a>. It is even in F#, and the
	Web project is based upon a course or blog post by you.
      </p>
    </div>
    <div class="comment-date">2017-04-26 19:26 UTC</div>
  </div>

  <div class="comment">
    <div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
      	Alf, thank you for writing. Apart from the alternative library, how is that different from the option I covered under the heading <em>Option: Nager.Date?</em>
      </p>
    </div>
    <div class="comment-date">2017-04-27 5:38 UTC</div>
  </div>

  <div class="comment">
    <div class="comment-author"><a href="http://blog.enazarov.ru">EQR</a></div>
    <div class="comment-content">
      <p>
		Great post, thanks. The minor point here is that it is probably not so effective to do Contains over long[]. I'd consider using something that can check the value existance faster.
      </p>
    </div>
    <div class="comment-date">2017-04-30 19:00 UTC</div>
  </div>

  <div class="comment">
    <div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
      	EQR, thank you for writing. The performance profile of the implementation wasn't my main concern with this article, so it's likely that it can be improved.
      </p>
      <p>
      	I did do some lackadaisical performance testing, but didn't detect any measurable difference between the implementation shown here, and one using a HashSet. On the other hand, there are other options I didn't try at all. One of these could be to perform a binary search, since the array is already ordered.
      </p>
    </div>
    <div class="comment-date">2017-05-15 11:03 UTC</div>
  </div>
	
  <div class="comment">
    <div class="comment-author"><a href="https://evilpilaf.io/">Thomas</a></div>
    <div class="comment-content">
      <p>
		Hi Mark, thanks for this post. One small note on your selection of bank holidays. Liberation day is an official bank holiday, but only for civil servants, for us 'normal' people this only happens every 5 years. This is reflected in Nager.Date wrong <a href="https://github.com/tinohager/Nager.Date/blob/master/Nager.Date/PublicHolidays/NetherlandsProvider.cs#L51">here</a>
      </p>
    </div>
    <div class="comment-date">2017-07-25 13:35 UTC</div>
  </div>

  <div class="comment">
    <div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
      	Thomas, thank you for writing. That just goes to show, I think, that holiday calculation is as complicated as any other 'business logic'. It should be treated as such, and not as an algorithmic calculation.
      </p>
    </div>
    <div class="comment-date">2017-07-25 15:12 UTC</div>
  </div>
</div>
