---
layout: post
tags: [AutoFixture, Unit Testing]
date: 2010-06-29 08:39:30
title: "Introducing AutoFixture Likeness"
---
{% include JB/setup %}

<div id="post">
	<p>The <a href="http://blog.ploeh.dk/2010/04/06/MappingTypesWithAutoFixture.aspx">last time I presented a sample</a> of an <a href="http://autofixture.codeplex.com/">AutoFixture</a>-based unit test, I purposely glossed over the state-based verification that asserted that the resulting state of the <em>basket</em> variable was that the appropriate Pizza was added:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red43\green145\blue175;\red255\green255\blue255;\red0\green0\blue0;\red163\green21\blue21;}??\fs20 \cf1 Assert\cf0 .IsTrue(basket.Pizze.Any(p =&gt;\par ??    p.Name == pizza.Name), \cf4 "Basket has added pizza."\cf0 );}
--> <div style="font-family: courier new; background: white; color: black; font-size: 10pt"><pre style="margin: 0px"><span style="color: #2b91af">Assert</span>.IsTrue(basket.Pizze.Any(p =&gt;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; p.Name == pizza.Name), <span style="color: #a31515">"Basket has added pizza."</span>);</pre></div>
<p>The main issue with this assertion is that the implied equality expression is rather weak: we consider a PizzaPresenter instance to be equal to a Pizza instance if their Name properties match.</p>
<p>What if they have other properties (like Size) that don't match? If this is the case, the test would be a <a href="http://xunitpatterns.com/false%20negative.html">false negative</a>. A match would be found in the Pizze collection, but the instances would not truly represent the same pizza.</p>
<p>How do we resolve this conundrum without introducing <a href="http://xunitpatterns.com/Test%20Logic%20in%20Production.html#Equality%20Pollution">equality pollution</a>? AutoFixture offers one option in the form of the generic Likeness&lt;TSource, TDestination&gt; class. This class offers convention-based <a href="http://xunitpatterns.com/test-specific%20equality.html">test-specific equality</a> mapping from TSource to TDestination and overriding the Equals method.</p>
<p>One of the ways we can use it is by a convenience extension method. This unit test is a refactoring of the test from the previous post, but now using Likeness:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;}??\fs20 [\cf3 TestMethod\cf0 ]\par ??\cf4 public\cf0  \cf4 void\cf0  AddWillAddToBasket_Likeness()\par ??\{\par ??    \cf5 // Fixture setup\par ??\cf0     \cf4 var\cf0  fixture = \cf4 new\cf0  \cf3 Fixture\cf0 ();\par ??    fixture.Register&lt;\cf3 IPizzaMap\cf0 , \cf3 PizzaMap\cf0 &gt;();\par ??\par ??    \cf4 var\cf0  basket = fixture.Freeze&lt;\cf3 Basket\cf0 &gt;();\par ??\par ??    \cf4 var\cf0  pizza = fixture.CreateAnonymous&lt;\cf3 PizzaPresenter\cf0 &gt;();\par ??    \cf4 var\cf0  expectedPizza = \par ??        pizza.AsSource().OfLikeness&lt;\cf3 Pizza\cf0 &gt;();\par ??\par ??    \cf4 var\cf0  sut = fixture.CreateAnonymous&lt;\cf3 BasketPresenter\cf0 &gt;();\par ??    \cf5 // Exercise system\par ??\cf0     sut.Add(pizza);\par ??    \cf5 // Verify outcome\par ??\cf0     \cf3 Assert\cf0 .IsTrue(basket.Pizze.Any(expectedPizza.Equals));\par ??    \cf5 // Teardown\par ??\cf0 \}}
-->
<div style="font-family: courier new; background: white; color: black; font-size: 10pt"><pre style="margin: 0px">[<span style="color: #2b91af">TestMethod</span>]</pre><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">void</span> AddWillAddToBasket_Likeness()</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">var</span> fixture = <span style="color: blue">new</span> <span style="color: #2b91af">Fixture</span>();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; fixture.Register&lt;<span style="color: #2b91af">IPizzaMap</span>, <span style="color: #2b91af">PizzaMap</span>&gt;();</pre><pre style="margin: 0px">&nbsp;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">var</span> basket = fixture.Freeze&lt;<span style="color: #2b91af">Basket</span>&gt;();</pre><pre style="margin: 0px">&nbsp;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">var</span> pizza = fixture.CreateAnonymous&lt;<span style="color: #2b91af">PizzaPresenter</span>&gt;();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">var</span> expectedPizza = </pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pizza.AsSource().OfLikeness&lt;<span style="color: #2b91af">Pizza</span>&gt;();</pre><pre style="margin: 0px">&nbsp;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">var</span> sut = fixture.CreateAnonymous&lt;<span style="color: #2b91af">BasketPresenter</span>&gt;();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; sut.Add(pizza);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Assert</span>.IsTrue(basket.Pizze.Any(expectedPizza.Equals));</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Teardown</span></pre><pre style="margin: 0px">}</pre></div>
<p>Notice how the Likeness instance is created with the AsSource() extension method. The <em>pizza</em> instance (of type PizzaPresenter) is the source of the Likeness, whereas the Pizza domain model type is the destination. The <em>expectedPizza</em> instance is of type Likeness&lt;PizzaPresenter, Pizza&gt;.</p>
<p>The Likeness class overrides Equals with a convention-based comparison: if two properties have the same name and type, they are equal if their values are equal. All public properties on the destination must have equal properties on the source.</p>
<p>This allows me to specify the Equals method as the predicate for the Any method in the assertion:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red43\green145\blue175;\red255\green255\blue255;\red0\green0\blue0;}??\fs20 \cf1 Assert\cf0 .IsTrue(basket.Pizze.Any(expectedPizza.Equals));}
-->
<div style="font-family: courier new; background: white; color: black; font-size: 10pt"><pre style="margin: 0px"><span style="color: #2b91af">Assert</span>.IsTrue(basket.Pizze.Any(expectedPizza.Equals));</pre></div>
<p>When the Any method evalues the Pizze collection, it executes the Equals method on Likeness, resulting in a convention-based comparison of all public properties and fields on the two instances.</p>
<p>It's possible to customize the comparison to override the behavior for certain properties, but I will leave that to later posts. This post only scratches the surface of what Likeness can do.</p>
<p>To use Likeness, you must add a reference to the Ploeh.SemanticComparison assembly. You can create a new instance using the public constructor, but to use the AsSource extension method, you will need to add a using directive:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;}??\fs20 \cf1 using\cf0  Ploeh.SemanticComparison.Fluent;}
-->
<div style="font-family: courier new; background: white; color: black; font-size: 10pt"><pre style="margin: 0px"><span style="color: blue">using</span> Ploeh.SemanticComparison.Fluent;</pre></div>
</div>
	