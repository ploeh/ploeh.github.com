---
layout: post
title: "Tautological assertions are not always caused by aliasing"
description: "You can also make mistakes that compile in Haskell."
date: 2025-12-15 14:12 UTC
tags: [Unit Testing, Haskell]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        Seeing a (unit) test fail before making it pass is an <a href="/2025/10/20/epistemology-of-software">important part of empirical software engineering</a>. This is nothing new. We've known about the <a href="https://www.jamesshore.com/v2/blog/2005/red-green-refactor">red-green-refactor</a> cycle for at least twenty years, so we know that ensuring that a test can fail is of the essence.
    </p>
    <p>
        A fundamental problem of automated testing is that we're writing code to test code. How do we know that our test code works? After all, it's easy enough to make mistakes, even with simple code.
    </p>
    <h3 id="39ab6414de2141288bcc4d513d1fefc1">
        The importance of discipline <a href="#39ab6414de2141288bcc4d513d1fefc1">#</a>
    </h3>
    <p>
        When I test-drive a programming task, it regularly happens that I write a test that I expect to fail, only for it to pass. Even so, it doesn't happen that often. During a week of intensive coding, it may happen once or twice.
    </p>
    <p>
        After all, a unit test is supposed to be a simple, short block of code, ideally with a <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a> of 1. If you're an experienced programmer, working in a language that you know, you wouldn't expect to make simple mistakes too often.
    </p>
    <p>
        It's easy to get lulled into a false sense of security. When new tests fail (as they should) more than 95% of the time, you may be tempted to cut corners: Just write the test, implement the desired code, and move on.
    </p>
    <p>
        My experience is, however, that I inadvertently write a passing test now and then. I've been doing test-driven development (TDD) for more than twenty years, and this still happens. It is therefore important to keep up discipline and run that damned test, even if you don't feel like it. It's exactly when your attention is flagging that you need this safety mechanism the most.
    </p>
    <p>
        Until you've tried a couple of times writing a test that unexpectedly pass, it can be hard to grasp why the <em>red</em> phase is essential. Therefore I've always felt that it was important to publish examples.
    </p>
    <h3 id="c9e6c65653d744789a1177ad5e56fd9c">
        Tautologies <a href="#c9e6c65653d744789a1177ad5e56fd9c">#</a>
    </h3>
    <p>
        A new test that passes on the first run is almost always a tautology. Theoretically, it may be that you <em>think</em> that the System Under Test does not yet have a certain capability, but after writing the test, it turns out that, after all, it does. This almost never happens to me. I can't rule out that this may have been the case once or twice in the last few decades, but it's as scarce as hen's teeth.
    </p>
    <p>
        Usually, the problem is that the test is a tautology. While you believe that the test correctly self-checks something relevant, in reality, it's written in such a way that it can't possibly fail.
    </p>
    <p>
        The first time I had the opportunity to document such a <a href="/2019/10/14/tautological-assertion">tautological assertion</a> the underlying problem turned out to be <a href="https://en.wikipedia.org/wiki/Aliasing_(computing)">aliasing</a>. The next examples I ran into also had their roots in aliasing.
    </p>
    <p>
        I began to wonder: Is the problem of tautological assertions mostly related to aliasing? If so, does it mean that the phenomenon of writing a passing test by mistake is mostly isolated to procedural and object-oriented programming? Could it be that this doesn't happen in functional programming?
    </p>
    <h3 id="9a1a568358924aeea3b98f5c0240c26d">
        If it compiles, it works <a href="#9a1a568358924aeea3b98f5c0240c26d">#</a>
    </h3>
    <p>
        Many so-called functional programming languages are in reality mixed-paradigm languages. The one that I know best is <a href="https://fsharp.org/">F#</a>, which <a href="https://en.wikipedia.org/wiki/Don_Syme">Don Syme</a> calls <em>functional-first</em>. Even so, it's explicitly designed to interact with .NET libraries written in other languages (almost always C#), so it can still suffer from aliasing problems. The same situation applies to <a href="https://clojure.org/">Clojure</a> and <a href="https://www.scala-lang.org/">Scala</a>, which both run on the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a>.
    </p>
    <p>
        A few languages are, however, unapologetically functional. <a href="https://www.haskell.org/">Haskell</a> is probably the most famous. If you rule out actions that run in <code>IO</code>, shared mutable state is not a concern.
    </p>
    <p>
        Haskell's type system is so advanced and powerful that there are programmers who still seem to approach the language with an implied attitude that if it compiles, it works. Clearly, as we shall see, that is not the case.
    </p>
    <h3 id="d66b70f0d56e4d38b2c2ff4b8fd91476">
        Example <a href="#d66b70f0d56e4d38b2c2ff4b8fd91476">#</a>
    </h3>
    <p>
        Last week, I was writing tests against an API that was already given. As the 53rd test, I wrote this:
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Cell&nbsp;1&nbsp;does&nbsp;not&nbsp;reproduce&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell1&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;cheater)&nbsp;(mkStdGen&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell2&nbsp;=&nbsp;Galapagos.CellState&nbsp;Nothing&nbsp;(mkStdGen&nbsp;1)&nbsp;<span style="color:green;">--&nbsp;seeded:&nbsp;no&nbsp;repr.
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.reproduce&nbsp;Galapagos.defaultParams&nbsp;(cell1,&nbsp;cell2)
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">--&nbsp;Sanity&nbsp;check&nbsp;that&nbsp;cell&nbsp;1&nbsp;remains,&nbsp;sampling&nbsp;on&nbsp;strategy:
</span>&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;Galapagos.finchStrategyExp&nbsp;&lt;$&gt;&nbsp;Galapagos.cellFinch&nbsp;(<span style="color:blue;">fst</span>&nbsp;actual))&nbsp;@?=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Galapagos.finchStrategyExp&nbsp;&lt;$&gt;&nbsp;Galapagos.cellFinch&nbsp;cell1
&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;Galapagos.finchHP&nbsp;&lt;$&gt;&nbsp;Galapagos.cellFinch&nbsp;cell2)&nbsp;@?=&nbsp;Nothing</pre>
    </p>
    <p>
        To my surprise, it immediately passed. What's wrong with it? Before reading on, see if you can spot the problem.
    </p>
    <p>
        I know that you don't know the problem domain or the particular API. Even so, the problem is in the test itself, not in the implementation code. After all, according to the red-green-refactor cycle, I hadn't yet added the code that would make this test pass.
    </p>
    <p>
        The error is that I meant to verify that the <code>actual</code> value's second component remained <code>Nothing</code>, but either due to a brain fart, or because I copied an earlier test, the last assertion checks that <code>cell2</code> is <code>Nothing</code>.
    </p>
    <p>
        Since <code>cell2</code> is originally initialized with <code>Nothing</code>, and Haskell values are immutable, there's no way it could be anything else. This is a tautological assertion. The correct assertion is
    </p>
    <p>
        <pre>(Galapagos.finchHP&nbsp;&lt;$&gt;&nbsp;Galapagos.cellFinch&nbsp;(<span style="color:blue;">snd</span>&nbsp;actual))&nbsp;@?=&nbsp;Nothing</pre>
    </p>
    <p>
        Notice that it examines <code>snd actual</code> rather than <code>cell2</code>.
    </p>
    <h3 id="742d2bcf8fa84779ae120603e2b66347">
        Causes <a href="#742d2bcf8fa84779ae120603e2b66347">#</a>
    </h3>
    <p>
        How could I be so stupid? First, to err is human, and this is exactly why it's important to start with a failing test. The error was mine, but even so, it sometimes pays to analyse if there might be an underlying driving force behind the error. In this case, I can identify at least two, although they are related.
    </p>
    <p>
        First, I don't recall exactly how I wrote this test, but looking at previous commits, I find it likely that I copied and pasted an earlier test case. Evidently, I failed to correctly alter the assertion to specify the new test case.
    </p>
    <p>
        Why was I even copying and pasting the test? Because the test is too complicated. As a rule of thumb, pay attention to copy-and-paste, also of test cases. <a href="/2025/12/01/treat-test-code-like-production-code">Test code should be well-factored</a>, without too much duplication, for the same reasons that apply to other code. If a test is too difficult to write, it indicates that the API is too difficult to use. This is feedback about the API design, and you should consider if simplification is possible.
    </p>
    <p>
        And the test is, indeed, too complicated. What I wanted to verify is that <code>Galapagos.cellFinch (snd actual)</code> is <code>Nothing</code>. If so, why didn't I just write <code>Galapagos.cellFinch (snd actual) @?= Nothing</code>? Because that doesn't compile.
    </p>
    <p>
        The issue is that the data type in question (<code>Finch</code>) doesn't have an <code>Eq</code> instance, which <code>@?=</code> requires. Thus, I had to project the value I wanted to examine to a value that does have an <code>Eq</code> instance, such <code>finchHP</code>, which is an <code>Int</code>.
    </p>
    <p>
        Why didn't I assert on <a href="https://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:isNothing">isNothing</a> instead? Eventually, I did, but the problem with asserting on raw Boolean values is that when the assertion fails, you get no good feedback. The test runner will only tell you that the expected value was <code>True</code>, but the actual value <code>False</code>.
    </p>
    <p>
        The <a href="https://hackage-content.haskell.org/package/tasty-hunit/docs/Test-Tasty-HUnit.html#v:assertBool">assertBool</a> action offers a solution, but then you have to write your own error message, and I wasn't yet ready to do that. Eventually, I did, though.
    </p>
    <p>
        The bottom line is that the risk of making mistakes increases, the more complicated things become. This also applies to functional programming, but in reality, simple is rarely easy.
    </p>
    <h3 id="bb165f0d1d904feda4e8c9bd3098fd12">
        Conclusion <a href="#bb165f0d1d904feda4e8c9bd3098fd12">#</a>
    </h3>
    <p>
        Tautological assertions are not only caused by aliasing, but also plain human error. In this article, you've seen an example of such an error in Haskell. This is a language with a type system that can identify many errors at compile time. Even so, some errors are run-time errors, and when it comes to TDD, in the <em>red</em> phase, the absence of failure indicates an error.
    </p>
    <p>
        I find it important to share such errors when they occur, because they are at the same time regular and uncommon. While rare, they still happen with some periodicity. Since, after all, they don't happen that often, it may take time if you only have your own mistakes to learn from. So learn from mine, too.
    </p>
</div>