---
layout: post
title: "Devil's advocate"
description: "How do you know when you have enough test cases. The Devil's Advocate technique can help you decide."
date: 2019-10-07 15:00 UTC
tags: [Unit Testing]
image: "/content/binary/coverage-of-can-accept-method.png"
image_alt: "Screen shot showing that the CanAccept method is 100% covered."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		When I review unit tests, I often utilise a technique I call <em>Devil's Advocate</em>. I do the same whenever I consider if I have a sufficient number of test cases. The first time I explicitly named the technique was, I think, in my <a href="/outside-in-tdd">Outside-in TDD Pluralsight course</a>, in which I also discuss the so-called <em>Gollum style</em> variation. I don't think, however, that I've ever written an article explicitly about this topic. The current text attempts to rectify that omission.
	</p>
	<h3 id="a66b04a5812b4a84ba3a60a8609e58be">
		Coverage <a href="#a66b04a5812b4a84ba3a60a8609e58be" title="permalink">#</a>
	</h3>
	<p>
		Programmers new to unit testing often struggle with identifying useful test cases. I sometimes see people writing redundant unit tests, while, on the other hand, forgetting to add important test cases. How do you know which test cases to add, and how do you know when you've added enough?
	</p>
	<p>
		I may return to the first question in another article, but in this, I wish to address the second question. How do you know that you have a sufficient set of test cases?
	</p>
	<p>
		You may think that this is a question of turning on code coverage. Surely, if you have <a href="/2015/11/16/code-coverage-is-a-useless-target-measure">100% code coverage</a>, that's sufficient?
	</p>
	<p>
		It's not. Consider this simple class:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">capacity</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Capacity&nbsp;=&nbsp;<span style="color:#1f377f;">capacity</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">int</span>&nbsp;Capacity&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Sum</span>(<span style="color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">r</span>.Quantity);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">if</span>&nbsp;(Capacity&nbsp;&lt;&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;+&nbsp;<span style="color:#1f377f;">reservation</span>.Quantity)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">false</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		This class implements the (simplified) decision logic for an online restaurant reservation system. The <code>CanAccept</code> method has a cyclomatic complexity of 2, so it should be easy to cover with a pair of unit tests:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWithNoPriorReservations</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;4
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>[0],&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}
 
[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptOnInsufficientCapacity</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;4
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;7&nbsp;}&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">False</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		These two tests together completely cover the <code>CanAccept</code> method:
	</p>
	<p>
		<img src="/content/binary/coverage-of-can-accept-method.png" alt="Screen shot showing that the CanAccept method is 100% covered.">
	</p>
	<p>
		You'd think that this is a sufficient number of test cases of the method, then.
	</p>
	<h3 id="0ac61ef87e3f4e738475e97179242db5">
		As the Devil reads the Bible <a href="#0ac61ef87e3f4e738475e97179242db5" title="permalink">#</a>
	</h3>
	<p>
		In Scandinavia we have an idiom that <a href="https://www.kentbeck.com">Kent Beck</a> (who's worked with Norwegian companies) has also encountered:
		<blockquote>
			<p>
				"TIL: "like the devil reads the Bible"--meaning someone who carefully reads a book to subvert its intent"
			</p>
			<footer><cite><a href="https://twitter.com/kentbeck/status/651817458857320449">Kent Beck</a></cite></footer>
		</blockquote>
		We have the same saying in Danish, and the Swedes also use it.
	</p>
	<p>
		If you think of a unit test suite as an executable specification, you may consider if you can follow the specification to the letter while intentionally introduce a defect. You can easily do that with the above <code>CanAccept</code> method:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Sum</span>(<span style="color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">r</span>.Quantity);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">if</span>&nbsp;(Capacity&nbsp;&lt;=&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;+&nbsp;<span style="color:#1f377f;">reservation</span>.Quantity)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">false</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">true</span>;
}</pre>
	</p>
	<p>
		This still passes both tests, and still has a code coverage of 100%, yet it's 'obviously' wrong.
	</p>
	<p>
		Can you spot the difference?
	</p>
	<p>
		Instead of a <em>less-than</em> comparison, it now uses a <em>less-than-or-equal</em> comparison. You could easily, inadvertently, make such a mistake while programming. It belongs in the category of <em>off-by-one errors</em>, which is one of the most common type of bugs.
	</p>
	<p>
		This is, in a nutshell, the Devil's Advocate technique. The intent isn't to break the software by sneaking in defects, but to explore how effectively the test suite detects bugs. In the current (simplified) example, the effectiveness of the test suite isn't impressive.
	</p>
	<h3 id="d6e4c657adec4cc1bb6d10af351a415f">
		Add test cases <a href="#d6e4c657adec4cc1bb6d10af351a415f" title="permalink">#</a>
	</h3>
	<p>
		The problem introduced by the Devil's Advocate is an edge case. If the reservation under consideration fits the restaurant's remaining capacity, but entirely consumes it, the <code>MaîtreD</code> class should still accept it. Currently, however, it doesn't.
	</p>
	<p>
		It'd seem that the obvious solution is to 'fix' the unit test:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWithNoPriorReservations</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;10
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>[0],&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		Changing the requested <code>Quantity</code> to <code>10</code> does, indeed, cause the test to fail.
	</p>
	<h3 id="26be7b38248c4dcba5134eb4529d8214">
		Beyond mutation testing <a href="#26be7b38248c4dcba5134eb4529d8214" title="permalink">#</a>
	</h3>
	<p>
		Until this point, you may think that the Devil's Advocate just looks like <em>an ad-hoc, informally-specified, error-prone, manual version of half of <a href="https://en.wikipedia.org/wiki/Mutation_testing">mutation testing</a></em>. So far, the change I made above could also have been made during mutation testing.
	</p>
	<p>
		What I sometimes do with the Devil's Advocate technique is to experiment with other, less heuristically driven changes. For instance, based on my knowledge of the existing test cases, it's not too difficult to come up with this change:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Sum</span>(<span style="color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">r</span>.Quantity);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">if</span>&nbsp;(<span style="color:#1f377f;">reservation</span>.Quantity&nbsp;!=&nbsp;10)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">false</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">true</span>;
}</pre>
	</p>
	<p>
		That's an even simpler implementation than the original, but obviously wrong.
	</p>
	<p>
		This should prompt you to add at least one other test case:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4)]
[<span style="color:#2b91af;">InlineData</span>(10)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWithNoPriorReservations</span>(<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">quantity</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">quantity</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>[0],&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		Notice that I converted the test to a parametrised test. This breaks the Devil's latest attempt, while the original implementation passes all tests.
	</p>
	<p>
		The Devil, not to be outdone, now switches tactics and goes after the <code>reservations</code> instead:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;!<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Any</span>();
}</pre>
	</p>
	<p>
		This still passes all tests, including the new test case. This indicates that you'll need to add at least one test case with existing reservations, but where there's still enough capacity to accept another reservation:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWithOnePriorReservation</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;4
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;4&nbsp;}&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		This new test fails, prompting you to correct the implementation of <code>CanAccept</code>. The Devil, however, can do this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Sum</span>(<span style="color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">r</span>.Quantity);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;!=&nbsp;7;
}</pre>
	</p>
	<p>
		This is still not correct, but passes all tests. It does, however, look like you're getting closer to a proper implementation.
	</p>
	<h3 id="9b955ad4a2084823a9eeb668415eb696">
		Reverse Transformation Priority Premise <a href="#9b955ad4a2084823a9eeb668415eb696" title="permalink">#</a>
	</h3>
	<p>
		If you find this process oddly familiar, it's because it resembles the <a href="https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">Transformation Priority Premise</a> (TPP), just reversed.
		<blockquote>
			<p>
				“As the tests get more specific, the code gets more generic.”
			</p>
			<footer><cite><a href="https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">Robert C. Martin</a></cite></footer>
		</blockquote>
	</p>
	<p>
		When I test-drive code, I often try to follow the TPP, but when I review code with tests, the code and the tests are already in place, and it's my task to assess both.
	</p>
	<p>
		Applying the Devil's Advocate review technique to <code>CanAccept</code>, it seems as though I'm getting closer to a proper implementation. It does, however, require more tests. As your next move you may, for instance, consider parametrising the test case that verifies what happens when capacity is insufficient:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(7)]
[<span style="color:#2b91af;">InlineData</span>(8)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptOnInsufficientCapacity</span>(<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;4
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;}&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">False</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		That doesn't help much, though, because this passes all tests:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Sum</span>(<span style="color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">r</span>.Quantity);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;&lt;&nbsp;7;
}</pre>
	</p>
	<p>
		Compared to the initial, 'desired' implementation, there's at least two issues with this code:
		<ul>
			<li>It doesn't consider <code>reservation.Quantity</code></li>
			<li>It doesn't take into account the <code>Capacity</code> of the restaurant</li>
		</ul>
		This indicates that you're going to have to add more test cases, varying both <code>reservation.Quantity</code> and <code>Capacity</code>. The happy-path test cases already varies <code>reservation.Quantity</code> a bit, but <code>CanAcceptOnInsufficientCapacity</code> does not, so perhaps you can follow the TPP by varying <code>reservation.Quantity</code> in that method as well:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;1,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;2,&nbsp;&nbsp;9)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;3,&nbsp;&nbsp;8)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;&nbsp;7)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;&nbsp;8)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;5,&nbsp;&nbsp;6)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;6,&nbsp;&nbsp;5)]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;&nbsp;1)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptOnInsufficientCapacity</span>(<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">quantity</span>,&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">quantity</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;}&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">False</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		This makes it harder for the Devil to come up with a malevolent implementation. Harder, but not impossible.
	</p>
	<p>
		It seems clear that since all test cases still use a hard-coded capacity, it ought to be possible to write an implementation that ignores the <code>Capacity</code>, but at this point I don't see a simple way to avoid looking at <code>reservation.Quantity</code>:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Sum</span>(<span style="color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">r</span>.Quantity);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;+&nbsp;<span style="color:#1f377f;">reservation</span>.Quantity&nbsp;&lt;&nbsp;11;
}</pre>
	</p>
	<p>
		This implementation passes all the tests. The last batch of test cases forced the Devil to consider <code>reservation.Quantity</code>. This strongly implies that if you vary <code>Capacity</code> as well, the proper implementation out to emerge.
	</p>
	<h3 id="e3ed81c93d5847039ea53e7acd978d99">
		Diminishing returns <a href="#e3ed81c93d5847039ea53e7acd978d99" title="permalink">#</a>
	</h3>
	<p>
		What happens, then, if you add just one test case with a different <code>Capacity</code>?
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;1,&nbsp;10,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;2,&nbsp;&nbsp;9,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;3,&nbsp;&nbsp;8,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;&nbsp;7,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;&nbsp;8,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;5,&nbsp;&nbsp;6,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;6,&nbsp;&nbsp;5,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;&nbsp;1,&nbsp;10)]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;1,&nbsp;&nbsp;1,&nbsp;&nbsp;1)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptOnInsufficientCapacity</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">quantity</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">capacity</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">quantity</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;}&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">False</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		Notice that I just added one test case with a <code>Capacity</code> of <code>1</code>.
	</p>
	<p>
		You may think that this is about where the Devil ought to capitulate, but not so. This passes all tests:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">r</span>&nbsp;<span style="color:#8f08c4;">in</span>&nbsp;<span style="color:#1f377f;">reservations</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">r</span>.Quantity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">break</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;+&nbsp;<span style="color:#1f377f;">reservation</span>.Quantity&nbsp;&lt;=&nbsp;Capacity;
}</pre>
	</p>
	<p>
		Here you may feel the urge to protest. So far, all the Devil's Advocate implementations have been objectively <em>simpler</em> than the 'desired' implementation because it has involved fewer elements and has had a lower or equivalent <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a>. This new attempt to circumvent the specification seems more complex.
	</p>
	<p>
		It's also seems clearly ill-intentioned. Recall that the intent of the Devil's Advocate technique isn't to 'cheat' the unit tests, but rather to explore how well the test describe the desired behaviour of the system. The motivation is that it's easy to make off-by-one errors like inadvertently use <code>&lt;=</code> instead of <code>&lt;</code>. It doesn't seem quite as reasonable that a well-intentioned programmer accidentally would leave behind an implementation like the above.
	</p>
	<p>
		You can, however, make it <em>look</em> less complicated:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Select</span>(<span style="color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">r</span>.Quantity).<span style="color:#74531f;">FirstOrDefault</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;+&nbsp;<span style="color:#1f377f;">reservation</span>.Quantity&nbsp;&lt;=&nbsp;Capacity;
}</pre>
	</p>
	<p>
		You could argue that this still looks intentionally wrong, but I've seen much code that looks like this. It seems to me that there's a kind of programmer who seems generally uncomfortable thinking in collections; they seem to subconsciously gravitate towards code that deals with singular objects. Code that attempts to get 'the' value out of a collection is, unfortunately, not that uncommon.
	</p>
	<p>
		Still, you might think that at this point, you've added enough test cases. That's reasonable.
	</p>
	<p>
		The Devil's Advocate technique isn't an <em>algorithm</em>; it has no deterministic exit criterion. It's just a heuristic that I use to explore the quality of tests. There comes a point where subjectively, I judge that the test cases <em>sufficiently</em> describe the desired behaviour.
	</p>
	<p>
		You may find that we've reached that point now. You could, for example, argue that in order to calculate <code>reservedSeats</code>, <code>reservations.Sum(r =&gt; r.Quantity)</code> is simpler than <code>reservations.Select(r =&gt; r.Quantity).FirstOrDefault()</code>. I'd be inclined to agree.
	</p>
	<p>
		There's diminishing returns to the Devil's Advocate technique. Once you find that the gains from insisting on intentionally pernicious implementations are smaller than the effort required to add more test cases, it's time to stop and commit to the test cases now in place.
	</p>
	<h3 id="609ddb35ae364efbbfb7965a646d857e">
		Test case variability <a href="#609ddb35ae364efbbfb7965a646d857e" title="permalink">#</a>
	</h3>
	<p>
		Tests specify desired behaviour. If the tests contain less variability than the code they cover, then how can you be certain that the implementation code is correct?
	</p>
	<p>
		The discussion now moves into territory where I usually exercise a great deal of judgement. Read the following for inspiration, not as rigid instructions. My intent with the following is not to imply that you must always go to like extremes, but simply to demonstrate what you <em>can</em> do. Depending on circumstances (such as the cost of a defect in production), I may choose to do the following, and sometimes I may choose to skip it.
	</p>
	<p>
		If you consider the original implementation of <code>CanAccept</code> at the top of the article, notice that it works with <code>reservations</code> of indefinite size. If you think of <code>reservations</code> as a finite collection, it can contain zero, one, two, ten, or hundreds of elements. Yet, no test case goes beyond a single existing reservation. This is, I think, a disconnect. The tests come not even close to the degree of variability that the method can handle. If this is a piece of mission-critical software, that could be a cause for concern.
	</p>
	<p>
		You should add some test cases where there's two, three, or more existing reservations. People often don't do that because it seems that you'd now have to write a test method that exercises one or more test cases with two existing reservations:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWithTwoPriorReservations</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;4
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;4&nbsp;},&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;1&nbsp;}&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		While this method now covers the two-existing-reservations test case, you need one to cover the three-existing-reservations test case, and so on. This seems repetitive, and probably bothers you at more than one level:
		<ul>
			<li>It's just plain tedious to have to add that kind of variability</li>
			<li>It seems to violate the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principle</a></li>
		</ul>
		I don't hold the DRY principle as an absolute that must always be followed, but it often indicates a maintainability problem. I think this is the case here, because the new <code>CanAcceptWithTwoPriorReservations</code> test method looks a lot like the previous <code>CanAcceptWithOnePriorReservation</code> method. If someone makes changes to the <code>MaîtreD</code> class, they would have to go and revisit all those test methods.
	</p>
	<p>
		What you can do instead is to parametrise the key values of the collection(s) in question. While you can't put collections of objects in <code>[InlineData]</code> attributes, you <em>can</em> put arrays of constants. For existing reservations, the key values are the quantities, so supply an array of integers as a test argument:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">int</span>[0])]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">int</span>[0])]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;4&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;4,&nbsp;1&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;2,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;2,&nbsp;1,&nbsp;3,&nbsp;2&nbsp;})]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWhenCapacityIsSufficient</span>(<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">quantity</span>,&nbsp;<span style="color:blue;">int</span>[]&nbsp;<span style="color:#1f377f;">reservationQantities</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">quantity</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservations</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservationQantities</span>.<span style="color:#74531f;">Select</span>(<span style="color:#1f377f;">q</span>&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">q</span>&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		This single test method replaces the previous three 'happy path' test methods. The first four <code>[InlineData]</code> annotations reproduce the previous test cases, whereas the fifth <code>[InlineData]</code> annotation adds a new test case with four existing reservations.
	</p>
	<p>
		I gave the method a new name to better reflect the more general nature of it.
	</p>
	<p>
		Notice that the <code>CanAcceptWhenCapacityIsSufficient</code> method uses <code>Select</code> to turn the array of integers into a collection of <code>Reservation</code> objects.
	</p>
	<p>
		You may think that I cheated, since I didn't supply any other values, such as the <code>Date</code> property, to the existing reservations. This is easily addressed:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">int</span>[0])]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">int</span>[0])]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;4&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;4,&nbsp;1&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(&nbsp;2,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;2,&nbsp;1,&nbsp;3,&nbsp;2&nbsp;})]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWhenCapacityIsSufficient</span>(<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">quantity</span>,&nbsp;<span style="color:blue;">int</span>[]&nbsp;<span style="color:#1f377f;">reservationQantities</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">date</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:#1f377f;">date</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">quantity</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>:&nbsp;10);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservations</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservationQantities</span>.<span style="color:#74531f;">Select</span>(<span style="color:#1f377f;">q</span>&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">q</span>,&nbsp;Date&nbsp;=&nbsp;<span style="color:#1f377f;">date</span>&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		The only change compared to before is that <code>date</code> is now a variable assigned not only to <code>reservation</code>, but also to all the <code>Reservation</code> objects in <code>reservations</code>.
	</p>
	<h3 id="0564ebd7cafc44f4ba6ad017e3f0d0ce">
		Towards property-based testing <a href="#0564ebd7cafc44f4ba6ad017e3f0d0ce" title="permalink">#</a>
	</h3>
	<p>
		Looking at a test method like <code>CanAcceptWhenCapacityIsSufficient</code> it should bother you that the <code>capacity</code> is still hard-coded. Why don't you make that a test argument as well?
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;&nbsp;4,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">int</span>[0])]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;10,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">int</span>[0])]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;4&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;4,&nbsp;1&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(10,&nbsp;&nbsp;2,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;2,&nbsp;1,&nbsp;3,&nbsp;2&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(20,&nbsp;10,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;2,&nbsp;2,&nbsp;2,&nbsp;2&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(20,&nbsp;&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;2,&nbsp;2,&nbsp;4,&nbsp;1,&nbsp;3,&nbsp;3&nbsp;})]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWhenCapacityIsSufficient</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">capacity</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">quantity</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>[]&nbsp;<span style="color:#1f377f;">reservationQantities</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">date</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:#1f377f;">date</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">quantity</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservations</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservationQantities</span>.<span style="color:#74531f;">Select</span>(<span style="color:#1f377f;">q</span>&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">q</span>,&nbsp;Date&nbsp;=&nbsp;<span style="color:#1f377f;">date</span>&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		The first five <code>[InlineData]</code> annotations just reproduce the test cases that were already present, whereas the bottom two annotations are new test cases with another <code>capacity</code>.
	</p>
	<p>
		How do I come up with new test cases? It's easy: In the happy-path case, the sum of existing reservation quantities, plus the requested quantity, must be less than or equal to the <code>capacity</code>.
	</p>
	<p>
		It sometimes helps to slightly reframe the test method. If you allow the collection of existing reservations to be the most variable element in the test method, you can express the other values relative to that input. For example, instead of supplying the <code>capacity</code> as an absolute number, you can express a test case's capacity in relation to the existing reservations:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(6,&nbsp;&nbsp;4,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">int</span>[0])]
[<span style="color:#2b91af;">InlineData</span>(0,&nbsp;10,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">int</span>[0])]
[<span style="color:#2b91af;">InlineData</span>(2,&nbsp;&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;4&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(1,&nbsp;&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;4,&nbsp;1&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(0,&nbsp;&nbsp;2,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;2,&nbsp;1,&nbsp;3,&nbsp;2&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(2,&nbsp;10,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;2,&nbsp;2,&nbsp;2,&nbsp;2&nbsp;})]
[<span style="color:#2b91af;">InlineData</span>(1,&nbsp;&nbsp;4,&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;2,&nbsp;2,&nbsp;4,&nbsp;1,&nbsp;3,&nbsp;3&nbsp;})]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWhenCapacityIsSufficient</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">capacitySurplus</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:#1f377f;">quantity</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>[]&nbsp;<span style="color:#1f377f;">reservationQantities</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">date</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:#1f377f;">date</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">quantity</span>
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservationQantities</span>.<span style="color:#74531f;">Sum</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">capacity</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;+&nbsp;<span style="color:#1f377f;">quantity</span>&nbsp;+&nbsp;<span style="color:#1f377f;">capacitySurplus</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservations</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservationQantities</span>.<span style="color:#74531f;">Select</span>(<span style="color:#1f377f;">q</span>&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">q</span>,&nbsp;Date&nbsp;=&nbsp;<span style="color:#1f377f;">date</span>&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		Notice that the value supplied as a test argument is now named <code>capacitySurplus</code>. This represents the surplus capacity for each test case. For example, in the first test case, the <code>capacity</code> was previously supplied as the absolute number <code>10</code>. The requested quantity is <code>4</code>, and since there's no prior reservations in that test case, the capacity surplus, after accepting the reservation, is <code>6</code>.
	</p>
	<p>
		Likewise, in the second test case, the requested quantity is <code>10</code>, and since the absolute capacity is also <code>10</code>, when you reframe the test case, the surplus capacity, after accepting the reservation, is <code>0</code>.
	</p>
	<p>
		This seems odd if you aren't used to it. You'd probably intuitively think of a restaurant's <code>Capacity</code> as 'the most absolute' number, in that it's often a number that originates from physical constraints.
	</p>
	<p>
		When you're looking for test cases, however, you aren't looking for test cases for a particular restaurant. You're looking for test cases for an arbitrary restaurant. In other words, you're looking for test inputs that belong to the same <em>equivalence class</em>.
	</p>
	<h3 id="174e2338027e4f3ca0b84dd0fb6adc5f">
		Property-based testing <a href="#174e2338027e4f3ca0b84dd0fb6adc5f" title="permalink">#</a>
	</h3>
	<p>
		I haven't explicitly stated this yet, but both the <code>capacity</code> and each reservation <code>Quantity</code> should be a positive number. This should really have been <a href="/2015/01/19/from-primitive-obsession-to-domain-modelling">captured as a proper domain object</a>, but I chose to keep these values as primitive integers in order to not complicate the example too much.
	</p>
	<p>
		If you look at the test parameters for the latest incarnation of <code>CanAcceptWhenCapacityIsSufficient</code>, you may now observe the following:
		<ul>
			<li><code>capacitySurplus</code> can be an arbitrary non-negative number</li>
			<li><code>quantity</code> can be an arbitrary positive number</li>
			<li><code>reservationQantities</code> can be an arbitrary array of positive numbers, including the empty array</li>
		</ul>
		This isn't too hard to express with, say, <a href="https://fscheck.github.io/FsCheck">FsCheck</a> (2.14.0):
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Property</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#74531f;">CanAcceptWhenCapacityIsSufficient</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">NonNegativeInt</span>&nbsp;<span style="color:#1f377f;">capacitySurplus</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">PositiveInt</span>&nbsp;<span style="color:#1f377f;">quantity</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">PositiveInt</span>[]&nbsp;<span style="color:#1f377f;">reservationQantities</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">date</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DateTime</span>(2018,&nbsp;8,&nbsp;30);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservation</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;<span style="color:#1f377f;">date</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">quantity</span>.Item
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservationQantities</span>.<span style="color:#74531f;">Sum</span>(<span style="color:#1f377f;">x</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">x</span>.Item);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">capacity</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;+&nbsp;<span style="color:#1f377f;">quantity</span>.Item&nbsp;+&nbsp;<span style="color:#1f377f;">capacitySurplus</span>.Item;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MaîtreD</span>(<span style="color:#1f377f;">capacity</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservations</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#1f377f;">reservationQantities</span>.<span style="color:#74531f;">Select</span>(<span style="color:#1f377f;">q</span>&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;{&nbsp;Quantity&nbsp;=&nbsp;<span style="color:#1f377f;">q</span>.Item,&nbsp;Date&nbsp;=&nbsp;<span style="color:#1f377f;">date</span>&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#1f377f;">sut</span>.<span style="color:#74531f;">CanAccept</span>(<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#1f377f;">reservation</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">True</span>(<span style="color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		This refactoring takes advantage of FsCheck's built-in wrapper types <code>NonNegativeInt</code> and <code>PositiveInt</code>. If you'd like an introduction to FsCheck, you could watch my <a href="/property-based-testing-intro">Introduction to Property-based Testing with F#</a> Pluralsight course.
	</p>
	<p>
		By default, FsCheck runs each property 100 times, so now, instead of seven test cases, you now have 100.
	</p>
	<h3 id="1eddf5bb91324b18880c78d1f1825ea6">
		Limits to the Devil's Advocate technique <a href="#1eddf5bb91324b18880c78d1f1825ea6" title="permalink">#</a>
	</h3>
	<p>
		There's a limit to the Devil's Advocate technique. Unless you're working with <a href="/2015/02/23/property-based-testing-without-a-property-based-testing-framework">a problem where you can exhaust the entire domain of possible test cases</a>, your testing strategy is always going to be a sampling strategy. You run your automated tests with either hard-coded values or randomly generated values, but regardless, a test run isn't going to cover all possible input combinations.
	</p>
	<p>
		For example, a truly hostile Devil could make this change to the <code>CanAccept</code> method:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">CanAccept</span>(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&nbsp;<span style="color:#1f377f;">reservations</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">if</span>&nbsp;(<span style="color:#1f377f;">reservation</span>.Quantity&nbsp;==&nbsp;3953911)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:blue;">true</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;=&nbsp;<span style="color:#1f377f;">reservations</span>.<span style="color:#74531f;">Sum</span>(<span style="color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="color:#1f377f;">r</span>.Quantity);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;<span style="color:#1f377f;">reservedSeats</span>&nbsp;+&nbsp;<span style="color:#1f377f;">reservation</span>.Quantity&nbsp;&lt;=&nbsp;Capacity;
}</pre>
	</p>
	<p>
		Even if you increase the number of test cases that FsCheck generates to, say, 100,000, it's unlikely to find the poisonous branch. The chance of randomly generating a <code>quantity</code> of <em>exactly</em> <code>3953911</code> isn't that great.
	</p>
	<p>
		The Devil's Advocate technique doesn't guarantee that you'll have enough test cases to protect yourself against all sorts of odd defects. It does, however, still work well as an analysis tool to figure out if there's 'enough' test cases.
	</p>
	<h3 id="6ad7a48fd0c04f91af236d99f0722617">
		Conclusion <a href="#6ad7a48fd0c04f91af236d99f0722617" title="permalink">#</a>
	</h3>
	<p>
		The Devil's Advocate technique is a heuristic you can use to evaluate whether more test cases would improve confidence in the test suite. You can use it to review existing (test) code, but you can also use it as inspiration for new test cases that you should consider adding.
	</p>
	<p>
		The technique is to deliberately implement the system under test incorrectly. The more incorrect you can make it, the more test cases you'll be likely to have to add.
	</p>
	<p>
		When there's only a few test cases, you can probably get away with a decidedly unsound implementation that still passes all tests. These are often simpler than the 'intended' implementation. In this phase of applying the heuristic, this clearly demonstrates the need for more test cases.
	</p>
	<p>
		At a later stage, you'll have to go deliberately out of your way to produce a wrong implementation that still passes all tests. When that happens, it may be time to stop.
	</p>
	<p>
		The intent of the technique is to uncover how many test cases you need to protect against common defects in the future. Thus, it's not a measure of <em>current</em> code coverage.
	</p>
</div>

<div id="comments">
  <hr>
  <h2 id="comments-header">
    Comments
  </h2>
  <div class="comment" id="fd53c72c360b42999b87c87649460e78">
    <div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a> <a href="#fd53c72c360b42999b87c87649460e78">#</a></div>
    <div class="comment-content">
      <blockquote>
	    <p>
		  When there's only a few test cases, you can probably get away with a decidedly unsound implementation that still passes all tests. These are often simpler than the 'intended' implementation. In this phase of applying the heuristic, this clearly demonstrates the need for more test cases.
	    </p>
	    <p>
		  At a later stage, you'll have to go deliberately out of your way to produce a wrong implementation that still passes all tests. When that happens, it may be time to stop.
	    </p>
	  </blockquote>
      <p>
        I like to think of this behavior as a phrase transition.
      </p>
      <blockquote>
	    Unless you're working with a problem where you can exhaust the entire domain of possible test cases, your testing strategy is always going to be a sampling strategy.
	  </blockquote>
	  <p>
	    I agree with this in practice, but it is not always true in theory.  A counter eaxample is <a href="https://en.wikipedia.org/wiki/Polynomial_interpolation">polynomial interpolation</a>.
	  </p>
      <p>
        Normally we think of a polynomial in an indeterminate <code>x</code> of degree <code>n</code> as being specified by a list of <code>n + 1</code> coefficients, where the <code>i</code>th coefficient is the coefficient of <code>x<sup>i</sup></code>.  Evaluating this polynomial given a value for <code>x</code> is easy; it just involves exponentiation, multiplication, and addition.  Polynomial evaluation has a conceptual inverse called polynomial interpolation.  In this direction, the input is evaluations at <code>n + 1</code> points in "general position" and the output is the <code>n + 1</code> coefficients.  For example, a line is a polynomial of degree <code>1</code> and two points are in general position if they are not the same point.  This is commonly expressed the phrase "Any two (distinct) points defines a line."  Three points are in general position if they are not co-linear, where co-linear means that all three points are on the same line.  In general, <code>n + 1</code> points are in general position if they are not all on the same polynomial of degree <code>n</code>.
      <p>
      <p>
        Anyway, here is the point.  If a pure function is known to implement some polynomial of degree (at most) <code>n</code>, then even if the domain is infinite, there exists <code>n + 1</code> inputs such that it is sufficient to test this function for correctness on those inputs.
      </p>
      <p>
        This is why I think the phrase transition in the Devil's advocate testing is critical.  There is some objective measure of complexity of the function under test (such as cyclomatic complexity), and we have an intuitive sense that a certain number of tests is sufficient for testing functions with that complexity.  If the Devil is allowed to add monomials to the polynomial (or, heaven forbid, modify the implementation so that it is not a polynomial), then any finite number of tests can be circumvented.  If instead the Devil is only allowed to modify the coefficients of the polynomial, then we have a winning strategy.
      </p>
      <blockquote>
        Here you may feel the urge to protest. So far, all the Devil's Advocate implementations have been objectively simpler than the 'desired' implementation because it has involved fewer elements and has had a lower or equivalent cyclomatic complexity. This new attempt to circumvent the specification seems more complex.
      </blockquote>
      <p>
        I think it would be exceedingly intersting if you can formally define what you mean here by "objectively".  In the case of a polynomial (and speaking slightly roughly), changing the "first" nonzero coefficient to <code>0</code> decreases the complexity (i.e. the degree of the polynomial) while any other change to that coefficient or any change to any other coefficient maintains the complexity.
      </p>
    </div>
    <div class="comment-date">2019-10-25 01:32 UTC</div>
  </div>

 	<div class="comment" id="cb15452b8c96429998efd50b67373da3">
		<div class="comment-author"><a href="/">Mark Seemann</a> <a href="#cb15452b8c96429998efd50b67373da3">#</a></div>
		<div class="comment-content">
			<p>
				Tyson, thank you for writing. What I meant by <em>objectively simpler</em> I partially explain in the same paragraph. I consider cyclomatic complexity one of hardly any useful measurements in software development. As I also imply in the article, I consider Robert C. Martin's <em>Transformation Priority Premise</em> to include a good ranking of code constructs, e.g. that using a constant is simpler than using a variable, and so on.
			</p>
			<p>
				I don't think you need to reach for polynomial interpolation in order to make your point. Just consider a function that returns a constant value, like this one:
			</p>
			<p>
				<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Foo</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">i</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;foo&quot;</span>;
}</pre>
			</p>
			<p>
				You can make a similar argument about this function: You only need a single test value in order to demonstrate that it works as intended. I suppose you could view that as a zero-degree polynomial.
			</p>
			<p>
				Beyond what you think of as the <em>phase transition</em> I sometimes try to see what happens if I slightly <em>increase</em> the complexity of a function. For the <code>Foo</code> function, it could be a change like this:
			</p>
			<p>
				<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Foo</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">i</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">i</span>&nbsp;&lt;&nbsp;-1000)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;bar&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;foo&quot;</span>;
}</pre>
			</p>
			<p>
				Unless you just happened to pick a number less than <code>-1000</code> for your test value, your test will not discover such a change.
			</p>
			<p>
				Your argument attempts to guard against that sort of change by assuming that we can somehow 'forbid' a change from a polynomial to something irregular. Real code doesn't work that way. Real code is rarely a continuous function, but rather discrete. That's the reason we have a concept such as <em>edge case</em>, because code branches at discrete values.
			</p>
			<p>
				A polynomial is a single function, regardless of degree. Implemented in code, it'll have a cyclomatic complexity of 1. That may not even be worth testing, because you'd essentially only be reproducing the implementation code in your test.
			</p>
			<p>
				The purpose of the Devil's Advocate technique isn't to demonstrate correctness; that's what unit tests are for. The purpose of the Devil's Advocate technique is to critique the tests.
			</p>
			<p>
				In reality, I never imagine that some malicious developer gains access to the source code. On the other hand, we all make mistakes, and I try to imagine what a likely mistake might look like.
			</p>
		</div>
		<div class="comment-date">2019-10-26 3:57 UTC</div>
	</div>
</div>
