---
layout: post
title: "Simplifying assertions with lenses"
description: "Get ready for some cryptic infix operators."
date: 2025-11-10 12:18 UTC
tags: [Haskell, Functional Programming]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        In a <a href="" hint="Test-specific Eq">previous article</a> I left you with a remaining problem: A test with an assertion weaker than warranted. In this article, you'll see a few tests like that, and how using lenses may improve the situation.
    </p>
    <h3 id="bd06a1fffee14b6db64d27d4fe0aa959">
        Weak tests <a href="#bd06a1fffee14b6db64d27d4fe0aa959">#</a>
    </h3>
    <p>
        The previous article already showed an example of a test I wasn't fully happy with. For convenience, I'll repeat it here.
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Groom&nbsp;two&nbsp;finches&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell1&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell2&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;cheater)&nbsp;(mkStdGen&nbsp;1)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.groom&nbsp;Galapagos.defaultParams&nbsp;(cell1,&nbsp;cell2)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;Just&nbsp;&lt;$&gt;&nbsp;Pair
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;finchEq&nbsp;$&nbsp;samaritan&nbsp;{&nbsp;Galapagos.finchHP&nbsp;=&nbsp;16&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;finchEq&nbsp;$&nbsp;cheater&nbsp;{&nbsp;Galapagos.finchHP&nbsp;=&nbsp;13&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;(cellFinchEq&nbsp;&lt;$&gt;&nbsp;Pair&nbsp;actual)&nbsp;@?=&nbsp;expected</pre>
    </p>
    <p>
        Another test exhibits the same problem, but since it's simpler, we'll start with that.
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Age&nbsp;finch&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.age&nbsp;cell
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;finchEq&nbsp;$&nbsp;samaritan&nbsp;{&nbsp;Galapagos.finchRoundsLeft&nbsp;=&nbsp;3&nbsp;}
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;cellFinchEq&nbsp;actual&nbsp;@?=&nbsp;Just&nbsp;expected</pre>
    </p>
    <p>
        As you read on, you'll see what makes those tests awkward, but in short, they only compare the <code>Finch</code> part of a cell, rather than comparing entire cells. The reason is that full comparisons make the tests more complicated, and less readable.
    </p>
    <h3 id="758686058a8247d79d1972203ac1e8de">
        Replacing Pair with both <a href="#758686058a8247d79d1972203ac1e8de">#</a>
    </h3>
    <p>
        The problem is one that I rarely run into, because, as I outlined in the previous article (and many times before), if a test is difficult to write, I usually consider a simpler design. Because of <a href="https://www.haskell.org/">Haskell</a>'s awkward copy-and-update syntax, I tend to avoid nested record types. (This also applies to <a href="https://fsharp.org/">F#</a>.) Even so, it helps to know that when you run into nested records, lenses may be a proper response.
    </p>
    <p>
        Since I prefer to avoid nested data types, I don't use lenses much, but when I have to, I tend to use the <a href="https://hackage.haskell.org/package/lens">lens</a> package, only because I'm of the impression that it's comprehensive and current.
    </p>
    <p>
        Even so, I only rarely use it, so whenever I decide to pull it in, I need to get reacquainted with it. While I was spelunking the documentation, I came across the <a href="https://hackage-content.haskell.org/package/lens/docs/Control-Lens-Combinators.html#v:both">both</a> function, and realized that it solves essentially the same problem as <code>Pair</code> from the previous article. So, to get an easy start, I decided to replace <code>Pair</code> with <code>both</code>, before proceeding with my actual pursuit.
    </p>
    <p>
        The <code>"Groom two finches"</code> test then looked like this:
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Groom&nbsp;two&nbsp;finches&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell1&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell2&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;cheater)&nbsp;(mkStdGen&nbsp;1)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.groom&nbsp;Galapagos.defaultParams&nbsp;(cell1,&nbsp;cell2)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;Just&nbsp;$&nbsp;finchEq&nbsp;$&nbsp;samaritan&nbsp;{&nbsp;Galapagos.finchHP&nbsp;=&nbsp;16&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;Just&nbsp;$&nbsp;finchEq&nbsp;$&nbsp;cheater&nbsp;{&nbsp;Galapagos.finchHP&nbsp;=&nbsp;13&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;(actual&nbsp;&amp;&nbsp;both&nbsp;%~&nbsp;cellFinchEq)&nbsp;@?=&nbsp;expected</pre>
    </p>
    <p>
        Notice that <code>actual&nbsp;&amp;&nbsp;both&nbsp;%~&nbsp;cellFinchEq</code> replaces <code>cellFinchEq&nbsp;&lt;$&gt;&nbsp;Pair&nbsp;actual</code>. In isolation, this is hardly more readable, but on the other hand, I believe that people often mistake unfamiliarity with things being hard to understand. If I imagine that all developers working with this code base are familiar with the lens library, <code>actual&nbsp;&amp;&nbsp;both&nbsp;%~&nbsp;cellFinchEq</code> may be perfectly legible.
    </p>
    <h3 id="936f0c369c614a52a3934904707b6476">
        Strengthening assertions the hard way <a href="#936f0c369c614a52a3934904707b6476">#</a>
    </h3>
    <p>
        Consider the <code>"Age finch"</code> test. The <code>samaritan</code> <code>Finch</code> value has <code>finchRoundsLeft = 4</code>. After each round of the <a href="https://en.wikipedia.org/wiki/Cellular_automaton">cellular automaton</a>, the <code>age</code> function decreases the value by one.
    </p>
    <p>
        If I wanted to make that explicit, and also compare the actual <code>CellState</code> to the expected <code>CellState</code>, I could do it with standard Haskell language features, but the test starts to become awkward.
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Age&nbsp;finch&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.age&nbsp;cell
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;cellStateEq&nbsp;$&nbsp;cell
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;Galapagos.cellFinch&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(\f&nbsp;-&gt;&nbsp;f&nbsp;{&nbsp;Galapagos.finchRoundsLeft&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Galapagos.finchRoundsLeft&nbsp;f&nbsp;-&nbsp;1&nbsp;})&nbsp;&lt;$&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Galapagos.cellFinch&nbsp;cell
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;cellStateEq&nbsp;actual&nbsp;@?=&nbsp;expected</pre>
    </p>
    <p>
        This is clunky for a number of reasons: The <code>Galapagos.cellFinch</code> field returns the finch found in that cell, but since the cell may also be empty, the return value is a <code>Maybe Finch</code>. This means that any modification must be done with a projection; either <code>fmap</code> or, as shown here, <code>&lt;$&gt;</code>. Inside the lambda expression, I need to query <code>Galapagos.finchRoundsLeft</code> to get the current value, and then use copy-and-update syntax to bind the new value to <code>Galapagos.finchRoundsLeft</code>. And then this entire expression must be bound to <code>Galapagos.cellFinch</code> in order to update <code>cell</code>.
    </p>
    <p>
        To summarize, both <code>Galapagos.finchRoundsLeft</code> and <code>Galapagos.cellFinch</code> has to appear twice.
    </p>
    <p>
        The other test, <code>"Groom two finches"</code>, involves two cells, so that's just double the cumber.
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Groom&nbsp;two&nbsp;finches&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell1&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell2&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;cheater)&nbsp;(mkStdGen&nbsp;1)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.groom&nbsp;Galapagos.defaultParams&nbsp;(cell1,&nbsp;cell2)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;cell1&nbsp;{&nbsp;Galapagos.cellFinch&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(\f&nbsp;-&gt;&nbsp;f&nbsp;{&nbsp;Galapagos.finchHP&nbsp;=&nbsp;16&nbsp;})&nbsp;&lt;$&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Galapagos.cellFinch&nbsp;cell1&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;cell2&nbsp;{&nbsp;Galapagos.cellFinch&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(\f&nbsp;-&gt;&nbsp;f&nbsp;{&nbsp;Galapagos.finchHP&nbsp;=&nbsp;13&nbsp;})&nbsp;&lt;$&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Galapagos.cellFinch&nbsp;cell2&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;(actual&nbsp;&amp;&nbsp;both&nbsp;%~&nbsp;cellStateEq)&nbsp;@?=&nbsp;(expected&nbsp;&amp;&nbsp;both&nbsp;%~&nbsp;cellStateEq)</pre>
    </p>
    <p>
        This demonstrates why I originally took a shortcut. Even without trying it out in practice, I have enough experience with Haskell (and F#) to predict exactly this situation. Fortunately, there's a way out.
    </p>
    <h3 id="b19743aec3304f2eb007fa25e823d142">
        Setting an inner value <a href="#b19743aec3304f2eb007fa25e823d142">#</a>
    </h3>
    <p>
        Not being well-versed in the lens library, I found it prudent to proceed in small steps. My next move was to update <code>finchRoundsLeft</code> in the above <code>"Age finch"</code> test. While I quickly found the <a href="https://hackage-content.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-45--126-">-~</a> operator, I then had to figure out how to define an <code>ASetter</code> for <code>finchRoundsLeft</code>.
    </p>
    <p>
        All documentation points to making use of <a href="https://hackage-content.haskell.org/package/lens/docs/Control-Lens-Combinators.html#v:makeLenses">makeLenses</a>, but that comes with requirements that I couldn't fulfil. I couldn't change the existing definition of <code>Finch</code>, so I couldn't name the fields according to the required naming convention. I tried to use <a href="https://hackage-content.haskell.org/package/lens/docs/Control-Lens-Combinators.html#v:makeLensesWith">makeLensesWith</a> from another module, but I couldn't make it work. It's possible that you can make it work if you know what you are doing, but I didn't.
    </p>
    <p>
        In the end, I just wrote an explicit setter function for <code>finchRoundsLeft</code>:
    </p>
    <p>
        <pre><span style="color:#2b91af;">setRoundsLeft</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Functor</span>&nbsp;f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;(<span style="color:blue;">Galapagos</span>.<span style="color:blue;">Rounds</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;f&nbsp;<span style="color:blue;">Galapagos</span>.<span style="color:blue;">Rounds</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Galapagos</span>.<span style="color:blue;">Finch</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;f&nbsp;<span style="color:blue;">Galapagos</span>.<span style="color:blue;">Finch</span>
setRoundsLeft&nbsp;f&nbsp;x&nbsp;=
&nbsp;&nbsp;(\r&nbsp;-&gt;&nbsp;x&nbsp;{&nbsp;Galapagos.finchRoundsLeft&nbsp;=&nbsp;r&nbsp;})&nbsp;&lt;$&gt;
&nbsp;&nbsp;f&nbsp;(Galapagos.finchRoundsLeft&nbsp;x)</pre>
    </p>
    <p>
        This enabled me to rewrite the <code>"Age finch"</code> test to this:
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Age&nbsp;finch&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.age&nbsp;cell
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;cellStateEq&nbsp;$&nbsp;cell
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;Galapagos.cellFinch&nbsp;=&nbsp;(setRoundsLeft&nbsp;-~&nbsp;1)&nbsp;&lt;$&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Galapagos.cellFinch&nbsp;cell
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;cellStateEq&nbsp;actual&nbsp;@?=&nbsp;expected</pre>
    </p>
    <p>
        Granted, it's not much of an improvement, but it gave me an idea of how to proceed.
    </p>
    <h3 id="c4fb295fe4e14813bcfe2f30f8d71465">
        Composing setters <a href="#c4fb295fe4e14813bcfe2f30f8d71465">#</a>
    </h3>
    <p>
        Not only did I need a setter for <code>finchRoundsLeft</code>, I also needed one for <code>cellFinch</code>. Again, not being able to identify a way to do this in an easier way, I wrote another explicit setter for that purpose:
    </p>
    <p>
        <pre><span style="color:#2b91af;">setFinch</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Functor</span>&nbsp;f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;(<span style="color:#2b91af;">Maybe</span>&nbsp;<span style="color:blue;">Galapagos</span>.<span style="color:blue;">Finch</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;f&nbsp;(<span style="color:#2b91af;">Maybe</span>&nbsp;<span style="color:blue;">Galapagos</span>.<span style="color:blue;">Finch</span>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Galapagos</span>.<span style="color:blue;">CellState</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;f&nbsp;<span style="color:blue;">Galapagos</span>.<span style="color:blue;">CellState</span>
setFinch&nbsp;f&nbsp;x&nbsp;=
&nbsp;&nbsp;(\finch&nbsp;-&gt;&nbsp;x&nbsp;{&nbsp;Galapagos.cellFinch&nbsp;=&nbsp;finch&nbsp;})&nbsp;&lt;$&gt;&nbsp;f&nbsp;(Galapagos.cellFinch&nbsp;x)</pre>
    </p>
    <p>
        Armed with that I could finally rewrite <code>"Age finch"</code> to something nice.
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Age&nbsp;finch&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.age&nbsp;cell
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cellStateEq&nbsp;$&nbsp;cell&nbsp;&amp;&nbsp;setFinch&nbsp;.&nbsp;_Just&nbsp;.&nbsp;setRoundsLeft&nbsp;-~&nbsp;1
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;cellStateEq&nbsp;actual&nbsp;@?=&nbsp;expected</pre>
    </p>
    <p>
        Likewise, with the addition of <code>setHP</code>, I could also rewrite <code>"Groom two finches"</code>:
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Groom&nbsp;two&nbsp;finches&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell1&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell2&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;cheater)&nbsp;(mkStdGen&nbsp;1)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.groom&nbsp;Galapagos.defaultParams&nbsp;(cell1,&nbsp;cell2)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;cell1&nbsp;&amp;&nbsp;setFinch&nbsp;.&nbsp;_Just&nbsp;.&nbsp;setHP&nbsp;.~&nbsp;16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;cell2&nbsp;&amp;&nbsp;setFinch&nbsp;.&nbsp;_Just&nbsp;.&nbsp;setHP&nbsp;.~&nbsp;13
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;(actual&nbsp;&amp;&nbsp;both&nbsp;%~&nbsp;cellStateEq)&nbsp;@?=&nbsp;(expected&nbsp;&amp;&nbsp;both&nbsp;%~&nbsp;cellStateEq)</pre>
    </p>
    <p>
        That's not too bad, if I may say so.
    </p>
    <h3 id="db1e27a7e16f421297bb6103167a19cd">
        Combinator golf <a href="#db1e27a7e16f421297bb6103167a19cd">#</a>
    </h3>
    <p>
        Sometimes I get carried away. It's really nothing to worry about, but only to play with options in order to learn, I decided to address the duplication in the above assertion. Notice that is goes <code>&amp;&nbsp;both&nbsp;%~&nbsp;cellStateEq</code> twice. That's not something that should bother me, and in any case, if you apply the <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">rule of three</a>, it's too early to refactor.
    </p>
    <p>
        Even so, I wanted that little bit of extra exercise, so I pulled in <a href="https://hackage.haskell.org/package/base/docs/Data-Function.html#v:on">on</a> and rewrote the assertion. All the other code is identical to the previous listing.
    </p>
    <p>
        <pre>testCase&nbsp;<span style="color:#a31515;">&quot;Groom&nbsp;two&nbsp;finches&quot;</span>&nbsp;$
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cell1&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;samaritan)&nbsp;(mkStdGen&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell2&nbsp;=&nbsp;Galapagos.CellState&nbsp;(Just&nbsp;cheater)&nbsp;(mkStdGen&nbsp;1)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;=&nbsp;Galapagos.groom&nbsp;Galapagos.defaultParams&nbsp;(cell1,&nbsp;cell2)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;cell1&nbsp;&amp;&nbsp;setFinch&nbsp;.&nbsp;_Just&nbsp;.&nbsp;setHP&nbsp;.~&nbsp;16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;cell2&nbsp;&amp;&nbsp;setFinch&nbsp;.&nbsp;_Just&nbsp;.&nbsp;setHP&nbsp;.~&nbsp;13
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;(<span style="color:#2b91af;">(@?=)</span>&nbsp;`on`&nbsp;(both&nbsp;%~&nbsp;cellStateEq))&nbsp;actual&nbsp;expected</pre>
    </p>
    <p>
        To be clear, I do, myself, consider this last edit frivolous. I wouldn't recommend it, and wouldn't use it in a code base shared with other people, but I still find it enjoyable.
    </p>
    <h3 id="db2a8bac20c74e6da40a00c0f94cd13e">
        Conclusion <a href="#db2a8bac20c74e6da40a00c0f94cd13e">#</a>
    </h3>
    <p>
        Nested data structures present problems in functional programming, particularly in Haskell, where the record syntax leaves something to be desired. Updating a value nested inside another value is, with plain vanilla code, awkward.
    </p>
    <p>
        This kind of situation is the main use case for lenses. In this article, you saw how I refactored awkward tests with the <em>lens</em> package.
    </p>
</div>