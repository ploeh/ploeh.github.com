---
layout: post
tags: [Services, Software Design]
date: 2011-05-31 15:27:11
title: "At the Boundaries, Applications are Not Object-Oriented"
---
{% include JB/setup %}

<div id="post">
	<p>My recent series of blog posts about <a href="http://blog.ploeh.dk/2011/05/24/PokayokeDesignFromSmellToFragrance.aspx">Poka-yoke Design</a> generated a few responses (I would have been disappointed had this not been the case). Quite a few of these reactions relate to various serialization or translation technologies usually employed at application boundaries: Serialization, XML (de)hydration, UI validation, etc. Note that such translation happens not only at the perimeter of the application, but also at the persistence layer. ORMs are also a translation mechanism.</p> <p>Common to most of the comments is that lots of serialization technologies require the presence of a default constructor. As an example, the <a href="http://msdn.microsoft.com/en-us/library/182eeyhh.aspx">XmlSerializer</a> requires a default constructor and public writable properties. Most ORMs I've investigated seem to have the same kind of requirements. Windows Forms and WPF Controls (UI is also an application boundary) also must have default constructors. Doesn't that break encapsulation? Yes and no.</p> <p><strong>Objects at the Boundary</strong></p> <p>It certainly <em>would</em> break encapsulation if you were to expose your (domain) <em>objects</em> directly at the boundary. Consider a simple XML document like this one:</p> <div style="font-family: ; background: white; color: "><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&lt;</font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#a31515">name</font></span></font><span style="color: "><font style="font-size: 10pt" color="#0000ff">&gt;</font></span></pre><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&nbsp; &lt;</font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#a31515">firstName</font></span><span style="color: "><font color="#0000ff">&gt;</font></span>Mark<span style="color: "><font color="#0000ff">&lt;/</font></span><span style="color: "><font color="#a31515">firstName</font></span></font><span style="color: "><font style="font-size: 10pt" color="#0000ff">&gt;</font></span></pre><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&nbsp; &lt;</font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#a31515">lastName</font></span><span style="color: "><font color="#0000ff">&gt;</font></span>Seemann<span style="color: "><font color="#0000ff">&lt;/</font></span><span style="color: "><font color="#a31515">lastName</font></span></font><span style="color: "><font style="font-size: 10pt" color="#0000ff">&gt;</font></span></pre><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&lt;/</font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#a31515">name</font></span></font><span style="color: "><font style="font-size: 10pt" color="#0000ff">&gt;</font></span></pre></div>
<p>Whether or not we have formal contract (XSD) or not, we might stipulate that both the firstName and lastName elements are <em>required</em>. However, despite such a contract, I can easily create a document that breaks it:</p>
<div style="font-family: ; background: white; color: "><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&lt;</font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#a31515">name</font></span></font><span style="color: "><font style="font-size: 10pt" color="#0000ff">&gt;</font></span></pre><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&nbsp; &lt;</font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#a31515">firstName</font></span><span style="color: "><font color="#0000ff">&gt;</font></span>Mark<span style="color: "><font color="#0000ff">&lt;/</font></span><span style="color: "><font color="#a31515">firstName</font></span></font><span style="color: "><font style="font-size: 10pt" color="#0000ff">&gt;</font></span></pre><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&lt;/</font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#a31515">name</font></span></font><span style="color: "><font style="font-size: 10pt" color="#0000ff">&gt;</font></span></pre></div>
<p>We can't <em>enforce</em> the contract as there's no compilation step involved. We can <em>validate</em> input (and output), but that's a different matter. Exactly because there's no enforcement it's very easy to create malformed input. The same argument can be made for UI input forms and any sort of serialized byte sequence. This is why we must treat all input as suspect.</p>
<p>This isn't a new observation at all. In <a href="http://www.martinfowler.com/books.html#eaa">Patterns of Enterprise Application Architecture</a>, <a href="http://www.martinfowler.com">Martin Fowler</a> described this as a <a href="http://martinfowler.com/eaaCatalog/dataTransferObject.html">Data Transfer Object</a> (DTO). However, despite the name we should realize that DTOs are not really objects at all. This is nothing new either. Back in 2004 Don Box formulated the <a href="http://msdn.microsoft.com/en-us/magazine/cc164026.aspx">Four Tenets of Service Orientation</a>. (Yes, I know that they are not in vogue any more and that people <a href="http://www.pluralsight-training.net/community/blogs/dbox/archive/2007/08/15/48232.aspx">wanted to retire them</a>, but some of them still make tons of sense.) Particularly the third tenet is germane to this particular discussion:</p>
<blockquote>
<p>Services share schema and contract, not class.</p></blockquote>
<p>Yes, and that means they are <em>not objects</em>. A DTO is a <em>representation</em> of such a piece of data <em>mapped into</em> an object-oriented language. That still doesn't make them objects in the sense of encapsulation. It would be impossible. Since all input is suspect, we can hardly enforce any invariants at all.</p>
<p>Often, as <a href="http://blogs.teamb.com/craigstuntz/">Craig Stuntz</a> points out in <a href="http://blog.ploeh.dk/2011/05/27/DesignSmellRedundantRequiredAttribute.aspx">a comment to one of my previous posts</a>, even if the input is invalid, we want to capture what we <em>did</em> receive in order to present a proper error message (this argument also applies on machine-to-machine boundaries). This means that any DTO must have <em>very</em> weak invariants (if any at all).</p>
<blockquote>
<p>DTOs don't break encapsulation because they aren't objects at all.</p></blockquote>
<p>Don't be fooled by your tooling. The .NET framework very, very much wants you to treat DTOs as objects. Code generation ensues.</p>
<p>However, the strong typing provided by such auto-generated classes gives a false sense of security. You may think that you get <a href="http://blog.ploeh.dk/2011/04/29/FeedbackMechanismsAndTradeoffs.aspx">rapid feedback from the compiler</a>, but there are many possible ways you can get run-time errors (most notably when you forget to update the auto-generated code based on new schema versions).</p>
<p>An even more problematic result of representing input and output as objects is that it tricks lots of developers into dealing with them as though they represent the real object model. The result is invariably an <a href="http://www.martinfowler.com/bliki/AnemicDomainModel.html">anemic domain model</a>.</p>
<p>More and more, this line of reasoning is leading me towards the conclusion that the DTO mental model that we have gotten used to over the last ten years is a dead end.</p>
<p><strong>What Should Happen at the Boundary</strong></p>
<p>Given that we write write object-oriented code and that data at the boundary is anything but object-oriented, how do we deal with it?</p>
<p>One option is to stick with what we already have. To bridge the gap we must then develop <em>translation layers</em> that can translate the DTOs to properly encapsulated domain objects. This is the route I take with the samples in <a href="http://affiliate.manning.com/idevaffiliate.php?id=1150_236">my book</a>. However, this is a solution that more and more I'm beginning to think may not be the best. It has issues with maintainability. (Incidentally, that's the problem with writing a book: at the time you're done, you know so much more than you did when you started out… Not that I'm denouncing the book  -  it's just not perfect…)</p>
<p>Another option is to stop treating data as objects and start treating it as the <em>structured data</em> that it really is. It would be really nice if our programming language had a separate concept of <em>structured data</em>… Interestingly, while C# has nothing of the kind, F# has tons of ways to model data structures without behavior. Perhaps that's a more honest approach to dealing with data… I will need to experiment more with this…</p>
<p>A third option is to look towards dynamic types. In his article <a href="http://msdn.microsoft.com/en-us/magazine/ff796227.aspx">Cutting Edge: Expando Objects in C# 4.0</a>, Dino Esposito outlines a dynamic approach towards consuming structured data that shortcuts auto-generated code and provides a lightweight API to structured data. This also looks like a promising approach… It doesn't provide compile-time feedback, but that's only a false sense of security anyway. We must resort to <a href="http://blog.ploeh.dk/2011/04/29/FeedbackMechanismsAndTradeoffs.aspx">unit tests to get rapid feedback</a>, but we're all using TDD already, right?</p>
<p>In summary, my entire series about encapsulation relates to <em>object-oriented programming</em>. Although there are lots of technologies available to represent boundary data as ‘objects', they are false objects. Even if we use an object-oriented language at the boundary, the code has nothing to do with object orientation. Thus, the Poka-yoke Design rules don't apply there.</p>
<p>Now go back and reread this post, but replace ‘DTO' with ‘Entity' (or whatever your ORM calls its representation of a relational table row) and you should begin to see the contours of why ORMs are problematic.</p>
</div>
	
<hr>
<div id="comments">
<h2 id="comments-header">
	Comments
</h2>
	<div class="comment">
	<div class="comment-author"><a href="http://marcgravell.blogspot.com">Marc Gravell</a></div>
	<div class="comment-content">Absolutely. I spend a lot of time in this space, an while I enjoy using (and maintaining) tools to make this transition simple, whenever there isthe first hint of a problem I always advise &quot;add a dedicated DTO&quot;. A similar question (using interfaces in WCF messages) came up on stackoverflow last week. But ultimately, any boundary talks &quot;data&quot;, not behaviour. It also emphasises why BinaryFormatter (implementation-aware) sucks so much for ***any*** kind of data exchange.</div>
	<div class="comment-date">2011-05-31 16:53</div>
</div><div class="comment">
	<div class="comment-author">Phil Sandler</div>
	<div class="comment-content">Arg, had a longer comment but it got eaten when I clicked Save Comment.<br>
<br>
Anyway the gist of it: great post, I commpletely agree that data objects aren't domain objects, and thinking of them as structured data is very liberating.  Using Entities/DTOs/data objects as a composible part of a domain object is a nice way to create that separation which still allows you to (potentially directly) use ORM entities while avoiding having an anemic domain model.  So, for example, CustomerDomain would/could contain a CustomerEntity, instead of trying to add behavior to CustomerEntity (which might be a generated class).</div>
	<div class="comment-date">2011-05-31 18:37</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">Phil, when you write 'Entity' I immediately think about the definition provided in &quot;Domain-Driven Design&quot;. Those Entities are definitely Domain Objects which should have lots of behavior, but I'm getting the feeling that you're thinking about something else?</div>
	<div class="comment-date">2011-05-31 20:22</div>
</div><div class="comment">
	<div class="comment-author">Phil Sandler</div>
	<div class="comment-content">Hey Mark,<br>
<br>
Yep, I meant &quot;entity&quot; more in the sense of how it is defined in some of the popular ORMs, like LLBLGen and Entity Framework.  Essentially, an instance that corresponds (more or less) directly to a row in a table or view.</div>
	<div class="comment-date">2011-06-01 00:09</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">Yes, we might compose real domain objects from DTOs, but I'm not sure that is the best solution. When we map non-object-oriented structures to objects, they tend to drag along a lot of baggage which hurts OO modeling.<br>
<br>
For instance, generating DTOs from a database schema provides an entire static structure (relationships, etc.) that tend to constrain us when we subsequently attempt to define an object model. I rather prefer being able to work unconstrained and then subsequently figure out how to persist it.</div>
	<div class="comment-date">2011-06-01 07:44</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://code.dortikum.net">Boyan Mihaylov</a></div>
	<div class="comment-content">I like this article. As far as I undertand you for every entity you have (a domain object) you need a separate DTO for different representations (XML, SQL, etc.). So you need a third object which translates every DTO into a specific entity. Am I correct? If so, isn't that process too complex?</div>
	<div class="comment-date">2011-06-01 10:29</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">Yes, that's what I've been doing for the last couple of years, but the downside is the maintenance overhead. That's why I, in the last part of the post, discuss alternatives. Currently I think that using dynamic types looks most promising.<br>
<br>
Keep in mind that in most cases, a DTO is not an end-goal in itself. Rather, the end-goal is often the wire-representation of the DTO (XML, JSON, etc.). Wouldn't it be better if we could just skip the DTO altogether and use a bit of convention-based (and testable) dynamic code to make that translation directly?</div>
	<div class="comment-date">2011-06-01 10:41</div>
</div><div class="comment">
	<div class="comment-author">Florian H&#246;tzinger</div>
	<div class="comment-content">I guess in WCF service scenarios there is really no other way than to create a DTO layer and compose our domain objects from those DTOs when passing them from/to the client. Since I'm doing a lot of Silverlight development at the moment, this came up quite early.</div>
	<div class="comment-date">2011-06-01 11:13</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://code.dortikum.net">Boyan Mihaylov</a></div>
	<div class="comment-content">@Mark: Yes, that would be quite a better way. Here comes the great article, you've mentioned, about the ExpandoObject and the dynamic way of dealing with json, xml and other representations of data. However, in case of SQL at this moment you still need some DTOs I guess. Maybe if we have some wrapper over the traditional IDataReader or some other mechanism to access the data, it will be possible again.</div>
	<div class="comment-date">2011-06-01 12:13</div>
</div><div class="comment">
	<div class="comment-author">Phil Sandler</div>
	<div class="comment-content">Hey Mark,<br>
<br>
It's a difficult problem to solve perfectly--every solution had downsides.  I have gone down the road of mapping DTOs (or data entities) via a translation layer and that can be painful as well.  As you said, the tradeoff of using data objects as a composable part of the Domain Object is that you can't model your domain with complete freedom (which DDD purists would likely see as non-negotiable).  The upside is that you have the potential for less maintenance.<br>
<br>
</div>
	<div class="comment-date">2011-06-01 16:34</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">Florian, in WCF it <i>is</i> possible to drop down to the message-level and write directly to the message. Even so, I'm not sure I'd go that route, but it's good to know that the option exists.</div>
	<div class="comment-date">2011-06-01 20:43</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">Boyan, I was specifically thinking about dropping down to IDataReader. For one example, please refer to Tomas Petricek's article <a href="http://tomasp.net/blog/dynamic-sql.aspx">Dynamic in F#: Reading data from SQL database</a>.</div>
	<div class="comment-date">2011-06-01 20:46</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://stratasphere.blogspot.com/">hotsleeper</a></div>
	<div class="comment-content">Hi Mark, <br>
<br>
There is lots to argue about in this article (nothing &quot;wrong&quot;, just semantics).  The main point I would like to pick up on is about your point &quot;What should happen at domain boundaries&quot;. <br>
<br>
I would contest that rather than &quot;translation&quot; layers, its semantically better to think of it as an &quot;interpretation object&quot;.  When an app accepts input, there are very few assumptions that should be automatically attached to the unit of input. One of the fundamental ones and often the easiest to break is the assumption that the input is in any way valid, useful or complete. <br>
<br>
The semantic concept(abstraction) that is wrapped around the unit of input (the object that encapsulates the input data) need to have a rich interface that can convey abstractions such as &quot;Cannot interpret this input&quot;, &quot;Can partially interpret the input but it contains some rubbish&quot;, &quot;Input contains SQL injection attack&quot;, &quot;Input is poorly formed and has a missing .DTD file&quot; etc.  <br>
<br>
My argument is that the semantic concept of &quot;translation&quot; while obviously closely related to &quot;interpretation&quot; is semantically a &quot;transformation process&quot;. A-&gt;B kind of idea, while &quot;interpretation&quot;, at least in my head, is not so deterministic and seeks to extract domain abstractions from the input that are then exposed to the application as high level abstractions rather than low level &quot;translated data/safe data/sanitized data&quot;. <br>
<br>
Thanks, <br>
<br>
hotsleeper<br>
</div>
	<div class="comment-date">2011-06-02 04:37</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">Makes sense. I mainly used the term 'translation layer' as I assumed that most people would then immediately know what I meant :)</div>
	<div class="comment-date">2011-06-02 08:51</div>
</div><div class="comment">
	<div class="comment-author">Arved Sandstrom</div>
	<div class="comment-content">What's the processing error that is currently preventing comments? I can't get a usefully long one successfully submitted.</div>
	<div class="comment-date">2011-06-02 11:50</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">Sorry about that. This blog is running on <a href="http://dasblog.info">dasBlog</a> which was last updated two years ago. Migrating the blog to a better engine is on my to-do list, but it'll be a couple of months at least before I get there.</div>
	<div class="comment-date">2011-06-02 12:07</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blogs.teamb.com/craigstuntz">Craig Stuntz</a></div>
	<div class="comment-content">FWIW, the maintenance cost is effectively zero if the DTO types are codegened. <br>
<br>
Dynamic types are also an option -- anyone who has used Rails/ActiveRecord is familiar with their upsides and downsides. In short, maintaining them is free, but using them costs more. <br>
<br>
My preferred approach (for now) is to use EF entities as boundary objects for the DB. They cost almost nothing to maintain -- a couple of mouse clicks when we change DB schemata -- since we use &quot;Database First&quot; modeling for internal reasons. <br>
<br>
You only get into encapsulation trouble with this if you try to use the EF entities as business objects -- something many people do. My $0.02 is that it's usually wrong to put any kind of behavior on an EF entity.</div>
	<div class="comment-date">2011-06-04 17:51</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">I agree on the rule of never putting any behavior on an EF entity (although, still, I used to put a translation method on most of them: ToDomainObject(), but still...).<br>
<br>
My personal experience with EF was that even with code generation, it was far from frictionless, but YMMV...</div>
	<div class="comment-date">2011-06-04 23:13</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://www.mellekoning.nl">Melle Koning</a></div>
	<div class="comment-content">Hi Mark,<br>
<br>
Depends! If we're building a framework that is used by others then there is a big difference between the applications boundary to the &quot;outside world&quot; (DTO's) and persistence. <br>
<br>
A quote taken from <A>NHDay - Loosely Coupled Complexity - CQRS</A> (see minute 2:10) What is wrong with a design with DTO's? &quot;Nothing.&quot; End of presentation. But then continues into CQRS :)<br>
<br>
Especially the translation-layer when requests come into our application, and we try to rebuild the OO model to help save new objects with an ORM can be cumbersome. <br>
<br>
The point is that the database follows from the domain design, not other way round like EF or ORM class generators make you try to believe.<br>
</div>
	<div class="comment-date">2011-06-05 13:18</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">The point being made here is that despite the name, DTOs aren't 'objects'. It's certainly possible to create a complex application entirely with DTOs - it's just not object-oriented.<br>
<br>
There may be nothing wrong with that, but if you decide that you need <em>object-orientation</em> to solve a business problem, you <em>must</em> transform DTOs into proper objects, because it's impossible to make OOD with DTOs.</div>
	<div class="comment-date">2011-06-05 13:45</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://zaemis.blogspot.com">Timothy</a></div>
	<div class="comment-content">The &quot;everything is an ________&quot; mantra gets us in trouble every time, whether it's strings in TCL, objects in Ruby, etc. Objects are a programming construct in practice, and the problem is we're trying to treat data as objects... which it really isn't. I echo your sentiments to &quot;stop treating data as objects and start treating it as the structured data that it really is.&quot; </div>
	<div class="comment-date">2011-06-05 20:59</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://geekswithblogs.net/theArchitectsNapkin">Ralf Westphal</a></div>
	<div class="comment-content">Great article!<br>
<br>
But why not think this further? What&#180;s a boundary? Is a boundary where data is exchanged between processes? Or processes on different machines? Processes implemented using different platforms? Or is a boundary where data moves between .NET AppDomains? Or between threads?<br>
<br>
The past year I&#180;ve felt great relieve by very strictly appyling this rule: data that moves around is, well, just data.<br>
<br>
That does not mean I&#180;m back to procedural programming. I appreciate the benefits of object oriented languages.<br>
<br>
But just because I can combine data and functions into one &quot;thing&quot;, I should not always do it.<br>
<br>
If data is state of a behavior, then data+function makes sense.<br>
<br>
But if data is pushed around between &quot;behaviroal objects&quot; then data should be just data (maybe spiced with some convenience functions).<br>
<br>
So what I&#180;ve come to doing is &quot;data flow design&quot; or &quot;behaviroal design&quot;. And that plays very nicely with async programming and distributing code across processes.</div>
	<div class="comment-date">2011-06-08 16:14</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">Yes, we can take it further, but I don't believe that one approach necessarily rules out the other. However, it depends on <em>how</em> you decide to pass around structured data.<br>
<br>
If you do it in a request/response style (even mapped into internal code), I'd say that you'd be doing procedural programming.<br>
<br>
However, if you do it as Commands, passing structured data to void methods, you'd basically be heading in the direction of <em>Pipes and Filters architecture</em>. <a href="http://blog.ploeh.dk/2011/03/22/CommandsAreComposable.aspx">That's actually a very good place to be</a>.</div>
	<div class="comment-date">2011-06-09 11:47</div>
</div>
</div>