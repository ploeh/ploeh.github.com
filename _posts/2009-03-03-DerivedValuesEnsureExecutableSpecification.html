---
layout: post
tags: [Productivity, Unit Testing]
date: 2009-03-03 20:01:29 UTC
title: "Derived Values Ensure Executable Specification"
comments: true
---
{% include JB/setup %}

<div id="post">
	<p>In this <a href="http://blog.ploeh.dk/2009/01/28/ZeroFrictionTDD.aspx">Zero-Friction TDD</a> post, I'd like to take a detour around the concept of tests as <a href="http://xunitpatterns.com/Goals%20of%20Test%20Automation.html#Executable%20Specification">Executable Specification</a>.</p> <p>An important aspect of test maintainability is readability. Tests should act both as Executable Specification as well as <a href="http://xunitpatterns.com/Goals%20of%20Test%20Automation.html#Tests%20as%20Documentation">documentation</a>, which puts a lot of responsibility on the test.</p> <p>One facet of test readability is to make the relationship between the <a href="http://xunitpatterns.com/test%20fixture%20-%20xUnit.html">Fixture</a>, the <a href="http://xunitpatterns.com/SUT.html">SUT</a> and the verification as easy to understand as possible. In other words, it should be clear to the <a href="http://xunitpatterns.com/test%20reader.html">Test Reader</a> what is being asserted, and why.</p> <p>Consider a test like this one:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;}??\fs20 [\cf3 TestMethod\cf0 ]\par ??\cf4 public\cf0  \cf4 void\cf0  InvertWillReverseText_Na\u239 ?ve()\par ??\{\par ??    \cf5 // Fixture setup\par ??\cf0     \cf3 MyClass\cf0  sut = \cf4 new\cf0  \cf3 MyClass\cf0 ();\par ??    \cf5 // Exercise system\par ??\cf0     \cf4 string\cf0  result = sut.Invert(\cf6 "ploeh"\cf0 );\par ??    \cf5 // Verify outcome\par ??\cf0     \cf3 Assert\cf0 .AreEqual&lt;\cf4 string\cf0 &gt;(\cf6 "heolp"\cf0 , result, \cf6 "DoWork"\cf0 );\par ??    \cf5 // Teardown\par ??\cf0 \}}
--> <div style="font-size: 10pt; background: white; color: black; font-family: courier new"><pre style="margin: 0px">[<span style="color: #2b91af">TestMethod</span>]</pre><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">void</span> InvertWillReverseText_Naïve()</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">MyClass</span> sut = <span style="color: blue">new</span> <span style="color: #2b91af">MyClass</span>();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> result = sut.Invert(<span style="color: #a31515">"ploeh"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Assert</span>.AreEqual&lt;<span style="color: blue">string</span>&gt;(<span style="color: #a31515">"heolp"</span>, result, <span style="color: #a31515">"DoWork"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Teardown</span></pre><pre style="margin: 0px">}</pre></div>
<p>Since this test is so simple, I expect that you can easily figure out that it implies that the Invert method should simply reverse its input argument, but one of the reasons this seems to be evident is because of the proximity of the two strings, as well as the test's name.</p>
<p>In a test of a more complex API, this may not be quite as evident.</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;}??\fs20 [\cf3 TestMethod\cf0 ]\par ??\cf4 public\cf0  \cf4 void\cf0  DoItWillReturnCorrectResult_Na\u239 ?ve()\par ??\{\par ??    \cf5 // Fixture setup\par ??\cf0     \cf3 MyClass\cf0  sut = \cf4 new\cf0  \cf3 MyClass\cf0 ();\par ??    \cf5 // Exercise system\par ??\cf0     \cf4 int\cf0  result = sut.DoIt(\cf6 "ploeh"\cf0 );\par ??    \cf5 // Verify outcome\par ??\cf0     \cf3 Assert\cf0 .AreEqual&lt;\cf4 int\cf0 &gt;(42, result, \cf6 "DoIt"\cf0 );\par ??    \cf5 // Teardown\par ??\cf0 \}}
-->
<div style="font-size: 10pt; background: white; color: black; font-family: courier new"><pre style="margin: 0px">[<span style="color: #2b91af">TestMethod</span>]</pre><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">void</span> DoItWillReturnCorrectResult_Naïve()</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">MyClass</span> sut = <span style="color: blue">new</span> <span style="color: #2b91af">MyClass</span>();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">int</span> result = sut.DoIt(<span style="color: #a31515">"ploeh"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Assert</span>.AreEqual&lt;<span style="color: blue">int</span>&gt;(42, result, <span style="color: #a31515">"DoIt"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Teardown</span></pre><pre style="margin: 0px">}</pre></div>
<p>In this test, there's no apparent relationship between the input (<em>ploeh</em>) and the output (<em>42</em>). Whatever the algorithm is behind the DoIt method, it's completely opaque to the Test Reader, and the test fails in its role as specification and documentation.</p>
<p>Returning to the first example, it would be better if the relationship between input and output was explicitly described:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;}??\fs20 [\cf3 TestMethod\cf0 ]\par ??\cf4 public\cf0  \cf4 void\cf0  InvertWillReverseText()\par ??\{\par ??    \cf5 // Fixture setup\par ??\cf0     \cf4 string\cf0  anonymousText = \cf6 "ploeh"\cf0 ;\par ??    \cf4 string\cf0  expectedResult =\par ??        \cf4 new\cf0  \cf4 string\cf0 (anonymousText.Reverse().ToArray());\par ??    \cf3 MyClass\cf0  sut = \cf4 new\cf0  \cf3 MyClass\cf0 ();\par ??    \cf5 // Exercise system\par ??\cf0     \cf4 string\cf0  result = sut.Invert(anonymousText);\par ??    \cf5 // Verify outcome\par ??\cf0     \cf3 Assert\cf0 .AreEqual&lt;\cf4 string\cf0 &gt;(expectedResult, result,\par ??        \cf6 "DoWork"\cf0 );\par ??    \cf5 // Teardown\par ??\cf0 \}}
-->
<div style="font-size: 10pt; background: white; color: black; font-family: courier new"><pre style="margin: 0px">[<span style="color: #2b91af">TestMethod</span>]</pre><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">void</span> InvertWillReverseText()</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> anonymousText = <span style="color: #a31515">"ploeh"</span>;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> expectedResult =</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">new</span> <span style="color: blue">string</span>(anonymousText.Reverse().ToArray());</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">MyClass</span> sut = <span style="color: blue">new</span> <span style="color: #2b91af">MyClass</span>();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> result = sut.Invert(anonymousText);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Assert</span>.AreEqual&lt;<span style="color: blue">string</span>&gt;(expectedResult, result,</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #a31515">"DoWork"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Teardown</span></pre><pre style="margin: 0px">}</pre></div>
<p>In this case, the input and expected outcome are clearly related, and we call the expectedResult variable a <a href="http://xunitpatterns.com/Derived%20Value.html">Derived Value</a>, since we explicitly derive the expected result from the input.</p>
<p>Note that I'm not asking you to re-implement the whole algorithm in the test, but only to establish a relationship. One of the main rules of thumb of unit testing is that a test should never contain conditional branches, so there must be at least one test case per path though the SUT.</p>
<p>In the example, the Invert method actually looks like this:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;}??\fs20 \cf1 public\cf0  \cf1 string\cf0  Invert(\cf1 string\cf0  message)\par ??\{\par ??    \cf1 double\cf0  d;\par ??    \cf1 if\cf0  (\cf1 double\cf0 .TryParse(message, \cf1 out\cf0  d))\par ??    \{\par ??        \cf1 return\cf0  (1d / d).ToString();\par ??    \}\par ??\par ??    \cf1 return\cf0  \cf1 new\cf0  \cf1 string\cf0 (message.Reverse().ToArray());\par ??\}}
-->
<div style="font-size: 10pt; background: white; color: black; font-family: courier new"><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">string</span> Invert(<span style="color: blue">string</span> message)</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">double</span> d;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">if</span> (<span style="color: blue">double</span>.TryParse(message, <span style="color: blue">out</span> d))</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; {</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> (1d / d).ToString();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; }</pre><pre style="margin: 0px">&nbsp;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> <span style="color: blue">new</span> <span style="color: blue">string</span>(message.Reverse().ToArray());</pre><pre style="margin: 0px">}</pre></div>
<p>Note that the above test only reproduces that part of the algorithm that corresponds to the <a href="http://xunitpatterns.com/equivalence%20class.html">Equivalence Class</a> defined by the input, whereas the branch that is triggered by a number string can be tested by another test case that doesn't specify string reversion.</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;}??\fs20 [\cf3 TestMethod\cf0 ]\par ??\cf4 public\cf0  \cf4 void\cf0  InvertWillInvertNumber()\par ??\{\par ??    \cf5 // Fixture setup\par ??\cf0     \cf4 double\cf0  anonymousNumber = 10;\par ??    \cf4 string\cf0  numberText = anonymousNumber.ToString();\par ??    \cf4 string\cf0  expectedResult = \par ??        (1d / anonymousNumber).ToString();\par ??    \cf3 MyClass\cf0  sut = \cf4 new\cf0  \cf3 MyClass\cf0 ();\par ??    \cf5 // Exercise system\par ??\cf0     \cf4 string\cf0  result = sut.Invert(numberText);\par ??    \cf5 // Verify outcome\par ??\cf0     \cf3 Assert\cf0 .AreEqual&lt;\cf4 string\cf0 &gt;(expectedResult, result,\par ??        \cf6 "DoWork"\cf0 );\par ??    \cf5 // Teardown\par ??\cf0 \}}
-->
<div style="font-size: 10pt; background: white; color: black; font-family: courier new"><pre style="margin: 0px">[<span style="color: #2b91af">TestMethod</span>]</pre><pre style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">void</span> InvertWillInvertNumber()</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">double</span> anonymousNumber = 10;</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> numberText = anonymousNumber.ToString();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> expectedResult = </pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1d / anonymousNumber).ToString();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">MyClass</span> sut = <span style="color: blue">new</span> <span style="color: #2b91af">MyClass</span>();</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span> result = sut.Invert(numberText);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">Assert</span>.AreEqual&lt;<span style="color: blue">string</span>&gt;(expectedResult, result,</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #a31515">"DoWork"</span>);</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Teardown</span></pre><pre style="margin: 0px">}</pre></div>
<p>In this way, we can break down the test cases to individual Executable Specifications that define the expected behavior for each Equivalence Class.</p>
<p>While such tests more clearly provide both specification and documentation, it requires discipline to write tests in this way. Particularly when the algorithm is so simple as is the case here, it's very tempting to just hard-code the values directly into the assertion.</p>
<p>In a future post, I'll explain <a href="http://blog.ploeh.dk/2009/03/05/ConstrainedNonDeterminism.aspx">how we can force ourselves to do the right thing per default</a>.</p>
</div>
	