---
layout: post
title: "IO is special"
description: "Are IO expressions really referentially transparent programs?"
date: 2025-09-08 5:36 UTC
tags: [Haskell, Functional Programming]
image: "/content/binary/ref-trans-purity-venn.png"
image_alt: "Venn diagram of two sets: Referential transparency and purity. The intersection is considerable."
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        Sometimes, when I discuss <a href="/2018/11/19/functional-architecture-a-definition">functional architecture</a> or <a href="/2020/06/08/the-io-container">the IO container</a>, a reader will argue that <a href="https://www.haskell.org/">Haskell</a> <code>IO</code> really is 'pure', 'referentially transparent', 'functional', or has another similar property.
    </p>
    <p>
        The argument usually goes like this: An <code>IO</code> value is a composable <em>description</em> of an action, but not in itself an action. Since <code>IO</code> is a <code>Monad</code> instance, it composes via the usual monadic <em>bind</em> combinator <code>&gt;&gt;=</code>, or one of its derivatives.
    </p>
    <p>
        Another point sometimes made is that you <em>can</em> 'call' an <code>IO</code>-valued action from within a pure function, as demonstrated by this toy example:
    </p>
    <p>
        <pre><span style="color:#2b91af;">greet</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">TimeOfDay</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">String</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">String</span>
greet&nbsp;timeOfDay&nbsp;name&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;greeting&nbsp;=&nbsp;<span style="color:blue;">case</span>&nbsp;<span style="color:blue;">()</span>&nbsp;<span style="color:blue;">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;|&nbsp;isMorning&nbsp;timeOfDay&nbsp;-&gt;&nbsp;<span style="color:#a31515;">&quot;Good&nbsp;morning&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isAfternoon&nbsp;timeOfDay&nbsp;-&gt;&nbsp;<span style="color:#a31515;">&quot;Good&nbsp;afternoon&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isEvening&nbsp;timeOfDay&nbsp;-&gt;&nbsp;<span style="color:#a31515;">&quot;Good&nbsp;evening&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:blue;">otherwise</span>&nbsp;-&gt;&nbsp;<span style="color:#a31515;">&quot;Hello&quot;</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sideEffect&nbsp;=&nbsp;<span style="color:blue;">putStrLn</span>&nbsp;<span style="color:#a31515;">&quot;Side&nbsp;effect!&quot;</span>
 
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;<span style="color:blue;">if</span>&nbsp;<span style="color:blue;">null</span>&nbsp;name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;greeting&nbsp;++&nbsp;<span style="color:#a31515;">&quot;.&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;greeting&nbsp;++&nbsp;<span style="color:#a31515;">&quot;,&nbsp;&quot;</span>&nbsp;++&nbsp;name&nbsp;++&nbsp;<span style="color:#a31515;">&quot;.&quot;</span></pre>
    </p>
    <p>
        This is effectively a Haskell port of the example given in <a href="/2020/07/06/referential-transparency-of-io">Referential transparency of IO</a>. Here, <code>sideEffect</code> is a value of the type <code>IO ()</code>, even though <code>greet</code> is a <a href="https://en.wikipedia.org/wiki/Pure_function">pure function</a>. Such examples are sometimes used to argue that the expression <code>putStrLn "Side effect!"</code> is pure, because it's deterministic and has no side effects.
    </p>
    <p>
        Rather, <code>sideEffect</code> is a 'program' that describes an action. The program is a referentially transparent value, although actually running it is not.
    </p>
    <p>
        As I also explained in <a href="/2020/07/06/referential-transparency-of-io">Referential transparency of IO</a>, the above function application is legal because <code>greet</code> never uses the value 'inside' the <code>IO</code> action. In fact, the compiler may choose to optimize the <code>sideEffect</code> expression away, and I believe that <a href="https://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler">GHC</a> does just that.
    </p>
    <p>
        I've tried to summarize the most common arguments as succinctly as I can. While I could cite actual online discussions that I've had, I don't wish to single out anyone. I don't want to make this article appear as though it's an attack on anyone in particular. Rather, my position remains that <em><code>IO</code> is special</em>, and I'll subsequently try to explain the reasoning.
    </p>
    <h3 id="a0e9e80d72eb4a979dddbce385649d3b">
        Reductio ad absurdum <a href="#a0e9e80d72eb4a979dddbce385649d3b">#</a>
    </h3>
    <p>
        While I could begin my argument stating the general case, backed up by citing some papers, I'm afraid I'll lose most readers in the process. Therefore I'll flip the argument around and start with a counter-example. What would happen if we accept the claim that <code>IO</code> is pure or <a href="https://en.wikipedia.org/wiki/Referential_transparency">referentially transparent</a>?
    </p>
    <p>
        It would follow that <em>all</em> Haskell code should be considered pure. That would include <code>putStrLn "Hello, world."</code> or <a href="https://hackage.haskell.org/package/acme-missiles/docs/Acme-Missiles.html">launchMissiles</a>. That I find that conclusion absurd may just be my <a href="/2020/10/12/subjectivity">subjective</a> opinion, but it also seems to go against the original purpose of using <code>IO</code> to tackle the awkward squad.
    </p>
    <p>
        Furthermore, and this may be more objective, it seems to allow writing <em>everything</em> in <code>IO</code>, and still call it 'functional'. What do I mean by that?
    </p>
    <h3 id="283ca4d2dc6b4b38897fd43f2c3c51d1">
        Functional imperative code <a href="#283ca4d2dc6b4b38897fd43f2c3c51d1">#</a>
    </h3>
    <p>
        If we accept that <code>IO</code> is pure, then we may decide to write everything in procedural style. We could, for example, <a href="/2024/12/23/implementing-rod-cutting">implement rod-cutting</a> by mirroring the imperative pseudocode used to describe the algorithm.
    </p>
    <p>
        <pre>{-#&nbsp;<span style="color:gray;">LANGUAGE</span>&nbsp;FlexibleContexts&nbsp;#-}
<span style="color:blue;">module</span>&nbsp;RodCutting&nbsp;<span style="color:blue;">where</span>
 
<span style="color:blue;">import</span>&nbsp;Control.Monad&nbsp;(<span style="color:#2b91af;">forM_</span>,&nbsp;<span style="color:#2b91af;">when</span>)
<span style="color:blue;">import</span>&nbsp;Data.Array.IO
<span style="color:blue;">import</span>&nbsp;Data.IORef&nbsp;(<span style="color:#2b91af;">newIORef</span>,&nbsp;<span style="color:#2b91af;">writeIORef</span>,&nbsp;<span style="color:#2b91af;">readIORef</span>,&nbsp;<span style="color:#2b91af;">modifyIORef</span>)
 
<span style="color:#2b91af;">cutRod</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Ix</span>&nbsp;i,&nbsp;<span style="color:blue;">Num</span>&nbsp;i,&nbsp;<span style="color:blue;">Enum</span>&nbsp;i,&nbsp;<span style="color:blue;">Num</span>&nbsp;e,&nbsp;<span style="color:blue;">Bounded</span>&nbsp;e,&nbsp;<span style="color:blue;">Ord</span>&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;<span style="color:blue;">IOArray</span>&nbsp;i&nbsp;e&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;i&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">IO</span>&nbsp;(<span style="color:blue;">IOArray</span>&nbsp;i&nbsp;e,&nbsp;<span style="color:blue;">IOArray</span>&nbsp;i&nbsp;i)
cutRod&nbsp;p&nbsp;n&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;r&nbsp;&lt;-&nbsp;newArray_&nbsp;(0,&nbsp;n)
&nbsp;&nbsp;s&nbsp;&lt;-&nbsp;newArray_&nbsp;(1,&nbsp;n)
&nbsp;&nbsp;writeArray&nbsp;r&nbsp;0&nbsp;0&nbsp;&nbsp;<span style="color:green;">--&nbsp;r[0]&nbsp;=&nbsp;0
</span>&nbsp;&nbsp;forM_&nbsp;[1..n]&nbsp;$&nbsp;\j&nbsp;-&gt;&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;&lt;-&nbsp;newIORef&nbsp;<span style="color:blue;">minBound</span>&nbsp;&nbsp;<span style="color:green;">--&nbsp;q&nbsp;=&nbsp;-∞
</span>&nbsp;&nbsp;&nbsp;&nbsp;forM_&nbsp;[1..j]&nbsp;$&nbsp;\i&nbsp;-&gt;&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qValue&nbsp;&lt;-&nbsp;readIORef&nbsp;q
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p_i&nbsp;&lt;-&nbsp;readArray&nbsp;p&nbsp;i
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r_j_i&nbsp;&lt;-&nbsp;readArray&nbsp;r&nbsp;(j&nbsp;-&nbsp;i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;(qValue&nbsp;&lt;&nbsp;p_i&nbsp;+&nbsp;r_j_i)&nbsp;$&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeIORef&nbsp;q&nbsp;(p_i&nbsp;+&nbsp;r_j_i)&nbsp;&nbsp;<span style="color:green;">--&nbsp;q&nbsp;=&nbsp;p[i]&nbsp;+&nbsp;r[j&nbsp;-&nbsp;i]
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeArray&nbsp;s&nbsp;j&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">--&nbsp;s[j]&nbsp;=&nbsp;i
</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qValue&#39;&nbsp;&lt;-&nbsp;readIORef&nbsp;q
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeArray&nbsp;r&nbsp;j&nbsp;qValue&#39;&nbsp;&nbsp;<span style="color:green;">--&nbsp;r[j]&nbsp;=&nbsp;q
</span>
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;(r,&nbsp;s)</pre>
    </p>
    <p>
        Ironically, the <code>cutRod</code> action remains referentially transparent, as is the original pseudocode from <a href="/ref/clrs">CLRS</a>. This is because the algorithm itself is deterministic, and has no (external) side effects. Even so, the Haskell type system can't 'see' that. This implementation is intrinsically <code>IO</code>-valued.
    </p>
    <h3 id="2b88809a7f244ed9bbabed7cfacff682">
        Functional encapsulation <a href="#2b88809a7f244ed9bbabed7cfacff682">#</a>
    </h3>
    <p>
        You may think that this just proves the point that <code>IO</code> is pure, but it doesn't. We've always known that we can lift any pure value into <code>IO</code> using <code>return</code>: <code>return 42</code> remains referentially transparent, even if it's contained in <code>IO</code>.
    </p>
    <p>
        The reverse isn't always true. We can't conclude that code is referentially transparent when it's contained in <code>IO</code>. Usually, it isn't.
    </p>
    <p>
        Be that as it may, why do we even care?
    </p>
    <p>
        The problem is one of <a href="/2022/10/24/encapsulation-in-functional-programming">encapsulation</a>. When an action like <code>cutRod</code>, above, returns an <code>IO</code> value, we're facing a dearth of guarantees. As users of the action, we may have many questions, most of which aren't answered by the type:
    </p>
    <ul>
        <li>Does <code>cutRod</code> modify the input array <code>p</code>?</li>
        <li>Is <code>cutRod</code> deterministic?</li>
        <li>Does <code>cutRod</code> launch missiles?</li>
        <li>Can I memoize the return values of <code>cutRod</code>?</li>
        <li>Does <code>cutRod</code> somehow keep a reference to the arrays that it returns? Can I be sure that a background thread, or a subsequent API call, doesn't mutate these arrays? In other words, is there a potential <a href="https://en.wikipedia.org/wiki/Aliasing_(computing)">aliasing</a> problem?</li>
    </ul>
    <p>
        At best, such lack of guarantees lead to <a href="/2013/07/08/defensive-coding">defensive coding</a>, but usually it leads to bugs.
    </p>
    <p>
        If, on the other hand, we were to write a version of <code>cutRod</code> that does <em>not</em> involve <code>IO</code>, we'd be able to answer all the above questions. The advantage would be that the function would be safer and easier to consume.
    </p>
    <h3 id="b0946c3ce3cc44359ec4babce80335cd">
        Referential transparency is not the same as purity <a href="#b0946c3ce3cc44359ec4babce80335cd">#</a>
    </h3>
    <p>
        This leads to a point that I failed to understand for years, <a href="/2020/02/24/discerning-and-maintaining-purity#60eb2b1f83dd4b2fbc0be684d729af96">until Tyson Williams pointed it out to me</a>. Referential transparency is not the same as purity, although the overlap is substantial.
    </p>
    <p>
        <img src="/content/binary/ref-trans-purity-venn.png" alt="Venn diagram of two sets: Referential transparency and purity. The intersection is considerable." width="400">
    </p>
    <p>
        Of course, such a claim requires me to define the terms, but I'll try to keep it light. I'll define <em>referential transparency</em> as the property that allows replacing a function with the value it produces. Practically, it allows memoization. On the other hand, I'll define <em>purity</em> as functions that Haskell can distinguish from impure actions. In practice, this implies the absence of <code>IO</code>.
    </p>
    <p>
        Usually this amounts to the same thing, but as we've seen above, it's possible to write referentially transparent code that nonetheless is embedded in <code>IO</code>. There are also <a href="http://conal.net/blog/posts/notions-of-purity-in-haskell">examples of functions that look pure, although they may not be referentially transparent</a>. Fortunately these are, in my experience, more rare.
    </p>
    <p>
        That said, this is a digression. My agenda is to argue that <code>IO</code> is special. Yes, it's a <code>Monad</code> instance. Yes, it composes. No, it's not referentially transparent.
    </p>
    <h3 id="5392eba1c39c405d99e77de57d842120">
        Semantics <a href="#5392eba1c39c405d99e77de57d842120">#</a>
    </h3>
    <p>
        From the point of encapsulation, I've previously argued that <a href="/2021/07/28/referential-transparency-fits-in-your-head">referential transparency is attractive because it fits in your head</a>. Code that is not referentially transparent usually doesn't.
    </p>
    <p>
        Why is <code>IO</code> not referentially transparent? To repeat the argument that I sometimes run into, <code>IO</code> values describe programs. Every time your Haskell code runs, the same <code>IO</code> value describes the same program.
    </p>
    <p>
        This strikes me as about as useful an assertion as insisting that all <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a> code is referentially transparent. After all, a C program also describes the same program even if executed multiple times.
    </p>
    <p>
        But you don't have to take my word for it. In <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf">Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell</a> Simon Peyton Jones presents the semantics of Haskell.
    </p>
    <blockquote>
        <p>
            "Our semantics is stratified in two levels: an <em>inner denotational semantics</em> that describes the behaviour of pure terms, while an <em>outer monadic transition semantics</em> describes the behaviour of <code>IO</code> computations."
        </p>
        <footer><cite>Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell</cite>, Simon Peyton Jones, 2000</footer>
    </blockquote>
    <p>
        Over the next 20 pages, that paper goes into details on how <code>IO</code> is special. The point is that it has different semantics from the rest of Haskell.
    </p>
    <h3 id="ba343f93c94d4ffba33c78a226f0f0de">
        Pure rod-cutting <a href="#ba343f93c94d4ffba33c78a226f0f0de">#</a>
    </h3>
    <p>
        Before I close, I realize that the above <code>cutRod</code> action may cause distress with some readers. To relieve the tension I'll leave you with a pure implementation.
    </p>
    <p>
        <pre>{-#&nbsp;<span style="color:gray;">LANGUAGE</span>&nbsp;TupleSections&nbsp;#-}
<span style="color:blue;">module</span>&nbsp;RodCutting&nbsp;(<span style="color:#2b91af;">cutRod</span>,&nbsp;<span style="color:#2b91af;">solve</span>)&nbsp;<span style="color:blue;">where</span>
 
<span style="color:blue;">import</span>&nbsp;Data.Foldable&nbsp;(<span style="color:#2b91af;">foldl&#39;</span>)
<span style="color:blue;">import</span>&nbsp;Data.Map.Strict&nbsp;(<span style="color:#2b91af;">(!)</span>)
<span style="color:blue;">import</span>&nbsp;<span style="color:blue;">qualified</span>&nbsp;Data.Map.Strict&nbsp;<span style="color:blue;">as</span>&nbsp;Map
 
<span style="color:#2b91af;">seekBetterCut</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Ord</span>&nbsp;a,&nbsp;<span style="color:blue;">Num</span>&nbsp;a)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;[a]&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(a,&nbsp;<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;a,&nbsp;<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:#2b91af;">Int</span>)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Int</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(a,&nbsp;<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;a,&nbsp;<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:#2b91af;">Int</span>)
seekBetterCut&nbsp;p&nbsp;j&nbsp;(q,&nbsp;r,&nbsp;s)&nbsp;i&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;price&nbsp;=&nbsp;p&nbsp;!!&nbsp;i
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainingRevenue&nbsp;=&nbsp;r&nbsp;!&nbsp;(j&nbsp;-&nbsp;i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(q&#39;,&nbsp;s&#39;)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;q&nbsp;&lt;&nbsp;price&nbsp;+&nbsp;remainingRevenue&nbsp;<span style="color:blue;">then</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(price&nbsp;+&nbsp;remainingRevenue,&nbsp;Map.insert&nbsp;j&nbsp;i&nbsp;s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;(q,&nbsp;s)
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&#39;&nbsp;=&nbsp;Map.insert&nbsp;j&nbsp;q&#39;&nbsp;r
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;(q&#39;,&nbsp;r&#39;,&nbsp;s&#39;)
 
<span style="color:#2b91af;">findBestCut</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Bounded</span>&nbsp;a,&nbsp;<span style="color:blue;">Ord</span>&nbsp;a,&nbsp;<span style="color:blue;">Num</span>&nbsp;a)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;[a]&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;a,&nbsp;<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:#2b91af;">Int</span>)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Int</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;a,&nbsp;<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:#2b91af;">Int</span>)
findBestCut&nbsp;p&nbsp;(r,&nbsp;s)&nbsp;j&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;q&nbsp;=&nbsp;<span style="color:blue;">minBound</span>&nbsp;&nbsp;<span style="color:green;">--&nbsp;q&nbsp;=&nbsp;-∞
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(_,&nbsp;r&#39;,&nbsp;s&#39;)&nbsp;=&nbsp;foldl&#39;&nbsp;(seekBetterCut&nbsp;p&nbsp;j)&nbsp;(q,&nbsp;r,&nbsp;s)&nbsp;[1..j]
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;(r&#39;,&nbsp;s&#39;)
 
<span style="color:#2b91af;">cutRod</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Bounded</span>&nbsp;a,&nbsp;<span style="color:blue;">Ord</span>&nbsp;a,&nbsp;<span style="color:blue;">Num</span>&nbsp;a)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;[a]&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;a,&nbsp;<span style="color:blue;">Map</span>.<span style="color:blue;">Map</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:#2b91af;">Int</span>)
cutRod&nbsp;p&nbsp;n&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;r&nbsp;=&nbsp;Map.fromAscList&nbsp;$&nbsp;<span style="color:blue;">map</span>&nbsp;(,&nbsp;0)&nbsp;[0..n]&nbsp;&nbsp;<span style="color:green;">--&nbsp;r[0:n]&nbsp;initialized&nbsp;to&nbsp;0
</span>&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;s&nbsp;=&nbsp;Map.fromAscList&nbsp;$&nbsp;<span style="color:blue;">map</span>&nbsp;(,&nbsp;0)&nbsp;[1..n]&nbsp;&nbsp;<span style="color:green;">--&nbsp;s[1:n]&nbsp;initialized&nbsp;to&nbsp;0
</span>&nbsp;&nbsp;foldl&#39;&nbsp;(findBestCut&nbsp;p)&nbsp;(r,&nbsp;s)&nbsp;[1..n]
 
<span style="color:#2b91af;">solve</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Bounded</span>&nbsp;a,&nbsp;<span style="color:blue;">Ord</span>&nbsp;a,&nbsp;<span style="color:blue;">Num</span>&nbsp;a)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;[a]&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Int</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[<span style="color:#2b91af;">Int</span>]
solve&nbsp;p&nbsp;n&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;(_,&nbsp;s)&nbsp;=&nbsp;cutRod&nbsp;p&nbsp;n
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;l&nbsp;n&#39;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;n&#39;&nbsp;&gt;&nbsp;0&nbsp;<span style="color:blue;">then</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;cut&nbsp;=&nbsp;s&nbsp;!&nbsp;n&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;loop&nbsp;(cut&nbsp;:&nbsp;l)&nbsp;(n&#39;&nbsp;-&nbsp;cut)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;l
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&#39;&nbsp;=&nbsp;loop&nbsp;<span style="color:blue;">[]</span>&nbsp;n
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;<span style="color:blue;">reverse</span>&nbsp;l&#39;</pre>
    </p>
    <p>
        This is a fairly direct translation of the imperative algorithm. It's possible that you could come up with something more elegant. At least, I think that <a href="/2025/01/06/encapsulating-rod-cutting">I did so in F#</a>.
    </p>
    <p>
        Regardless of the level of elegance of the implementation, this version of <code>cutRod</code> advertises its properties via its type. A client developer can now trivially answer the above questions, just by looking at the type: No, the function doesn't mutate the input list <code>p</code>. Yes, the function is deterministic. No, it doesn't launch missiles. Yes, you can memoize it. No, there's no aliasing problem.
    </p>
    <h3 id="379ee8d1db8046a1ac2133d7ff603a4a">
        Conclusion <a href="#379ee8d1db8046a1ac2133d7ff603a4a">#</a>
    </h3>
    <p>
        From time to time, I run into the claim that Haskell <code>IO</code>, being monadic and composable, is referentially transparent, and that it's only during execution that this property is lost.
    </p>
    <p>
        I argue that such claims are of little practical interest. There are other parts of Haskell that <em>remain</em> referentially transparent, even during execution. Thus, <code>IO</code> is still special.
    </p>
    <p>
        From a practical perspective, the reason I care about referential transparency is because the more you have of it, the simpler your code is; the better it fits in your head. The kind of referential transparency that some people argue that <code>IO</code> has does not have the property of making code simpler. In reality, <code>IO</code> code has the same inherent properties as code written in C, <a href="https://www.python.org/">Python</a>, <a href="https://www.java.com">Java</a>, <a href="https://fortran-lang.org/">Fortran</a>, etc.
    </p>
</div>