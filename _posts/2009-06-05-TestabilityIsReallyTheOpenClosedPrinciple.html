---
layout: post
tags: [Software Design, Unit Testing]
date: 2009-06-05 07:56:19 UTC
title: "Testability Is Really The Open/Closed Principle"
comments: true
---
{% include JB/setup %}

<div id="post">
	<p>When I talk with people about TDD and unit testing, the discussion often moves into the area of Testability  -  that is, the software's susceptibility to unit testing. A couple of years back, <a href="http://weblogs.asp.net/rosherove/default.aspx">Roy</a> even discussed the seemingly <a href="http://weblogs.asp.net/rosherove/archive/2007/02/25/why-you-should-think-about-ootp-object-oriented-testable-programming.aspx">opposable forces of Object-Oriented Design and Testability</a>.</p> <p>Lately, it has been occurring to me that there really isn't any conflict. Encapsulation is important because it manifests expert knowledge so that other developers can effectively leverage that knowledge, and it does so in a way that minimizes misuse.</p> <p>However, too much encapsulation goes against the Open/Closed Principle (that states that objects should be open for extension, but closed for modification). From a Testability perspective, the Open/Closed Principle pulls object-oriented design in the desired direction. Equivalently, done correctly, making your API Testable is simply opening it up for extensibility.</p> <p>As an example, consider a simple <a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">WPF ViewModel</a> class called MainWindowViewModel. This class has an <a href="http://msdn.microsoft.com/en-us/library/system.windows.input.icommand.aspx">ICommand</a> property that, when invoked, should show a message box. Showing a message box is good example of breaking testability, because if the <a href="http://xunitpatterns.com/SUT.html">SUT</a> were to show a message box, it would be very hard to automatically verify and we wouldn't have fully automated tests.</p> <p>For this reason, we need to introduce an abstraction that basically models an action with a string as input. <a href="http://blog.ploeh.dk/2009/05/28/DelegatesAreAnonymousInterfaces.aspx">Although we could define an interface for that, an Action&lt;string&gt; fits the bill perfectly</a>.</p> <p>To enable that feature, I decide to use Constructor Injection to inject that abstraction into the MainWindowViewModel class:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;}??\fs20 \cf1 public\cf0  MainWindowViewModel(\cf4 Action\cf0 &lt;\cf1 string\cf0 &gt; notify)\par ??\{\par ??    \cf1 this\cf0 .ButtonCommand = \cf1 new\cf0  \cf4 RelayCommand\cf0 (p =&gt; \par ??    \{ notify(\cf5 "Button was clicked!"\cf0 ); \});\par ??\}}
--> <div style="font-family: courier new; background: white; color: black; font-size: 10pt"><pre style="margin: 0px"><span style="color: blue">public</span> MainWindowViewModel(<span style="color: #2b91af">Action</span>&lt;<span style="color: blue">string</span>&gt; notify)</pre><pre style="margin: 0px">{</pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>.ButtonCommand = <span style="color: blue">new</span> <span style="color: #2b91af">RelayCommand</span>(p =&gt; </pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; { notify(<span style="color: #a31515">"Button was clicked!"</span>); });</pre><pre style="margin: 0px">}</pre></div>
<p>When I recently did that at a public talk I gave, one member of the audience initially reacted by assuming that I was now introducing test-specific code into my SUT, but that's not the case.</p>
<p>What I'm really doing here is opening the MainWindowViewModel class for extensibility. It can still be used with message boxes:</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}??\fs20 \cf1 var\cf0  vm = \cf1 new\cf0  \cf4 MainWindowViewModel\cf0 (s =&gt; \cf4 MessageBox\cf0 .Show(s));}
-->
<div style="font-family: courier new; background: white; color: black; font-size: 10pt"><pre style="margin: 0px"><span style="color: blue">var</span> vm = <span style="color: blue">new</span> <span style="color: #2b91af">MainWindowViewModel</span>(s =&gt; <span style="color: #2b91af">MessageBox</span>.Show(s));</pre></div>
<p>but now we also have the option of notifying by sending off an email; writing to a database; or whatever else we can think of.</p>
<p>It just so happens that one of the things we can do instead of showing a message box, is unit testing by passing in a <a href="http://xunitpatterns.com/Test%20Double.html">Test Double</a>.</p><!--
{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green128\blue0;\red255\green255\blue255;\red0\green0\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;}??\fs20 \cf1 // Fixture setup\par ??\cf3 var\cf0  mockNotify = \par ??    \cf5 MockRepository\cf0 .GenerateMock&lt;\cf5 Action\cf0 &lt;\cf3 string\cf0 &gt;&gt;();\par ??mockNotify.Expect(a =&gt; a(\cf6 "Button was clicked!"\cf0 ));\par ??\par ??\cf3 var\cf0  sut = \cf3 new\cf0  \cf5 MainWindowViewModel\cf0 (mockNotify);\par ??\cf1 // Exercise system\par ??\cf0 sut.ButtonCommand.Execute(\cf3 new\cf0  \cf3 object\cf0 ());\par ??\cf1 // Verify outcome\par ??\cf0 mockNotify.VerifyAllExpectations();\par ??\cf1 // Teardown}
-->
<div style="font-family: courier new; background: white; color: black; font-size: 10pt"><pre style="margin: 0px"><span style="color: green">// Fixture setup</span></pre><pre style="margin: 0px"><span style="color: blue">var</span> mockNotify = </pre><pre style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: #2b91af">MockRepository</span>.GenerateMock&lt;<span style="color: #2b91af">Action</span>&lt;<span style="color: blue">string</span>&gt;&gt;();</pre><pre style="margin: 0px">mockNotify.Expect(a =&gt; a(<span style="color: #a31515">"Button was clicked!"</span>));</pre><pre style="margin: 0px">&nbsp;</pre><pre style="margin: 0px"><span style="color: blue">var</span> sut = <span style="color: blue">new</span> <span style="color: #2b91af">MainWindowViewModel</span>(mockNotify);</pre><pre style="margin: 0px"><span style="color: green">// Exercise system</span></pre><pre style="margin: 0px">sut.ButtonCommand.Execute(<span style="color: blue">new</span> <span style="color: blue">object</span>());</pre><pre style="margin: 0px"><span style="color: green">// Verify outcome</span></pre><pre style="margin: 0px">mockNotify.VerifyAllExpectations();</pre><pre style="margin: 0px"><span style="color: green">// Teardown</span></pre></div>
<p>Once again, TDD has lead to better design. In this case it prompted me to open the class for extensibility. There really isn't a need for Testability as a specific concept; the Open/Closed Principle should be enough to drive us in the right direction.</p>
<p>Pragmatically, that's not the case, so we use TDD to drive us towards the Open/Closed Principle, but I think it's important to note that we are not only doing this to enable testing: We are creating a better and more flexible API at the same time.</p>
</div>
	