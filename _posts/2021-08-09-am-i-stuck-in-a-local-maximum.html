---
layout: post
title: "Am I stuck in a local maximum?"
description: "On long-standing controversies, biases, and failures of communication."
date: 2021-08-09 5:56 UTC
tags: [Productivity]
image: "/content/binary/same-goal-different-starting-points.png"
image_alt: "Two arrows pointing to the same problem from different directions."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		If you can stay out of politics, Twitter can be a great place to engage in robust discussions. I mostly follow and engage with people in the programming community, and every so often find myself involved in a discussion about one of several long-standing controversies. No, not the tabs-versus-spaces debate, but other debates such as functional versus object-oriented programming, dynamic versus static typing, or <a href="/2020/03/16/conways-law-latency-versus-throughput">oral versus written collaboration</a>.
	</p>
	<p>
		It happened again the past week, but while this article is a reaction, it's not about the specific debacle. Thus, I'm not going to link to the tweets in question.
	</p>
	<p>
		These discussion usually leave me wondering why people with decades of industry experience seem to have such profound disagreements.
	</p>
	<h3 id="13c8dc8fbc9b4e26ba08bfeef9b61fd9">
		I might be wrong <a href="#13c8dc8fbc9b4e26ba08bfeef9b61fd9" title="permalink">#</a>
	</h3>
	<p>
		Increasingly, I find myself disagreeing with my heroes. This isn't a comfortable position. Could I be wrong?
	</p>
	<p>
		I've definitely been wrong before. For example, in my article <a href="/2016/02/10/types-properties-software">Types + Properties = Software</a>, I wrote about type systems:
	</p>
	<blockquote>
		<p>"To the far right, we have a hypothetical language with such a strong type system that, indeed, <em>if it compiles, it works.</em>"</p>
	</blockquote>
	<p>
		<em>To the right</em>, in this context, means <em>more statically typed</em>. While the notion is natural, the sentence is uninformed. When I wrote the article, I <a href="https://www.goodreads.com/review/show/1731926050">hadn't yet read</a> Charles Petzold's excellent <a href="http://amzn.to/2n9MFGh">Annotated Turing</a>. Although I had heard about the <a href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a> before reading the book, I hadn't internalised it. I wasn't able to draw inferences based on that labelled concept.
	</p>
	<p>
		After I read the book, I've come to understand that general-purpose static type system can never prove unequivocally that a generic program works. That's what <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Church</a>, <a href="https://en.wikipedia.org/wiki/Alan_Turing">Turing</a>, and <a href="https://en.wikipedia.org/wiki/Kurt_Gödel">Gödel</a> proved.
	</p>
	<p>
		I've been writing articles on this blog <a href="/2009/01/28/LivingInInterestingTimes">since January 2009</a>. To date, I've published 582 posts. Some are bound to be misinformed, outdated, or just plain wrong. Due to the sheer volume, I make no consistent effort to retroactively monitor and correct my past self. (I'm happy to engage with specific posts. If you feel that an old post is misleading, erroneous, or the like, please <a href="https://github.com/ploeh/ploeh.github.com#comments">leave a comment</a>.)
	</p>
	<p>
		For good measure, despite my failure to understand the implications of the halting problem, I'm otherwise happy with the article series <a href="/2016/02/10/types-properties-software">Types + Properties = Software</a>. You shouldn't consider this particular example a general condemnation of it. It's just an example of a mistake I made. This time, I'm aware of it, but there are bound to be plenty of other examples where I don't even realise it.
	</p>
	<h3 id="d7843f0140164eaf97a7724413d70d76">
		Heroes <a href="#d7843f0140164eaf97a7724413d70d76" title="permalink">#</a>
	</h3>
	<p>
		I don't have a formal degree in computer science. As so many others of my age, I began my software career by tinkering with computers and (later) programming. The first five years of my professional career, there wasn't much methodology to the way I approached software development. Self-taught often means that you have to learn everything the hard way.
	</p>
	<p>
		This changed when I first heard about test-driven development (TDD). I credit <a href="https://martinfowler.com">Martin Fowler</a> with that. Around the same time I also read <a href="http://amzn.to/XBYukB">Design Patterns</a>. Armed with those two techniques, I was able to rescue a failed software project and bring it to successful completion. I even received an (internal) award for it.
	</p>
	<p>
		While there's more to skilled programming than test-driven development and patterns, it wasn't a bad place to start. Where, before, I had nothing that even resembled a methodology, now I had a set of practices I could use. This gave me an opportunity to experiment and observe. A few years later, <a href="/2010/12/03/Towardsbetterabstractions">I'd already started to notice some recurring beneficial patterns</a> in the code that I wrote, as well as <a href="/2010/12/22/TheTDDApostate">some limits of TDD</a>.
	</p>
	<p>
		Still, that was a decade where I voraciously read, attended conferences, and tried to learn from my heroes. I hope that they won't mind that I list them here:
		<ul>
			<li><a href="https://martinfowler.com">Martin Fowler</a></li>
			<li><a href="https://en.wikipedia.org/wiki/Kent_Beck">Kent Beck</a></li>
			<li><a href="https://en.wikipedia.org/wiki/Robert_C._Martin">Robert C. Martin</a></li>
			<li><a href="https://michaelfeathers.silvrback.com">Michael Feathers</a></li>
			<li><a href="https://dannorth.net">Dan North</a></li>
		</ul>
		Surely, there were others. I remember being a big fan of <a href="https://en.wikipedia.org/wiki/Don_Box">Don Box</a>, but he seems to have withdrawn from the public long time ago. There were also .NET trailblazers that I admired and tried to emulate. Later, I learned much from the early luminaries of <a href="https://fsharp.org">F#</a>. I'm not going to list all the people I admire here, because the list could never be complete, and I don't wish to leave anyone feeling left out. Related to the point I'm trying to make, all these other wonderful people give me less pause.
	</p>
	<p>
		There's a reason I list those particular heroes. I should include a few more of whom I wasn't aware in my formative years, but whom I've since come to highly respect: <a href="https://twitter.com/marick">Brian Marick</a> and <a href="https://jessitron.com">Jessica Kerr</a>.
	</p>
	<p>
		Why do I mention these heroes of mine?
	</p>
	<h3 id="ae81dde11de94f9fb223cf06377a22c4">
		Bias <a href="#ae81dde11de94f9fb223cf06377a22c4" title="permalink">#</a>
	</h3>
	<p>
		Humans aren't as rational as we'd like to think. We all have plenty of <a href="https://en.wikipedia.org/wiki/Cognitive_bias">cognitive biases</a>. I'm aware of a few of mine, but I expect most of them to be hidden from me. Sometimes, it's easier to spot the bias in others. Perhaps, by spotting the bias in others, it reveals something about oneself?
	</p>
	<p>
		I increasingly find myself disagreeing with my heroes. One example is the long-standing controversy about static versus dynamic typing.
	</p>
	<p>
		I hope I'm not misrepresenting anyone, but the heroes I enumerate above seem to favour dynamic typing over static typing - some more strongly than others. This worries me.
	</p>
	<p>
		These are people who've taught me a lot; whose opinion I deeply respect, and yet I fail to grasp the benefit of dynamic typing. What are the benefits they gain from their preferred languages that I'm blind to? What am I missing?
	</p>
	<p>
		Whenever I find myself disagreeing with my heroes, I can't help question my own judgment. Am I biased? Yes, obviously, but in which way? What bias prohibits me from seeing the benefits that are so obvious to them?
	</p>
	<p>
		It's too easy to jump to conclusions - to erect a dichotomy:
		<ul>
			<li>My heroes are right, and I'm wrong</li>
			<li>My heroes are <em>all</em> wrong, and I'm right</li>
		</ul>
		The evidence doesn't seem to support the latter conclusion, but if the first is true, I still fail to understand <em>why</em> I'm wrong.
	</p>
	<p>
		I'm hoping that there's a more nuanced position to take - that the above is a <a href="https://en.wikipedia.org/wiki/False_dilemma">false dichotomy</a>.
	</p>
	<h3 id="1dc21ee0532e4555ab621dfd32f31f12">
		What's the problem? <a href="#1dc21ee0532e4555ab621dfd32f31f12" title="permalink">#</a>
	</h3>
	<p>
		Perhaps we're really talking past each other. Perhaps we're trying to solve different problems, and thereby arrive at different solutions.
	</p>
	<p>
		I can only guess at the kinds of problems that my heroes think of when they prefer dynamic languages, and I don't want to misrepresent them. What I <em>can</em> do, however, is outline the kind of problem that I typically have in mind.
	</p>
	<p>
		I've spent much of my career trying to balance <a href="/2019/03/04/code-quality-is-not-software-quality">sustainability</a> with correctness. I consider correctness as a prerequisite for all code. As <a href="/ref/psychology-of-computer-programming">Gerald Weinberg implies</a>, if a program doesn't have to work, anything goes. Thus, sustainability is a major focus for me: how do we develop software that can sustain our organisation now <em>and</em> in the future? How do we structure and organise code so that future change is possible?
	</p>
	<p>
		Whenever I get into debates, that's implicitly the problem on my mind. It'd probably improve communication if I stated this explicitly going into every debate, but sometimes, I get dragged sideways into a debacle... I do, however, speculate that much disagreement may stem from such implicit assumptions. I bring my biases and implicit problem statements into any discussion. I consider it only human if my interlocutors do the same, but their biases and implicit problem understanding may easily be different than mine. What are they, I wonder?
	</p>
	<p>
		This seems to happen not only in the debate about dynamic versus static types. I get a similar sense when I discuss collaboration. Most of my heroes seem to advocate for high-band face-to-face collaboration, while <a href="/2020/03/16/conways-law-latency-versus-throughput">I favour asynchronous, written communication</a>. Indeed, I admit that my bias is speaking. I self-identify as a contrarian introvert (although, again, we should be careful not turning introversion versus extroversion into binary classification).
	</p>
	<p>
		Still, even when I try to account for my bias, I get the sense that my opponents and I may actually try to accomplish a common goal, but by addressing two contrasting problems.
	</p>
	<p>
		<img src="/content/binary/same-goal-different-starting-points.png" alt="Two arrows pointing to the same problem from different directions.">
	</p>
	<p>
		I think and hope that, ultimately, we're trying to accomplish the same goal: to deliver and sustain business capability.
	</p>
	<p>
		I do get the sense that the proponents of more team co-location, more face-to-face collaboration are coming at the problem from a different direction than I am. Perhaps the problem they're trying to solve is micro-management, red tape, overly bureaucratic processes, and a lack of developer autonomy. I can certainly see that if that's the problem, talking to each other is likely to improve the situation. I'd recommend that too, in such a situation.
	</p>
	<p>
		Perhaps it's a local Danish (or perhaps Northern European) phenomenon, but that's not the kind of problem I normally encounter. Most organisations who ask for my help essentially have <em>no</em> process. Everything is ad hoc, nothing is written down, deployment is a manual process, and there are meetings and interruptions all the time. Since nothing is written down, decisions aren't recorded, so team members and stakeholders keep having the same meetings over and over. Again, little gets done, but for an entirely different reason than too much bureaucracy. I see this more frequently than too much red tape, so I tend to recommend that people start leaving behind some sort of written trail of what they've been doing. Pull request reviews, for example, are great for that, and I see <a href="/2021/06/21/agile-pull-requests">no incongruity between agile and pull requests</a>.
	</p>
	<h3 id="37232ffbc5cf48e58ec773ca83046807">
		Shaped by scars <a href="#37232ffbc5cf48e58ec773ca83046807" title="permalink">#</a>
	</h3>
	<p>
		The inimitable <a href="https://twitter.com/richcampbell">Richard Campbell</a> has phrased our biases as the scars we collect during our careers. If you've deleted the production database one too many times, you develop routines and practices to avoid doing that in the future. If you've mostly worked in an organisation that stifled progress by subjecting you to <a href="https://en.wikipedia.org/wiki/Brazil_(1985_film)">Brazil</a>-levels of bureaucracy, it's understandable if you develop a preference for less formal methods. And if, like me, you've mostly seen dysfunction manifest as a <em>lack</em> of beneficial practices, you develop a taste for written over oral communication.
	</p>
	<p>
		Does it go further than that? Are we also shaped by our successes, just like we are shaped by our scars?
	</p>
	<p>
		The first time I had professional success <em>with a methodology</em> was when I discovered TDD. This made me a true believer in TDD. I'm still a big proponent of TDD, but since I learned what <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a> <a href="/2016/11/28/easy-domain-modelling-with-types">can do</a> in terms of modelling, I see <a href="/2011/04/29/Feedbackmechanismsandtradeoffs">no reason to write a run-time test if I instead can get the compiler to enforce a rule</a>.
	</p>
	<p>
		In a recent discussion, some of my heroes expressed the opinion that they don't need <a href="/2021/06/07/abstruse-nomenclature">fancy</a> functional-programming concepts and features to write good code. I'm sure that they don't.
	</p>
	<p>
		My heroes have written code for decades. While I <em>have</em> met bad programmers with decades of experience, most programmers who last that long ultimately become good programmers. I'm not so worried about them.
	</p>
	<p>
		The people who need my help are typically younger teams. Statistically, there just aren't that many <a href="/2020/09/14/we-need-young-programmers-we-need-old-programmers">older programmers</a> around.
	</p>
	<p>
		When I recommend certain practices or programming techniques, those recommendations are aimed at anyone who care to listen. Usually, I find that the audience who engage with me is predominantly programmers with five to ten years of professional experience.
	</p>
	<h3 id="0d6d6bee68644d158deb5fa8cf478be7">
		Anecdotal evidence <a href="#0d6d6bee68644d158deb5fa8cf478be7" title="permalink">#</a>
	</h3>
	<p>
		This is a difficult discussion to have. I think that another reason that we keep returning to the same controversies is that we mostly rely on <a href="https://martinfowler.com/bliki/AnecdotalEvidence.html">anecdotal evidence</a>. As we progress through our careers, we observe what works and what doesn't, but it's likely that <a href="https://en.wikipedia.org/wiki/Confirmation_bias">confirmation bias</a> makes us remember the results that we already favour, whereas we conveniently forget about the outcomes that don't fit our preferred narrative.
	</p>
	<p>
		Could we settle these discussions with more science? Alas, <a href="/2020/05/25/wheres-the-science">that's difficult</a>.
	</p>
	<p>
		I can't think of anything better, then, than keep having the same discussions over and over. I try hard to overcome my biases to understand the other side, and now and then, I learn something that I find illuminating. It doesn't seem to be a particularly efficient way to address these difficult questions, but I don't know what else to do. What's the alternative to discussion? To <em>not</em> discuss? To <em>not</em> exchange ideas?
	</p>
	<p>
		That seems worse.
	</p>
	<h3 id="ea7ed446c9094c1985f585223fbddb26">
		Conclusion <a href="#ea7ed446c9094c1985f585223fbddb26" title="permalink">#</a>
	</h3>
	<p>
		In this essay, I've tried to come to grips with an increasing cognitive incongruity that I'm experiencing. I find myself disagreeing with my heroes on a regular basis, and that makes me uncomfortable. Could it be that I'm erecting an echo chamber for myself?
	</p>
	<p>
		The practices that I follow and endorse work well for me, but could I be stuck in a local maximum?
	</p>
	<p>
		This essay has been difficult to write. I'm not sure that I've managed to convey my doubts and motivations. Should I have named my heroes, only to describe how I disagree with them? Will it be seen as aggressive?
	</p>
	<p>
		I hope not. I'm writing about my heroes with reverence and gratitude for all that they've taught me. I mean no harm.
	</p>
	<p>
		At the same time, I'm struggling with reconciling that they rarely seem to agree with me these days. Perhaps they never did.
	</p>
</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	
	<div class="comment" id="0de8cf1ba14ad74a440eb0b29f2e437b">
		<div class="comment-author"><a href="https://news.ycombinator.com/tylerhou">tylerhou</a> <a href="#0de8cf1ba14ad74a440eb0b29f2e437b">#</a></div>
		<div class="comment-content">
			<p>
			Re: type systems. I think you are wrong about being wrong. You *can* create languages with
			type systems that are strong enough to guarantee that if a program compiles, it "works." Languages
			like this exist. The most well known is <a href="https://en.wikipedia.org/wiki/Coq">Coq</a>, a
			programming language/proof-assistant which provides tools for proving that properties of your
			program hold. So literally, if it compiles, your properties are proven true (assuming the proof
			assistant does not have bugs).
			</p>

			<p>
			Why doesn't halting problem apply here? The halting problem does not conclude that "all programs cannot be
			determined to halt [for a given input]." It says something much weaker -- there is no algorithm to determine
			whether an *arbitrary program* will halt given an arbitrary input. But there are still (large) subsets of
			programs where there *does* exist such a halting algorithm, and practically, these programs are common.
			In particular, if a language disallows certain types of recursion (or iteration), you can easily prove that
			programs written in that language will halt.
			</p>

			<p>
			For example, if you used a subset of C that did not allow recursion, goto, or loops, clearly every program
			written in that subset would terminate. If you expanded your subset to allow loops with a statically-known
			iteration bound you would know that any program in that new subset would also terminate.
			Then, instead of only statically bounded loops, you could choose to allow any loop with a finite bound
			(e.g. iterating over a finite list), and termination would still be guaranteed.
			</p>

			<p>
			I am not as familiar with Coq, so I will discuss a similar language
			(<a href="https://www.idris-lang.org/">Idris</a>) that implements "substructual recursion," a generalization
			of the above intuition. In functional languages, the main barrier to proving termination is unbounded recusion.
			(In imperative languages, loops are also an issue, but loops are equivalent to recursion.) So 
			<a href="https://docs.idris-lang.org/en/latest/tutorial/theorems.html#totality-checking">Idris provides a 
			language subset</a> that only allows substructural recursion -- i.e. if a function <code>f</code>
			eventually calls itself, it must only call itself with arguments that are "smaller" than the first call.
			(E.g. for natural numbers smaller means less than, and for lists smaller means a list with a smaller size.)
			This property is checked at compile time. Since all function cases must be covered the recursive calls must
			eventually terminate.
			</p>

			<p>
			In practice, most programs don't need unbounded recursion. Most useful algorithms<sup>[citation needed]</sup>
			have some bound on the number of iterations needed. To modify any arbitrary algorithm to fit a language like
			Idris it is simple to introduce another natural number parameter <code>N</code> that always decreases by one on
			recursive calls. When that parameter reaches zero, the function should return an error. Now it is simple for
			Idris to prove that any call to that function must terminate within <code>N</code> recursions. On the initial
			call you can set this number to be the upper bound on your algorithm, and since you know that your algorithm
			will never need that many iterations you know you will always get an answer (the error is just there to satisfy
			the totality checker).
			</p>
		</div>
		<div class="comment-date">2021-08-11 05:40 UTC</div>
	</div>

	<div class="comment" id="02f4fd84d77c4006adc696457fe407dd">
		<div class="comment-author"><a href="https://twitter.com/_rchaves_">_rchaves_</a> <a href="#02f4fd84d77c4006adc696457fe407dd">#</a></div>
		<div class="comment-content">
			<p>
			Hello there!
			</p>

			<p>
			That is a very nice write up, impeccable choice of words. I could see myself a lot in it, except that at some point I
			was not in disagreement with the dynamic or static types approach, but that somehow I enjoyed both, and couldn’t reconcile this
			contradiction until some months ago, so I hope my experience can help you too.
			</p>

			<p>
			Going through a recent experience of moving from a consulting company (the one Martin Fowler works on) with good
			practices and TDD all the way, strong types and no runtime exceptions (Elm) to a Perl shop with no tests,
			no pull requests, nothing, I can tell you it felt like a roller coaster.
			</p>

			<p>
			At first I thought everything was wrong, and wanted to change it all, to play the consultant. But I decided
			not to stress out too much about work, and with time I actually started seeing the beauty in all that too, and the advantages
			this "move fast and break things" culture brought. Meanwhile, on the side, I was still having fun building Elm apps, learning
			about Haskell, curious about TLA+, writing tests for everything, etc. I felt conflicted, how is it that one can see beauty
			in both approaches? Which one do I think is the best?
			</p>

			<p>
			Luckily for me, I was also very interested in data, statistics, causality, etc, and somehow I think that lead me to read all
			the books by Nassim Taleb (one of my heroes now), but it was finally Kent Back (on top of Nassim's insights) that made it all
			click in place, from a similar experience at Facebook, with his 3X theory, which I really recommend you to watch if you haven't
			already: <a href="https://www.youtube.com/watch?v=FlJN6_4yI2A">https://www.youtube.com/watch?v=FlJN6_4yI2A</a>.
			</p>

			<p>
			I realised then that my views were actually not in contradiction at all, it was an obvious case of Consulting 101: "it depends".
			None of the approaches is the best one alone, they are conditional on the environment you are, the risks you face, what are you
			trying to achieve. You said "we are shaped by our scars", but I think we can (with a lot of effort) actually
			take a step back and acknowledge our scars as you did, and be mindful of what environments our experiences are conditional too, to
			try to see different paths that different people went, so you can experience that too and find other "local maxima".
			Having the two (or more) local maxima in your toolbelt in a way gets you closer to the global maxima :)
			</p>

			<p>
			I also wrote a blogpost, and happy to talk more about it if you are interested: <a href="https://rchavesferna.medium.com/designed-v-evolutionary-code-d52a54408c8f">https://rchavesferna.medium.com/designed-v-evolutionary-code-d52a54408c8f</a>
			</p>

			<p>
			Good luck on your journey <br>
			Cheers!
			</p>
		</div>
		<div class="comment-date">2021-08-11 09:44 UTC</div>
	</div>

	<div class="comment" id="51a93388e4fe499e9d953afb494ee43a">
		<div class="comment-author"><a href="/">Mark Seemann</a> <a href="#51a93388e4fe499e9d953afb494ee43a">#</a></div>
		<div class="comment-content">
			<p>
				tylerhou, thank you for writing. Yes, you're correct. I should have more explicitly stated that there's no algorithm to determine whether an arbitrary program in a Turing-complete language halts. This does highlight the importance of explicitly stating assumptions and preconditions, which I failed to fully do here.
			</p>
		</div>
		<div class="comment-date">2021-08-12 7:33 UTC</div>
	</div>
</div>
