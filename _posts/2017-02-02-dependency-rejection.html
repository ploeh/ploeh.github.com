---
layout: post
title: "Dependency rejection"
date: 2017-02-02 08:56 UTC
tags: [Software Design, Dependency Injection, F#, Haskell]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>In functional programming, the notion of dependencies must be rejected. Instead, applications should be composed from pure and impure functions.</em>
	</p>
	<p>
		This is the third article in a small article series called <a href="http://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection">from dependency injection to dependency rejection</a>. In the <a href="http://blog.ploeh.dk/2017/01/30/partial-application-is-dependency-injection">previous article in the series</a>, you learned that dependency injection can't be functional, because it makes everything impure. In this article, you'll see what to do instead.
	</p>
	<p>
		<strong>Indirect input and output</strong>
	</p>
	<p>
		One of the first concepts you learned when you learned to program was that units of operation (functions, methods, procedures) take input and produce output. Input is in the form or input parameters, and output is in the form of return values. (Sometimes, though, a method returns nothing, but we know from category theory that nothing is also a value (called <em>unit</em>).)
	</p>
	<p>
		In addition to such input and output, a unit with dependencies also take indirect input, and produce indirect output:
	</p>
	<p>
		<img src="/content/binary/unit-with-dependencies-and-direct-and-indirect-input-and-output.png" alt="A unit with dependencies and direct and indirect input and output.">
	</p>
	<p>
		When a unit queries a dependency for data, the data returned from the dependency is indirect input. In the restaurant reservation example used in this article series, when <code>tryAccept</code> calls <code>readReservations</code>, the returned reservations are indirect input.
	</p>
	<p>
		Likewise, when a unit invokes a dependency, all arguments passed to that dependency constitute indirect output. In the example, when <code>tryAccept</code> calls <code>createReservation</code>, the reservation value it uses as input argument to that function call becomes output. The intent, in this case, is to save the reservation in a database.
	</p>	
	<p>
		<strong>From indirect output to direct output</strong>
	</p>
	<p>
		Instead of producing indirect output, you can refactor functions to produce direct output.
	</p>
	<p>
		<img src="/content/binary/unit-with-dependencies-and-direct-input-and-output-but-no-indirect-output.png" alt="A unit with dependencies and direct input and output, but no indirect output.">
	</p>
	<p>
		Such a refactoring is often problematic in mainstream object-oriented languages like C# and Java, because you wish to control the circumstances in which the indirect output must be produced. Indirect output often implies side-effects, but perhaps the side-effect must only happen when certain conditions are fulfilled. In the restaurant reservation example, the desired side-effect is to add a reservation to a database, but this must only happen when the restaurant has sufficient remaining capacity to serve the requested number of people. Since languages like C# and Java are statement-based, it can be difficult to separate the decision from the action.
	</p>
	<p>
		In expression-based languages like F# and Haskell, <a href="http://blog.ploeh.dk/2016/09/26/decoupling-decisions-from-effects">it's trivial to decouple decisions from effects</a>.
	</p>
	<p>
		In the <a href="http://blog.ploeh.dk/2017/01/30/partial-application-is-dependency-injection">previous article</a>, you saw a version of <code>tryAccept</code> with this signature:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;int&nbsp;-&gt;&nbsp;(DateTimeOffset&nbsp;-&gt;&nbsp;Reservation&nbsp;list)&nbsp;-&gt;&nbsp;(Reservation&nbsp;-&gt;&nbsp;int)&nbsp;-&gt;&nbsp;Reservation</span>
<span style="color:green;">//&nbsp;-&gt;&nbsp;int&nbsp;option</span></pre>
	</p>
	<p>
		The second function argument, with the type <code>Reservation&nbsp;-&gt;&nbsp;int</code>, produces indirect output. The <code>Reservation</code> value is the output. The function even violates Command Query Separation and returns the database ID of the added reservation, so that's additional indirect input. The overall function returns <code>int option</code>: the database ID if the reservation was added, and <code>None</code> if it wasn't.
	</p>
	<p>
		Refactoring the indirect output to direct output is easy, then: just remove the <code>createReservation</code> function and return the <code>Reservation</code> value instead:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;int&nbsp;-&gt;&nbsp;(DateTimeOffset&nbsp;-&gt;&nbsp;Reservation&nbsp;list)&nbsp;-&gt;&nbsp;Reservation&nbsp;-&gt;&nbsp;Reservation&nbsp;option</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">tryAccept</span>&nbsp;capacity&nbsp;<span style="color:navy;">readReservations</span>&nbsp;reservation&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;reservedSeats&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">readReservations</span>&nbsp;reservation.Date&nbsp;|&gt;&nbsp;<span style="color:teal;">List</span>.<span style="color:navy;">sumBy</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Quantity)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;reservedSeats&nbsp;+&nbsp;reservation.Quantity&nbsp;&lt;=&nbsp;capacity
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;{&nbsp;reservation&nbsp;<span style="color:blue;">with</span>&nbsp;IsAccepted&nbsp;=&nbsp;<span style="color:blue;">true</span>&nbsp;}&nbsp;|&gt;&nbsp;<span style="color:navy;">Some</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;<span style="color:navy;">None</span></pre>
	</p>
	<p>
		Notice that this refactored version of <code>tryAccept</code> returns a <code>Reservation option</code> value. The implication is that the reservation was accepted if the return value is a <code>Some</code> case, and rejected if the value is <code>None</code>. The decision is embedded in the value, but decoupled from the side-effect of writing to the database.
	</p>
	<p>
		This function clearly never writes to the database, so at the boundary of your application, you'll have to connect the decision to the effect. To keep the example consistent with the previous article, you can do this in a <code>tryAcceptComposition</code> function, like this:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;Reservation&nbsp;-&gt;&nbsp;int&nbsp;option</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">tryAcceptComposition</span>&nbsp;reservation&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;reservation
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:navy;">tryAccept</span>&nbsp;10&nbsp;(<span style="color:teal;">DB</span>.<span style="color:navy;">readReservations</span>&nbsp;connectionString)
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:teal;">Option</span>.<span style="color:navy;">map</span>&nbsp;(<span style="color:teal;">DB</span>.<span style="color:navy;">createReservation</span>&nbsp;connectionString)</pre>
	</p>
	<p>
		Notice that the type of <code>tryAcceptComposition</code> remains <code>Reservation&nbsp;-&gt;&nbsp;int&nbsp;option</code>. This is a true refactoring. The overall API remains the same, as does the behaviour. The reservation is added to the database only if there's sufficient remaining capacity, and in that case, the ID of the reservation is returned.
	</p>
	<p>
		<strong>From indirect input to direct input</strong>
	</p>
	<p>
		Just as you can refactor from indirect output to direct output can you refactor from indirect input to direct input.
	</p>
	<p>
		<img src="/content/binary/unit-with-dependencies-and-direct-input-and-output.png" alt="A unit with dependencies and direct input and output.">
	</p>
	<p>
		Again, in statement-based languages like C# and Java, this may be problematic, because you may wish to defer a query, or base it on a decision inside the unit. In expression-based languages you can decouple decisions from effects, and deferred execution can always be done by lazy evaluation, if that's required. In the case of the current example, however, the refactoring is easy:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;int&nbsp;-&gt;&nbsp;Reservation&nbsp;list&nbsp;-&gt;&nbsp;Reservation&nbsp;-&gt;&nbsp;Reservation&nbsp;option</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">tryAccept</span>&nbsp;capacity&nbsp;reservations&nbsp;reservation&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;reservedSeats&nbsp;=&nbsp;reservations&nbsp;|&gt;&nbsp;<span style="color:teal;">List</span>.<span style="color:navy;">sumBy</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Quantity)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;reservedSeats&nbsp;+&nbsp;reservation.Quantity&nbsp;&lt;=&nbsp;capacity
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;{&nbsp;reservation&nbsp;<span style="color:blue;">with</span>&nbsp;IsAccepted&nbsp;=&nbsp;<span style="color:blue;">true</span>&nbsp;}&nbsp;|&gt;&nbsp;<span style="color:navy;">Some</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;<span style="color:navy;">None</span></pre>
	</p>
	<p>
		Instead of calling a (potentially impure) function, this version of <code>tryAccept</code> takes a list of existing reservations as input. It still sums over all the quantities, and the rest of the code is the same as before.
	</p>
	<p>
		Obviously, the list of existing reservations must come from somewhere, like a database, so <code>tryAcceptComposition</code> will still have to take care of that:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;(&#39;a&nbsp;-&gt;&nbsp;&#39;b&nbsp;-&gt;&nbsp;&#39;c)&nbsp;-&gt;&nbsp;&#39;b&nbsp;-&gt;&nbsp;&#39;a&nbsp;-&gt;&nbsp;&#39;c</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">flip</span>&nbsp;<span style="color:navy;">f</span>&nbsp;x&nbsp;y&nbsp;=&nbsp;<span style="color:navy;">f</span>&nbsp;y&nbsp;x
 
<span style="color:green;">//&nbsp;Reservation&nbsp;-&gt;&nbsp;int&nbsp;option</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">tryAcceptComposition</span>&nbsp;reservation&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;reservation.Date
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:teal;">DB</span>.<span style="color:navy;">readReservations</span>&nbsp;connectionString
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:navy;">flip</span>&nbsp;(<span style="color:navy;">tryAccept</span>&nbsp;10)&nbsp;reservation
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:teal;">Option</span>.<span style="color:navy;">map</span>&nbsp;(<span style="color:teal;">DB</span>.<span style="color:navy;">createReservation</span>&nbsp;connectionString)</pre>
	</p>
	<p>
		The type and behaviour of this composition is still the same as before, but the data flow is different. First, the function queries the database, which is an impure operation. Then, it pipes the resulting list of reservations to <code>tryAccept</code>, which is now a <a href="https://en.wikipedia.org/wiki/Pure_function">pure function</a>. It returns a <code>Reservation option</code> that's finally mapped to another impure operation, which writes the reservation to the database if the reservation was accepted.
	</p>
	<p>
		You'll notice that I also added a <code>flip</code> function in order to make the composition more concise, but I could also have used a lambda expression when invoking <code>tryAccept</code>. The <code>flip</code> function is a part of Haskell's standard library, but isn't in F#'s core library. It's not crucial to the example, though.
	</p>
	<p>
		<strong>Evaluation</strong>
	</p>
	<p>
		Did you notice that in the previous diagram, above, all arrows between the unit and its dependencies were gone? This means that the unit no longer has any dependencies:
	</p>
	<p>
		<img src="/content/binary/unit-with-direct-input-and-output.png" alt="A unit with direct input and output, but no dependencies.">
	</p>
	<p>
		Dependencies are, by their nature, impure, and since pure functions can't call impure functions, functional programming must reject the notion of dependencies. Pure functions can't <em>depend</em> on impure functions.
	</p>
	<p>
		Instead, pure functions must take direct input and produce direct output, and the impure boundary of an application must compose impure and pure functions together in order to achieve the desired behaviour.
	</p>
	<p>
		In the previous article, you saw how Haskell can be used to evaluate whether or not an implementation is functional. You can port the above F# code to Haskell to verify that this is the case.
	</p>
	<p>
		<pre><span style="color:#600277;">tryAccept</span>&nbsp;::&nbsp;Int&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[<span style="color:blue;">Reservation</span>]&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Reservation</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;Maybe&nbsp;<span style="color:blue;">Reservation</span>
tryAccept&nbsp;capacity&nbsp;reservations&nbsp;reservation&nbsp;<span style="color:#666666;">=</span>
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;reservedSeats&nbsp;<span style="color:#666666;">=</span>&nbsp;sum&nbsp;<span style="color:#666666;">$</span>&nbsp;map&nbsp;quantity&nbsp;reservations
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;&nbsp;<span style="color:#af00db;">if</span>&nbsp;reservedSeats&nbsp;<span style="color:#666666;">+</span>&nbsp;quantity&nbsp;reservation&nbsp;<span style="color:#666666;">&lt;=</span>&nbsp;capacity
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#af00db;">then</span>&nbsp;Just&nbsp;<span style="color:#666666;">$</span>&nbsp;reservation&nbsp;{&nbsp;isAccepted&nbsp;<span style="color:#666666;">=</span>&nbsp;True&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#af00db;">else</span>&nbsp;Nothing</pre>
	</p>
	<p>
		This version of <code>tryAccept</code> is pure, and compiles, but as you learned in the previous article, that's not the crucial question. The question is whether the composition compiles?
	</p>
	<p>
		<pre><span style="color:#600277;">tryAcceptComposition</span>&nbsp;::&nbsp;<span style="color:blue;">Reservation</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;IO&nbsp;(Maybe&nbsp;Int)
tryAcceptComposition&nbsp;reservation&nbsp;<span style="color:#666666;">=</span>&nbsp;runMaybeT&nbsp;<span style="color:#666666;">$</span>
&nbsp;&nbsp;liftIO&nbsp;(<span style="color:#dd0000;">DB</span><span style="color:#666666;">.</span>readReservations&nbsp;connectionString&nbsp;<span style="color:#666666;">$</span>&nbsp;date&nbsp;reservation)
&nbsp;&nbsp;<span style="color:#666666;">&gt;&gt;=</span>&nbsp;<span style="color:#dd0000;">MaybeT</span>&nbsp;<span style="color:#666666;">.</span>&nbsp;return&nbsp;<span style="color:#666666;">.</span>&nbsp;flip&nbsp;(tryAccept&nbsp;<span style="color:#09885a;">10</span>)&nbsp;reservation
&nbsp;&nbsp;<span style="color:#666666;">&gt;&gt;=</span>&nbsp;liftIO&nbsp;<span style="color:#666666;">.</span>&nbsp;<span style="color:#dd0000;">DB</span><span style="color:#666666;">.</span>createReservation&nbsp;connectionString</pre>
	</p>
	<p>
		This version of <code>tryAcceptComposition</code> compiles, and works as desired. The code exhibits a common pattern for Haskell: First, gather data from impure sources. Second, pass pure data to pure functions. Third, take the pure output from the pure functions, and do something impure with it.
	</p>
	<p>
		It's like a sandwich, with the best parts in the middle, and some necessary stuff surrounding it.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		Dependencies are, by nature, impure. They're either non-deterministic, have side-effects, or both. Pure functions can't call impure functions (because that would make them impure as well), so pure functions can't have dependencies. Functional programming must reject the notion of dependencies.
	</p>
	<p>
		Obviously, software is only useful with impure behaviour, so instead of injecting dependencies, functional programs must be composed in impure contexts. Impure functions can call pure functions, so at the boundary, an application must gather impure data, and use it to call pure functions. This <a href="http://blog.ploeh.dk/2016/03/18/functional-architecture-is-ports-and-adapters">automatically leads to the ports and adapters architecture</a>.
	</p>
</div>
<div id="comments">
<hr>
<h2 id="comments-header">Comments</h2>
	<div class="comment">
		<div class="comment-author"><a href="https://dusted.codes/">Dustin Moris Gorski</a></div>
		<div class="comment-content">
			<p>Hi, Thank you for this blog post series. I also read your other posts on ports and adapters and the proposed architecture makes sense in terms of how it works, but I struggle to see the benefit in a real world application. Maybe let me explain my question with a quick example.</p>
			<p>In the 2nd blog post of this series you demonstrated this function:</p>
			<pre><code>// int -&gt; (DateTimeOffset -&gt; Reservation list) -&gt; (Reservation -&gt; int) -&gt; Reservation
// -&gt; int option
let tryAccept capacity readReservations createReservation reservation =
    let reservedSeats =
        readReservations reservation.Date |&gt; List.sumBy (fun x -&gt; x.Quantity)
    if reservedSeats + reservation.Quantity &lt;= capacity
    then createReservation { reservation with IsAccepted = true } |&gt; Some
    else None</code></pre>
			<p>If I understand it correctly this function is pure if <code>readReservations</code> and <code>createReservation</code> are both pure otherwise it is impure.</p>
			<p>I also understand the benefit of having a pure function, because it is a lot easier to understand the code, test the code and reason about it. That makes sense as well :).</p>
			<p>So in the 3rd blog post you make <code>tryAccept</code> a pure function, by removing the function dependencies and replacing it with simple values:</p>
			<pre><code>// int -&gt; Reservation list -&gt; Reservation -&gt; Reservation option
let tryAccept capacity reservations reservation =
    let reservedSeats = reservations |&gt; List.sumBy (fun x -&gt; x.Quantity)
    if reservedSeats + reservation.Quantity &lt;= capacity
    then { reservation with IsAccepted = true } |&gt; Some
    else None</code></pre>
			<p>However this was only possible because you essentially moved the impure code into another new function:</p>
			<pre><code>// Reservation -&gt; int option
let tryAcceptComposition reservation =
    reservation.Date
    |&gt; DB.readReservations connectionString
    |&gt; flip (tryAccept 10) reservation
    |&gt; Option.map (DB.createReservation connectionString)</code></pre>
			<p>So after all the application hasn't really reduced the total number of impure functions (still 3 in each case - <code>readReservations</code>, <code>createReservation</code> and <code>tryAccept[Composition]</code>).</p>
			<p>The only difference I see is that one impure function has been refactored into 2 functions - one pure and one impure. Considering that the original <code>tryAccept</code> function was already fully testable from a unit testing point of view and quite readable what is the benefit of this additional step? I would almost argue that the original <code>tryAccept</code> function was even easier to read/understand than the combination of <code>tryAccept</code> and <code>tryAcceptComposition</code>. I understand that impure functions like this are not truly functional, but in a real world application you must have some impure functions and I would like to better understand where trade-off benefit of that additional step is? Am I missing something else?</p>
			<p></p>
		</div>
		<div class="comment-date">2017-02-03 10:34 UTC</div>
	</div>
	<div class="comment">
		<div class="comment-author">
			<a href="http://blog.ploeh.dk">Mark Seemann</a>
		</div>
		<div class="comment-content">
		</div>
			<p>
				Dustin, thank you for writing. There are several answers to your question, depending on the perspective one is interested in. I'll see if I can cover the most important ones.
			</p>
			<p>
				<strong>Is it functional?</strong>
			</p>
			<p>
				On the most fundamental level, I'm interested in learning functional programming. In order to do this, I seek out strictly functional solutions to problems. Haskell is a great help in that endeavour, because it's not a hybrid language. It only allows you to do functional programming.
			</p>
			<p>
				Does it make sense to back-port Haskell solutions to F#, then? That depends on what one is trying to accomplish, but if the goal is nothing but learning how to do it functionally, then that goal is accomplished.
			</p>
			<p>
				<strong>Toy examples</strong>
			</p>
			<p>
				On another level, the example I've presented here is obviously nothing but a toy example. It's simplified, because if I presented readers with a more realistic example, the complexity of the real problem could easily drown out the message of the example. Additionally, most readers would probably give up reading.
			</p>
			<p>
				I'm asking my readers to pretend that the problem is more complex than the one I present here; pretend that this problem is a stand-in for a harder problem.
			</p>
			<p>
				In this particular context, there could be all sorts of complications:
				<ul>
					<li>
						Reservations could be for time slots instead of whole dates. In order to keep the example simple, I treat each reservation as simply blocking out an entire date. I once dined at a restaurant where they started serving at 19:00, and if you weren't there on time, you'd miss the first courses. Most restaurants, though, allow you to make reservations for a particular time, and many have more than one serving on a single evening.
					</li>
					<li>
						Most restaurants have tables, not seats. Again, the same restaurant I mentioned above seated 12 people at a bar-like arrangement facing the kitchen, but most restaurants have tables of varying sizes. If they get a reservation for three people, they may have to reserve a table for four.
					</li>
					<li>
						Perhaps the restaurant would like to implement a feature where, if it receives a reservation that doesn't fill out a table (like a reservation for three people, and only four-people tables are left), it'd defer the decision to see if a 'better' reservation arrives later.
					</li>
					<li>
						Some people make reservations, but never show up. For that reason, a restaurant may want to allow a degree of overbooking, just like airlines. How much overbooking to allow is a business decision.
					</li>
					<li>
						A further wrinkle on the overbooking business rule is that you may have a different overbooking policy for Fridays than for, say, Wednesdays.
					</li>
					<li>
						Perhaps the restaurant would like to implement a waiting-list feature as well.
					</li>
				</ul>
				As you can see, we could easily imagine that the business logic could be more convoluted. Keeping all of that decision logic pure would be beneficial.
			</p>
			<p>
				<strong>Separation of concerns</strong>
			</p>
			<p>
				In my experience, there's an entire category of software defects that occur because of state mutation in business logic. You could have an area of your code that calls other code, which calls other code, and so on, for several levels of nesting. Somewhere, deep in the bowels of such a system, a conditional statement flips a boolean flag that consequently impact how the rest of the program runs. I've seen plenty of examples of such software, and it's inhumane; it doesn't fit within human cognitive limits.
			</p>
			<p>
				Code that allows arbitrary side-effects is difficult to reason about.
			</p>
			<p>
				Knowing that an subgraph of your call tree is pure reduces defects like that. This is nothing but another way to restate the <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">command-query separation</a> principle. In F#, we still can't be sure unless we exert some discipline, but in Haskell, all it takes is a look at the type of a function or value. If it doesn't include <code>IO</code>, you know that it's pure.
			</p>
			<p>
				Separating pure code from impure code is separation of concern. Business logic is one concern, and I/O is another concern, and the better you can separate these, the fewer sources of defects you'll have. True, I haven't reduced the amount of code by much, but I've <em>separated</em> concerns by separating the code that contains (side) effects from the pure code.
			</p>
			<p>
				<strong>Testability</strong>
			</p>
			<p>
				It's true that the partial application version of <code>tryAccept</code> is <a href="http://blog.ploeh.dk/2015/05/07/functional-design-is-intrinsically-testable">testable, because it has isolation</a>, but the tests are more complicated than they have to be:
			</p>
			<p>
				<pre>[&lt;<span style="color:teal;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``tryAccept&nbsp;behaves&nbsp;correctly&nbsp;when&nbsp;it&nbsp;can&nbsp;accept``</span>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:navy;">NonNegativeInt</span>&nbsp;excessCapacity)
&nbsp;&nbsp;&nbsp;&nbsp;(expected&nbsp;:&nbsp;<span style="color:teal;">int</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">Tuple2</span>.<span style="color:navy;">curry</span>&nbsp;<span style="color:navy;">id</span>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;!&gt;&nbsp;<span style="color:teal;">Gen</span>.reservation
&nbsp;&nbsp;&nbsp;&nbsp;&lt;*&gt;&nbsp;<span style="color:teal;">Gen</span>.<span style="color:navy;">listOf</span>&nbsp;<span style="color:teal;">Gen</span>.reservation
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;&nbsp;<span style="color:teal;">Arb</span>.<span style="color:navy;">fromGen</span>&nbsp;|&gt;&nbsp;<span style="color:teal;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;(reservation,&nbsp;reservations)&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;capacity&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;excessCapacity
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;(reservations&nbsp;|&gt;&nbsp;<span style="color:teal;">List</span>.<span style="color:navy;">sumBy</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Quantity))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;reservation.Quantity
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">readReservations</span>&nbsp;=&nbsp;((=!)&nbsp;reservation.Date)&nbsp;&gt;&gt;!&nbsp;reservations
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">createReservation</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=!)&nbsp;{&nbsp;reservation&nbsp;<span style="color:blue;">with</span>&nbsp;IsAccepted&nbsp;=&nbsp;<span style="color:blue;">true</span>&nbsp;})&nbsp;&gt;&gt;!&nbsp;expected
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">tryAccept</span>&nbsp;capacity&nbsp;<span style="color:navy;">readReservations</span>&nbsp;<span style="color:navy;">createReservation</span>&nbsp;reservation
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">Some</span>&nbsp;expected&nbsp;=!&nbsp;actual
 
[&lt;<span style="color:teal;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``tryAccept&nbsp;behaves&nbsp;correctly&nbsp;when&nbsp;it&nbsp;can&#39;t&nbsp;accept``</span>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:navy;">PositiveInt</span>&nbsp;lackingCapacity)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">Tuple2</span>.<span style="color:navy;">curry</span>&nbsp;<span style="color:navy;">id</span>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;!&gt;&nbsp;<span style="color:teal;">Gen</span>.reservation
&nbsp;&nbsp;&nbsp;&nbsp;&lt;*&gt;&nbsp;<span style="color:teal;">Gen</span>.<span style="color:navy;">listOf</span>&nbsp;<span style="color:teal;">Gen</span>.reservation
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;&nbsp;<span style="color:teal;">Arb</span>.<span style="color:navy;">fromGen</span>&nbsp;|&gt;&nbsp;<span style="color:teal;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;(reservation,&nbsp;reservations)&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;capacity&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reservations&nbsp;|&gt;&nbsp;<span style="color:teal;">List</span>.<span style="color:navy;">sumBy</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Quantity))&nbsp;-&nbsp;lackingCapacity
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">readReservations</span>&nbsp;_&nbsp;=&nbsp;reservations
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">createReservation</span>&nbsp;_&nbsp;=&nbsp;<span style="color:navy;">failwith</span>&nbsp;<span style="color:#a31515;">&quot;Mock&nbsp;shouldn&#39;t&nbsp;be&nbsp;called.&quot;</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">tryAccept</span>&nbsp;capacity&nbsp;<span style="color:navy;">readReservations</span>&nbsp;<span style="color:navy;">createReservation</span>&nbsp;reservation
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">None</span>&nbsp;=!&nbsp;actual</pre>
			</p>
			<p>
				(You can find these tests in <a href="https://github.com/ploeh/dependency-rejection-samples/commit/d2387cceb81eabc349a63ab7df1249236e9b1d13">commit d2387cceb81eabc349a63ab7df1249236e9b1d13 in the accompanying sample code repository</a>.) Contrast those dependency-injection style tests to these tests against the pure version of <code>tryAccept</code>:
			</p>
			<p>
				<pre>[&lt;<span style="color:teal;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``tryAccept&nbsp;behaves&nbsp;correctly&nbsp;when&nbsp;it&nbsp;can&nbsp;accept``</span>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:navy;">NonNegativeInt</span>&nbsp;excessCapacity)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">Tuple2</span>.<span style="color:navy;">curry</span>&nbsp;<span style="color:navy;">id</span>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;!&gt;&nbsp;<span style="color:teal;">Gen</span>.reservation
&nbsp;&nbsp;&nbsp;&nbsp;&lt;*&gt;&nbsp;<span style="color:teal;">Gen</span>.<span style="color:navy;">listOf</span>&nbsp;<span style="color:teal;">Gen</span>.reservation
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;&nbsp;<span style="color:teal;">Arb</span>.<span style="color:navy;">fromGen</span>&nbsp;|&gt;&nbsp;<span style="color:teal;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;(reservation,&nbsp;reservations)&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;capacity&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;excessCapacity
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;(reservations&nbsp;|&gt;&nbsp;<span style="color:teal;">List</span>.<span style="color:navy;">sumBy</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Quantity))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;reservation.Quantity
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:navy;">tryAccept</span>&nbsp;capacity&nbsp;reservations&nbsp;reservation
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">Some</span>&nbsp;{&nbsp;reservation&nbsp;<span style="color:blue;">with</span>&nbsp;IsAccepted&nbsp;=&nbsp;<span style="color:blue;">true</span>&nbsp;}&nbsp;=!&nbsp;actual
 
[&lt;<span style="color:teal;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``tryAccept&nbsp;behaves&nbsp;correctly&nbsp;when&nbsp;it&nbsp;can&#39;t&nbsp;accept``</span>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:navy;">PositiveInt</span>&nbsp;lackingCapacity)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">Tuple2</span>.<span style="color:navy;">curry</span>&nbsp;<span style="color:navy;">id</span>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;!&gt;&nbsp;<span style="color:teal;">Gen</span>.reservation
&nbsp;&nbsp;&nbsp;&nbsp;&lt;*&gt;&nbsp;<span style="color:teal;">Gen</span>.<span style="color:navy;">listOf</span>&nbsp;<span style="color:teal;">Gen</span>.reservation
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;&nbsp;<span style="color:teal;">Arb</span>.<span style="color:navy;">fromGen</span>&nbsp;|&gt;&nbsp;<span style="color:teal;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;(reservation,&nbsp;reservations)&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;capacity&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reservations&nbsp;|&gt;&nbsp;<span style="color:teal;">List</span>.<span style="color:navy;">sumBy</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Quantity))&nbsp;-&nbsp;lackingCapacity
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:navy;">tryAccept</span>&nbsp;capacity&nbsp;reservations&nbsp;reservation
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">None</span>&nbsp;=!&nbsp;actual</pre>
			</p>
			<p>
				They're simpler, and since they don't use <a href="http://xunitpatterns.com/Mock%20Object.html">mocks</a>, they're more robust. They were easier to write, and I subscribe to the spirit of <a href="http://amzn.to/SM8Yv0">GOOS</a>: <em>if test are difficult to write, the system under test should be simplified</em>.
			</p>
		<div class="comment-date">2017-02-05 20:09 UTC</div>
	</div>

	<div class="comment">
		<div class="comment-author"><a href="http://stackoverflow.com/users/1523776/benjamin-hodgson?tab=profile">Benjamin Hodgson</a></div>
		<div class="comment-content">
			<p>Hi Mark,</p>
			<p>Thanks for your talk at NDC last month, and for writing this series! I feel that the functional community (myself included) has a habit of using examples that aren't obviously relevant to the sort of line-of-business programming most of us do in our day jobs, so articles like this are sorely needed.</p>
			<p>We talked a little about this in person after your talk at the conference: I wanted to highlight a potential criticism of this style of programming. Namely, there's still some important business logic being carried out by your <code>tryAcceptComposition</code> function, like checking the capacity <i>on the requested reservation date</i>. How do you unit test that <code>readReservations</code> is called with the correct date? Likewise, how do you unit test that rejected reservations don't get saved? Real world business logic isn't always purely functional in nature. Sometimes the side effects that your code performs are part of the requirements.</p>
			<p>The Haskell philosophy isn't about rejecting side effects outright - it's about measuring and controlling them. I wouldn't write <code>tryAcceptComposition</code> using <code>IO</code>. Instead I'd program to the interface, not the implementation, using an mtl-style class to abstract over monads which support saving and loading reservations.</p>
			<pre><code>class Monad m =&gt; MonadReservation m where
    readReservations :: ConnectionString -&gt; Date -&gt; m [Reservation]
    createReservation :: ConnectionString -&gt; Reservation -&gt; m ReservationId


tryAcceptComposition :: MonadReservation m =&gt; Reservation -&gt; m (Maybe ReservationId)
tryAcceptComposition r = runMaybeT $ do
    reservations &lt;- lift $ readReservations connectionString (date r)
    accepted &lt;- MaybeT $ return $ tryAccept 10 reservations r
    lift $ createReservation connectionString accepted</code></pre>
			<p>Code that lives in a <code>MonadReservation</code> context can read and create reservations in the database but nothing else; it doesn't have all the power of <code>IO</code>. During unit testing I can use an instance of <code>MonadReservation</code> that returns canned values, and in production I can use a monad that actually talks to the database.</p>
			<p>Since type classes are syntactic sugar for passing an argument, this is really just a nicer way of writing your original DI-style code. I don't advocate the "free monad" style that's presently trendy in Scala-land because I find it unnecessarily complex. 90% of the purported advantages of free monads are already supported by simpler language features.</p>
			<p>I suppose the main downside of this design is that you can't express it in F#, at least not cleanly. It relies on type classes and higher-kinded types.</p>
			<p>Hope you find this interesting, I'd love to hear what you think!</p>
			<p>Benjamin</p>
		</div>
		<div class="comment-date">2017-02-06 16:28 UTC</div>
	</div>

	<div class="comment">
		<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Benjamin, thank you for writing. The alternative you propose looks useful in Haskell, but, as you've already suggested, it doesn't translate well into F#.
			</p>
			<p>
				I write F# code professionally, whereas so far, I've only used Haskell to critique my F# code. (If someone who reads this comment would offer to pay me to write some Haskell code, please get in touch.) In other words, I still have much to learn about Haskell. I think I understand as much, however, that I'd be able to use your suggested design to unit test <code>tryAcceptComposition</code> using the <code>Identity</code> monad for Stubs, or perhaps <code>MonadWriter</code> or <code>MonadState</code> for Mocks. I'll have to try that one day...
			</p>
			<p>
				In F#, I write integration tests. Such tests are important regardless, and often they more closely relate to actual requirements, so I find this a worthwhile effort anyway.
			</p>
		</div>
		<div class="comment-date">2017-02-11 22:42 UTC</div>
	</div>
</div>
