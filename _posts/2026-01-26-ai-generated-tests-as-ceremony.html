---
layout: post
title: "AI-generated tests as ceremony"
description: "On epistemological soundness of using LLMs to generate automated tests."
date: 2026-01-26 9:05 UTC
tags: [Productivity]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        For decades, software development <a href="https://x.com/hillelogram/status/1445435617047990273">thought leaders</a> have tried to convince the industry that test-driven development (TDD) should be the norm. <a href="/2025/10/20/epistemology-of-software">I think so too</a>. Even so, the majority of developers don't use TDD. If they write tests, they add them after having written production code.
    </p>
    <p>
        With the rise of <a href="https://en.wikipedia.org/wiki/Large_language_model">large language models</a> (LLMs, so-called AI) many developers see new opportunities: Let LLMs write the tests.
    </p>
    <p>
        Is this a good idea?
    </p>
    <p>
        After having thought about this for some time, I've come to the interim conclusion that it seems to be missing the point. It's tests as ceremony, rather than <a href="/2025/10/20/epistemology-of-software">tests as an application of the scientific method</a>.
    </p>
    <h3 id="1ff6fbf8c9e14618bc1a831b92ebbb66">
        How do you know that LLM-generated code works? <a href="#1ff6fbf8c9e14618bc1a831b92ebbb66">#</a>
    </h3>
    <p>
        People who are enthusiastic about using LLMs for programming often emphasise the the amount of code they can produce. <a href="/2025/09/22/its-striking-so-quickly-the-industry-forgets-that-lines-of-code-isnt-a-measure-of-productivity">It's striking so quickly the industry forgets that lines of code isn't a measure of productivity</a>. We already had trouble with the amount of code that existed back when humans wrote it. Why do we think that accelerating this process is going to be an improvement?
    </p>
    <p>
        When people wax lyrical about all the code that LLMs generated, I usually ask: <em>How do you know that it works?</em> To which the most common answer seems to be: I looked at the code, and it's fine.
    </p>
    <p>
        This is where the discussion becomes difficult, because it's hard to respond to this claim without risking offending people. For what it's worth, I've personally looked at much code and deemed it correct, only to later discover that it contained defects. How do people think that bugs make it past code review and into production?
    </p>
    <p>
        It's as if some variant of <a href="https://en.wikipedia.org/wiki/Gell-Mann_amnesia_effect">Gell-Mann amnesia</a> is at work. Whenever a bug makes it into production, you acknowledge that it 'slipped past' vigilant efforts of quality assurance, but as soon as you've fixed the problem, you go back to believing that code-reading can prevent defects.
    </p>
    <p>
        To be clear, I'm a big proponent of code reviews. To <a href="/2020/05/25/wheres-the-science">the degree that any science is done in this field</a>, research indicates that it's one of the better ways of catching bugs early. My own experience supports this to a degree, but an effective code review is a concentrated effort. It's not a cursory scan over dozens of code files, followed by LGTM.
    </p>
    <p>
        The world isn't black or white. There are stories of LLMs producing near-ready forms-over-data applications. Granted, this type of code is often repetitive, but uncomplicated. It's conceivable that if the code looks reasonable and smoke tests indicate that the application works, it most likely does. Furthermore, not all software is born equal. In <a href="/2018/11/12/what-to-test-and-not-to-test">some systems, errors are catastrophic, whereas in others, they're merely inconveniences</a>.
    </p>
    <p>
        There's little doubt that LLM-generated software is part of our future. This, in itself, may or may not be fine. We still need, however, to figure out how that impacts development processes. What does it mean, for example, related to software testing?
    </p>
    <h3 id="f4fc01e761264964bf73e5f4001e489c">
        Using LLMs to generate tests <a href="#f4fc01e761264964bf73e5f4001e489c">#</a>
    </h3>
    <p>
        Since automated tests, such as unit tests, are written in a programming language, the practice of automated testing has always been burdened with the obvious question: If we write code to test code, how do we know that the test code works? <a href="http://en.wikipedia.org/wiki/Quis_custodiet_ipsos_custodes%3F">Who watches the watchmen?</a> Is it going to be <a href="http://en.wikipedia.org/wiki/Turtles_all_the_way_down">turtles all the way down</a>?
    </p>
    <p>
        The answer, as argued in <a href="/2025/10/20/epistemology-of-software">Epistemology of software</a>, is that seeing a test fail is an example of the scientific method. It corroborates the (often unstated, implied) hypothesis that a new test, of a feature not yet implemented, should fail, thereby demonstrating the need for adding code to the System Under Test (SUT). This doesn't <em>prove</em> that the test is correct, but increases our rational belief that it is.
    </p>
    <p>
        When using LLMs to generate tests for existing code, you skip this step. How do you know, then, that the generated test code is correct? That all tests pass is hardly a useful criterion. Looking at the test code may catch obvious errors, but again: Those people who already view automated tests as a chore to be done with aren't likely to perform a thorough code reading. And even a proper review may fail to unearth problems, such as <a href="/2019/10/14/tautological-assertion">tautological assertions</a>.
    </p>
    <p>
        Rather, using LLMs to generate tests may lull you into a false sense of security. After all, now you have tests.
    </p>
    <p>
        What is missing from this process is an understanding of why tests work in the first place. Tests work best when you have seen them fail.
    </p>
    <h3 id="a78b57c393f941a9a879e7a19ccf61cc">
        Toward epistemological soundness <a href="#a78b57c393f941a9a879e7a19ccf61cc">#</a>
    </h3>
    <p>
        Is there a way to take advantage of LLMs when writing tests? This is clearly a field where we have yet to discover better practices. Until then, here are a few ideas.
    </p>
    <p>
        When writing tests after production code, you can still apply <a href="/2025/11/03/empirical-characterization-testing">empirical Characterization Testing</a>. In this process, you deliberately temporarily sabotage the SUT to see a test fail, and then revert that change. When using LLM-generated tests, you can still do this.
    </p>
    <p>
        Obviously, this requires more work, and takes more time, than 'just' asking an LLM to generate tests, run them, and check them in, but it would put you on epistemologically safer ground.
    </p>
    <p>
        Another option is to ask LLMs to follow TDD. On what's left of technical social media, I see occasional noises indicating that people are doing this. Again, however, I think the devil is in the details. What is the actual process when asking an LLM to follow TDD?
    </p>
    <p>
        Do you ask the LLM to write a test, then review the test, run it, and see it fail? Then stage the code changes? Then ask the LLM to pass the test? Then verify that the LLM <em>did not</em> change the test while passing it? Review the additional code change? Commit and repeat? If so, this sounds epistemologically sound.
    </p>
    <p>
        If, on the other hand, you let it go in a fast loop where the only observations your human brain can keep up with is that test status oscillates between red and green, then you're back to where we started: This is essentially ex-post tests with extra ceremony.
    </p>
    <h3 id="22986a515b8c4deba31dcc59501465c1">
        Cargo-cult testing <a href="#22986a515b8c4deba31dcc59501465c1">#</a>
    </h3>
    <p>
        These days, most programmers have heard about <a href="https://en.wikipedia.org/wiki/Cargo_cult_programming">cargo-cult programming</a>, where coders perform ceremonies hoping for favourable outcomes, confusing cause and effect.
    </p>
    <p>
        Having LLMs write unit tests strikes me as a process with little epistemological content. Imagine, for the sake of argument, that the LLM never produces code in a high-level programming language. Instead, it goes straight to machine code. Assuming that you don't read machine code, how much would you trust the generated system? Would you trust it more if you asked the LLM to write tests? What does a test program even indicate? You may be given a program that ostensibly tests the system, but how do you know that it isn't a simulation? A program that only looks as though it runs tests, but is, in fact, unrelated to the actual system?
    </p>
    <p>
        You may find that a contrived thought experiment, but this is effectively the definition of <a href="https://en.wikipedia.org/wiki/Vibe_coding">vibe coding</a>. You don't inspect the generated code, so the language becomes functionally irrelevant.
    </p>
    <p>
        Without human engagement, tests strike me as mere ceremony.
    </p>
    <h3 id="a30e7891e7494761ab593f851cb5dd81">
        Ways forward <a href="#a30e7891e7494761ab593f851cb5dd81">#</a>
    </h3>
    <p>
        It would be naive of me to believe that programmers stop using LLMs to generate code, including unit tests. Are there techniques we can apply to put software development back on more solid footing?
    </p>
    <p>
        As always when new technology enters the picture, we've yet to discover efficient practices. Meanwhile, we may attempt to apply the knowledge and experience we have from the old ways of doing things.
    </p>
    <p>
        I've already outlined a few technique to keep you on good epistemological footing, but I surmise that people who already find writing tests a chore aren't going to take the time to systematically apply the techniques for empirical Characterization Testing.
    </p>
    <p>
        Another option is to turn the tables. Instead of writing production code and asking LLMs to write tests, why not write tests, and ask LLMs to implement the SUT? This would entail a mostly <a href="/2025/09/15/greyscale-box-test-driven-development">black-box approach to TDD</a>, but still seems scientific to me.
    </p>
    <p>
        For some reason I've never understood, however, most people dislike writing tests, so this is probably unrealistic, too. As a supplement, then, we should explore ways to critique tests.
    </p>
    <h3 id="ae3876d0b61846dcb5b702ed38c49a69">
        Conclusion <a href="#ae3876d0b61846dcb5b702ed38c49a69">#</a>
    </h3>
    <p>
        It may seem alluring to let LLMs relieve you of the burden it is to write automated tests. If, however, you don't engage with the tests it generates, you can't tell what guarantees they give. If so, what benefits do the tests provide? Do automated testing become mere ceremony, intended to give you a nice warm feeling with little real protection?
    </p>
    <p>
        I think that there are ways around this problem, some of which are already in view, but some of which we have probably yet to discover.
    </p>
</div>