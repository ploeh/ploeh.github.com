---
layout: post
title: "A reading of Extensibility for the Masses"
description: "A paper read and translated to C#."
date: 2021-07-12 5:36 UTC
tags: [Software Design, Design Patterns]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		When I have the time (and I do make this a priority) I set aside an hour every day to study. Lately I've been using these time slots to read and reproduce the code in the 2012 paper <em>"Extensibility for the Masses. Practical Extensibility with Object Algebras"</em> by Bruno C. d. S. Oliveira and William R. Cook. As is often common with academic papers, they don't have a single, authoritative address on the internet. You can find the paper in various places. I've used <a href="https://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf">a copy hosted by University of Texas</a>, which is the institution with which William R. Cook is associated.
	</p>
	<p>
		While the example code in the paper is in Java, the authors claim that it translates easily to C#. I decided to give this a try, and found it to be true.
	</p>
	<h3 id="673345bb9c48466790a40e4c5e239240">
		Git repository <a href="#673345bb9c48466790a40e4c5e239240" title="permalink">#</a>
	</h3>
	<p>
		From the beginning I created <a href="https://github.com/ploeh/ExtensibilityForMasses">a Git repository</a> with an eye to publishing it in case anyone was interested in looking over my shoulder. Not only can you see the 'final' translation, but you can also follow along with each commit.
	</p>
	<p>
		I committed each time I had something that seemed to work. When I struggled to understand how to interpret some of the code, I left detailed commit messages describing my doubts, and explaining why I had chosen to interpret things in a particular way.
	</p>
	<p>
		Along the way I also added automated tests, because I found that the paper lacked examples. Those tests represent my own interpretation of the code in the paper, and how one is supposed to use it. In total, I wrote 75 test cases.
	</p>
	<h3 id="05a8b46089be4fed9ead17648df68bef">
		Help from one of the authors <a href="#05a8b46089be4fed9ead17648df68bef" title="permalink">#</a>
	</h3>
	<p>
		At one time I hit a snag that I couldn't readily resolve. After searching the web in vain, I posted <a href="https://stackoverflow.com/q/67818254/126014">a question on Stack Overflow</a>. After a few days, I got an answer from Bruno C. d. S. Oliveira, one of the authors of the paper!
	</p>
	<p>
		It turns out that some of my confusion stemmed from an otherwise inconsequential error in the paper. We shouldn't be shocked that an academic paper contains errors. One of many things I learned from reading Charles Petzold's excellent book <a href="http://amzn.to/2n9MFGh">The Annotated Turing</a> was that later researchers found several errors in Turing's 1936 paper, but none that changed the overall conclusion. So it seems to be here as well. There's at least one confirmed error (and another one that I only suspect), but it's inconsequential and easily corrected.
	</p>
	<p>
		It does, however, raise a point about scientific papers in general: Even if they're peer-reviewed they may contain errors. I'm <a href="/2020/05/25/wheres-the-science">much in favour of scientific knowledge, but also sceptical about some claims about computer science and software engineering</a>.
	</p>
	<h3 id="1cd1086ddbe84c83910dddad451efdbc">
		Readability <a href="#1cd1086ddbe84c83910dddad451efdbc" title="permalink">#</a>
	</h3>
	<p>
		The paper's title claims to give extensibility to the masses, but will 'the masses' be able to read the paper? As papers go, I found this one quite readable. While other papers present their examples in <a href="https://www.haskell.org">Haskell</a>, this one uses Java. If you're comfortable with Java (or C#), you should be able to follow the code examples (or my C# translation).
	</p>
	<p>
		You won't entirely escape Greek letters or other <a href="/2021/06/07/abstruse-nomenclature">abstruse nomenclature</a>. This is, after all, an academic paper, so it can't be lucid all the way through. There's a section called <em>Algebraic Signatures, F-Algebras, and Church Encodings</em> that is definitely not for 'the masses'. I understand enough about <a href="https://bartoszmilewski.com/2017/02/28/f-algebras/">F-algebras</a> and <a href="/2018/05/22/church-encoding">Church encodings</a> to follow the outline of this section, but I didn't find it helpful.
	</p>
	<p>
		If you're interested in the overall article, but don't know what these words mean, I suggest you skim those parts and pay as much attention to the details as when <a href="https://en.wikipedia.org/wiki/Geordi_La_Forge">Geordi La Forge</a> spews <a href="https://en.wikipedia.org/wiki/Technobabble">technobabble</a>. In other words, I think you can follow the rest of the article just was well, even if <em>Church<sub>Σ</sub> = ∀A.(T<sub>1</sub> → A) × ... × (T<sub>n</sub> → A) → A</em> makes no sense to you.
	</p>
	<h3 id="c42c389e557a47848d4c66af477297ca">
		Conclusion <a href="#c42c389e557a47848d4c66af477297ca" title="permalink">#</a>
	</h3>
	<p>
		Does the paper deliver on its promise? Yes and no. Formally, I think that it does. In the beginning, it establishes some criteria for a successful solution, and as far as I can tell, it can check off all of them.
	</p>
	<p>
		It's also true that the proposed solution requires only intermediary language features. Generics and inheritance, as they're available in C# and Java, is all that's required.
	</p>
	<p>
		On the other hand, I don't find the paper's examples compelling. Few 'mass developers' are tasked with implementing a simple expression-based language. I can't shake the feeling that most of what the paper accomplishes could be handled with tasty application of composition and the <a href="https://en.wikipedia.org/wiki/Adapter_pattern">Adapter pattern</a>.
	</p>
	<p>
		Still, I'll keep this paper in mind if I ever have to publish a reusable and extensible, type-safe software library.
	</p>
</div>

<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	
	<div class="comment" id="eddd9051446447b8ae4831a703c1ccbf">
		<div class="comment-author"><a href="https://github.com/Joker-vD">Joker_vD</a> <a href="#eddd9051446447b8ae4831a703c1ccbf">#</a></div>
		<div class="comment-content">
			<p>
				I was intrigued by the paper's abstract, but then it turned out it's just about implementing Oleg Kiselyov's final (typed, tagless) encoding
				in plain boring Java/C# &mdash; the most surprising thing is that it doesn't really mention Kiselyov's work which predates this paper by 3-4
				years. And Kiselyov in his writings moslty used really basic Haskell features so translating it to Java/C# is pretty straightforward, I
				actually did with it the last Autumn, toying with the idea, so I feel this paper could very well have been a (small) blog post, really. Anyway,
				let's talk about the proposed solution itself.
			</p>
			
			<p>
				And the solution is actually pretty ingenious! The conventional approach to representing AST and writing interpreters (in broad sense) for it
				is to represent AST as a tree of objects, and interpret it by walking this tree over, doing the work in the process. The problem is that to
				add a new kind of node to AST you need to patch all existing intepreters, and writing an interpreter involves either manual dynamic dispatch
				on the node types in the interpreter's code, or trying to shift it onto the nodes itself somehow (cf. Visitor pattern).
			</p>
			
			<p>
				The proposed solution neatly side steps the whole problem of representing an AST by simply not representing it as a piece of data <b>at all</b>,
				it instead interprets a (would-be) AST right at the moment of the construction. And so the interpreters &mdash; instead of being written as
				vistors &mdash; are written as builders that build the resulting value.
			</p>
			
			<p>
				As I said, it's very ingenious but it is also, sadly, largely pointless. You see, it all largely started with the Haskell programmers trying to make
				ASTs more statically typed to get rid of as many runtime checks and "this case is impossible" in switches in the interpreters: you have to check
				that e.g. the <code>if</code>'s condition (which is usually just a plain <code>Expr</code>) must evaluate to boolean, but if you make its type
				some sort of <code>Expr&lt;BoolType&rt;</code>, the Haskell's typechecker won't allow you to build a malformed AST in the first place! It led to
				introduction of GADTs, then to extending GADTs even further, and I guess at some point some people started feeling kinda uneasy about going this
				close to the full-blown dependent types, and so the tagless final encoding was born: as I said in the beginning, it uses very boring and
				straightforward Haskell features &mdash; parametric polymorphism and typeclasses &mdash; or, as they're more widely known, generics and interfaces.
				But then again, as it evolved, it too started require language extensions although not as radical as in previous cases, and at some point waded into
				the esoteric type-level meta-programming territory.
			</p>
			
			<p>
				So here's the pointless part: the initial goal was to push type-checking of the (mini-)language being implemented onto the Haskell's typechecker, and
				it makes implementing small, typed mini-languages that are essentially Haskell's subset <i>very</i> easy, but... if you program in Haskell, what do
				you need this toy of a language for? And do its types/semantics really align that well with Haskell's? If they don't, this whole ordeal becomes very
				difficult: imagine a language with three variables (<code>A</code>, <code>B</code>, and <code>C</code>) that can hold either integers or booleans,
				constants, assignments, basic arithmetic and comparison operators, <code>if-then-else</code> statement and <code>while</code> loop. Trying to encode
				it in Haskell type-safely (so that variables would have consistent types after all branches/loops' ends) is pretty non-trivial, whether you use GADTs
				or the approach from the paper. I've seen a blogpost where this exact excercise was done, and it was done in Coq, with essential use of dependent typing.
			</p>
			
			<p>
				And trying to pull this off in a language like Java/C# with much more limited type-system is, I would argue, fundamentally misguided. Eric Lippert has
				summed it quite well in his "Wizards and warriors, part five":
			</p>
			
			<quote>
				We have no reason to believe that the C# type system was designed to have sufficient generality to encode the rules of Dungeons &amp; Dragons, so why
				are we even trying?
			</quote>
			
			<p>
				Then, of course, there is a problem that in this approach, AST does not actually exist as an object: it's represented as a function/method. If the
				interpreter you write needs multiple passes over AST, I am afraid you'll have to materialize your AST and AFAIK you can't really fine-tune or optimize
				the representation of closures in Java/C#. Of course, if you <i>don't</i> need multiple passes, then this approach is perfectly fine, and in fact, that's
				actually how one-pass compilers are usually structured: the parser straight up calls the code-generating hooks, and when it's done, the code-gen is done.
			</p>
			
			<p>
				And when it comes down to actual extensibility, that is, the case when a new node type is added to AST, this approach really doesn't win much compared
				to conventional visitors: ideally, since interfaces should be immutable, such addition means that a new visitor interface is declared (an extension of
				the old one) which can be implemented by inheriting from the old interpreter, or by Adapting it &mdash; just the same that would be done in the proposed
				approach.
			</p>
			
			<p>
				So, my conclusion: this paper tries to solve the problem of AST representation/interpretation by telling us to essentially write one-pass compilers, in
				the name of not writing semantic checking code for AST ourselves but instead of shifting it onto the shoulders of Java/C# type checker. No, sorry, but
				that's not a solution to the actual problem.
			</p>
		</div>
		<div class="comment-date">2021-07-14 01:21 UTC</div>
	</div>	
</div>
