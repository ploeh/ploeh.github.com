---
layout: post
title: "Stubs and mocks break encapsulation"
description: "Favour Fakes over dynamic mocks."
date: 2022-10-17 8:47 UTC
tags: [Unit Testing]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		For a while now, I've <a href="/2019/02/18/from-interaction-based-to-state-based-testing">favoured Fakes over Stubs and Mocks</a>. Using <a href="http://xunitpatterns.com/Fake%20Object.html">Fake Objects</a> over other <a href="https://martinfowler.com/bliki/TestDouble.html">Test Doubles</a> makes test suites more robust. I wrote the code base for my book <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a> entirely with Fakes and the occasional <a href="http://xunitpatterns.com/Test%20Spy.html">Test Spy</a>, and I rarely had to fix broken tests. No <a href="https://moq.github.io/moq4/">Moq</a>, <a href="https://fakeiteasy.github.io/">FakeItEasy</a>, <a href="https://nsubstitute.github.io/">NSubstitute</a>, nor <a href="https://hibernatingrhinos.com/oss/rhino-mocks">Rhino Mocks</a>. Just hand-written Test Doubles.
	</p>
	<p>
		It recently occurred to me that a way to explain the problem with <a href="http://xunitpatterns.com/Mock%20Object.html">Mocks</a> and <a href="http://xunitpatterns.com/Test%20Stub.html">Stubs</a> is that they break encapsulation.
	</p>
	<p>
		You'll see some examples soon, but first it's important to be explicit about terminology.
	</p>
	<h3 id="bde25ebecc664e99b529755c3f0829fb">
		Terminology <a href="#bde25ebecc664e99b529755c3f0829fb" title="permalink">#</a>
	</h3>
	<p>
		Words like <em>Mocks</em>, <em>Stubs</em>, as well as <em>encapsulation</em>, have different meanings to different people. They've fallen victim to <a href="https://martinfowler.com/bliki/SemanticDiffusion.html">semantic diffusion</a>, if ever they were well-defined to begin with.
	</p>
	<p>
		When I use the words <em>Test Double</em>, <em>Fake</em>, <em>Mock</em>, and <em>Stub</em>, I use them as they are defined in <a href="/ref/xunit-patterns">xUnit Test Patterns</a>. I usually try to avoid the terms <em>Mock</em> and <em>Stub</em> since people use them vaguely and inconsistently. The terms <em>Test Double</em> and <em>Fake</em> fare better.
	</p>
	<p>
		We do need, however, a name for those libraries that generate Test Doubles on the fly. In .NET, they are libraries like Moq, FakeItEasy, and so on, as listed above. Java has <a href="https://site.mockito.org/">Mockito</a>, <a href="https://easymock.org/">EasyMock</a>, <a href="https://jmockit.github.io/">JMockit</a>, and possibly more like that.
	</p>
	<p>
		What do we call such libraries? Most people call them <em>mock libraries</em> or <em>dynamic mock libraries</em>. Perhaps <em>dynamic Test Double library</em> would be more consistent with the <em>xUnit Test Patterns</em> vocabulary, but nobody calls them that. I'll call them <em>dynamic mock libraries</em> to at least emphasise the dynamic, on-the-fly object generation these libraries typically use.
	</p>
	<p>
		Finally, it's important to define <em>encapsulation</em>. This is another concept where people may use the same word and yet mean different things.
	</p>
	<p>
		I base my understanding of encapsulation on <a href="/ref/oosc">Object-Oriented Software Construction</a>. I've tried to distil it in my Pluralsight course <a href="/encapsulation-and-solid">Encapsulation and SOLID</a>.
	</p>
	<p>
		In short, encapsulation denotes the distinction between an object's contract and its implementation. An object should fulfil its contract in such a way that client code doesn't need to know about its implementation.
	</p>
	<p>
		Contracts, according to Meyer, describe three properties of objects:
	</p>
	<ul>
		<li>Preconditions: What client code must fulfil in order to successfully interact with the object.</li>
		<li>Invariants: Statements about the object that are always true.</li>
		<li>Postconditions: Statements that are guaranteed to be true after a successful interaction between client code and object.</li>
	</ul>
	<p>
		As I'll demonstrate in this article, objects generated by dynamic mock libraries often break their contracts.
	</p>
	<h3 id="2d05b5926474448589c3953f6796c2a9">
		Create-and-read round-trip <a href="#2d05b5926474448589c3953f6796c2a9" title="permalink">#</a>
	</h3>
	<p>
		Consider the <code>IReservationsRepository</code> interface from <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a>:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IReservationsRepository</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;Create(<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;Reservation&nbsp;reservation);
 
&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt;&nbsp;ReadReservations(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;DateTime&nbsp;min,&nbsp;DateTime&nbsp;max);
 
&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;Reservation?&gt;&nbsp;ReadReservation(<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;Guid&nbsp;id);
 
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;Update(<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;Reservation&nbsp;reservation);
 
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;Delete(<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;Guid&nbsp;id);
}</pre>
	</p>
	<p>
		I already discussed some of the contract properties of this interface in <a href="/2021/12/06/the-liskov-substitution-principle-as-a-profunctor">an earlier article</a>. Here, I want to highlight a certain interaction.
	</p>
	<p>
		What is the contract of the <code>Create</code> method?
	</p>
	<p>
		There are a few preconditions:
	</p>
	<ul>
		<li>The client must have a properly initialised <code>IReservationsRepository</code> object.</li>
		<li>The client must have a valid <code>restaurantId</code>.</li>
		<li>The client must have a valid <code>reservation</code>.</li>
	</ul>
	<p>
		A client that fulfils these preconditions can successfully call and await the <code>Create</code> method. What are the invariants and postconditions?
	</p>
	<p>
		I'll skip the invariants because they aren't relevant to the line of reasoning that I'm pursuing. One postcondition, however, is that the <code>reservation</code> passed to <code>Create</code> must now be 'in' the repository.
	</p>
	<p>
		How does that manifest as part of the object's contract?
	</p>
	<p>
		This implies that a client should be able to retrieve the <code>reservation</code>, either with <code>ReadReservation</code> or <code>ReadReservations</code>. This suggests a kind of property that Scott Wlaschin calls <a href="https://fsharpforfunandprofit.com/posts/property-based-testing-2/">There and back again</a>.
	</p>
	<p>
		Picking <code>ReadReservation</code> for the verification step we now have a property: If client code successfully calls and awaits <code>Create</code> it should be able to use <code>ReadReservation</code> to retrieve the reservation it just saved. That's implied by the <code>IReservationsRepository</code> contract.
	</p>
	<h3 id="f787d89599a04573a2c9b7afc28b2315">
		SQL implementation <a href="#f787d89599a04573a2c9b7afc28b2315" title="permalink">#</a>
	</h3>
	<p>
		The 'real' implementation of <code>IReservationsRepository</code> used in production is an implementation that stores reservations in SQL Server. This class should obey the contract.
	</p>
	<p>
		While it might be possible to write a true property-based test, running hundreds of randomly generated test cases against a real database is going to take time. Instead, I chose to only write a parametrised test:
	</p>
	<p>
		<pre>[Theory]
[InlineData(Grandfather.Id,&nbsp;<span style="color:#a31515;">&quot;2022-06-29&nbsp;12:00&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;e@example.gov&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Enigma&quot;</span>,&nbsp;1)]
[InlineData(Grandfather.Id,&nbsp;<span style="color:#a31515;">&quot;2022-07-27&nbsp;11:40&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;c@example.com&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Carlie&quot;</span>,&nbsp;2)]
[InlineData(2,&nbsp;<span style="color:#a31515;">&quot;2021-09-03&nbsp;14:32&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;bon@example.edu&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Jovi&quot;</span>,&nbsp;4)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;Task&nbsp;CreateAndReadRoundTrip(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;at,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;email,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;name,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;quantity)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;expected&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Reservation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Guid.NewGuid(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTime.Parse(at,&nbsp;CultureInfo.InvariantCulture),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Email(email),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Name(name),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;connectionString&nbsp;=&nbsp;ConnectionStrings.Reservations;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;SqlReservationsRepository(connectionString);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">await</span>&nbsp;sut.Create(restaurantId,&nbsp;expected);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservation(restaurantId,&nbsp;expected.Id);
 
&nbsp;&nbsp;&nbsp;&nbsp;Assert.Equal(expected,&nbsp;actual);
}</pre>
	</p>
	<p>
		The part that we care about is the three last lines:
	</p>
	<p>
		<pre><span style="color:blue;">await</span>&nbsp;sut.Create(restaurantId,&nbsp;expected);
<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservation(restaurantId,&nbsp;expected.Id);
 
Assert.Equal(expected,&nbsp;actual);</pre>
	</p>
	<p>
		First call <code>Create</code> and subsequently <code>ReadReservation</code>. The value created should equal the value retrieved, which is also the case. All tests pass.
	</p>
	<h3 id="dc7d9e2730364cf8895d73d2adcd37b0">
		Fake <a href="#dc7d9e2730364cf8895d73d2adcd37b0" title="permalink">#</a>
	</h3>
	<p>
		The Fake implementation is effectively an in-memory database, so we expect it to also fulfil the same contract. We can test it with an almost identical test:
	</p>
	<p>
		<pre>[Theory]
[InlineData(RestApi.Grandfather.Id,&nbsp;<span style="color:#a31515;">&quot;2022-06-29&nbsp;12:00&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;e@example.gov&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Enigma&quot;</span>,&nbsp;1)]
[InlineData(RestApi.Grandfather.Id,&nbsp;<span style="color:#a31515;">&quot;2022-07-27&nbsp;11:40&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;c@example.com&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Carlie&quot;</span>,&nbsp;2)]
[InlineData(2,&nbsp;<span style="color:#a31515;">&quot;2021-09-03&nbsp;14:32&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;bon@example.edu&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Jovi&quot;</span>,&nbsp;4)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;Task&nbsp;CreateAndReadRoundTrip(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;at,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;email,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;name,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;quantity)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;expected&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Reservation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Guid.NewGuid(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTime.Parse(at,&nbsp;CultureInfo.InvariantCulture),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Email(email),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Name(name),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;FakeDatabase();
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">await</span>&nbsp;sut.Create(restaurantId,&nbsp;expected);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservation(restaurantId,&nbsp;expected.Id);
 
&nbsp;&nbsp;&nbsp;&nbsp;Assert.Equal(expected,&nbsp;actual);
}</pre>
	</p>
	<p>
		The only difference is that the <code>sut</code> is a different class instance. These test cases also all pass.
	</p>
	<p>
		How is <code>FakeDatabase</code> implemented? That's not important, because it obeys the contract. <code>FakeDatabase</code> has good encapsulation, which makes it possible to use it without knowing anything about its internal implementation details. That, after all, is the point of encapsulation.
	</p>
	<h3 id="a13bc3a894914ce59b1c11ea9702b3f8">
		Dynamic mock <a href="#a13bc3a894914ce59b1c11ea9702b3f8" title="permalink">#</a>
	</h3>
	<p>
		How does a dynamic mock fare if subjected to the same test? Let's try with Moq 4.18.2 (and I'm not choosing Moq to single it out - I chose Moq because it's the dynamic mock library I used to love the most):
	</p>
	<p>
		<pre>[Theory]
[InlineData(RestApi.Grandfather.Id,&nbsp;<span style="color:#a31515;">&quot;2022-06-29&nbsp;12:00&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;e@example.gov&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Enigma&quot;</span>,&nbsp;1)]
[InlineData(RestApi.Grandfather.Id,&nbsp;<span style="color:#a31515;">&quot;2022-07-27&nbsp;11:40&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;c@example.com&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Carlie&quot;</span>,&nbsp;2)]
[InlineData(2,&nbsp;<span style="color:#a31515;">&quot;2021-09-03&nbsp;14:32&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;bon@example.edu&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Jovi&quot;</span>,&nbsp;4)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;Task&nbsp;CreateAndReadRoundTrip(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;at,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;email,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;name,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;quantity)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;expected&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Reservation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Guid.NewGuid(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTime.Parse(at,&nbsp;CultureInfo.InvariantCulture),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Email(email),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Name(name),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Mock&lt;IReservationsRepository&gt;().Object;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">await</span>&nbsp;sut.Create(restaurantId,&nbsp;expected);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservation(restaurantId,&nbsp;expected.Id);
 
&nbsp;&nbsp;&nbsp;&nbsp;Assert.Equal(expected,&nbsp;actual);
}</pre>
	</p>
	<p>
		If you've worked a little with dynamic mock libraries, you will not be surprised to learn that all three tests fail. Here's one of the failure messages:
	</p>
	<p>
		<pre>Ploeh.Samples.Restaurants.RestApi.Tests.MoqRepositoryTests.CreateAndReadRoundTrip(↩
&nbsp;&nbsp;&nbsp;&nbsp;restaurantId:&nbsp;1,&nbsp;at:&nbsp;&quot;2022-06-29&nbsp;12:00&quot;,&nbsp;email:&nbsp;&quot;e@example.gov&quot;,&nbsp;name:&nbsp;&quot;Enigma&quot;,&nbsp;quantity:&nbsp;1)
&nbsp;Source:&nbsp;<span style="color:blue;">MoqRepositoryTests.cs</span>&nbsp;line&nbsp;17
&nbsp;Duration:&nbsp;1&nbsp;ms
 
Message:&nbsp;
&nbsp;&nbsp;Assert.Equal()&nbsp;Failure
&nbsp;&nbsp;Expected:&nbsp;Reservation↩
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{↩
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;At&nbsp;=&nbsp;2022-06-29T12:00:00.0000000,↩
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Email&nbsp;=&nbsp;e@example.gov,↩
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Id&nbsp;=&nbsp;c9de4f95-3255-4e1f-a1d6-63591b58ff0c,↩
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;Enigma,↩
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;1↩
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;Actual:&nbsp;&nbsp;&nbsp;(null)
 
Stack&nbsp;Trace:&nbsp;
&nbsp;&nbsp;<span style="color:red;">MoqRepositoryTests.CreateAndReadRoundTrip(↩
&nbsp;&nbsp;&nbsp;&nbsp;Int32&nbsp;restaurantId,&nbsp;String&nbsp;at,&nbsp;String&nbsp;email,&nbsp;String&nbsp;name,&nbsp;Int32&nbsp;quantity)</span>&nbsp;line&nbsp;35
&nbsp;&nbsp;---&nbsp;End&nbsp;of&nbsp;stack&nbsp;trace&nbsp;from&nbsp;previous&nbsp;location&nbsp;where&nbsp;exception&nbsp;was&nbsp;thrown&nbsp;---</pre>
	</p>
	<p>
		(I've introduced line breaks and indicated them with the ↩ symbol to make the output more readable. I'll do that again later in the article.)
	</p>
	<p>
		Not surprisingly, the return value of <code>Create</code> is null. You typically have to configure a dynamic mock in order to give it any sort of behaviour, and I didn't do that here. In that case, the dynamic mock returns the default value for the return type, which in this case correctly is null.
	</p>
	<p>
		You may object that the above example is unfair. How can a dynamic mock know what to do? You have to configure it. That's the whole point of it.
	</p>
	<h3 id="307eb992e4c54aae8a2f331c05d9d7e4">
		Retrieval without creation <a href="#307eb992e4c54aae8a2f331c05d9d7e4" title="permalink">#</a>
	</h3>
	<p>
		Okay, let's set up the dynamic mock:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;dm&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Mock&lt;IReservationsRepository&gt;();
dm.Setup(r&nbsp;=&gt;&nbsp;r.ReadReservation(restaurantId,&nbsp;expected.Id)).ReturnsAsync(expected);
<span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;dm.Object;</pre>
	</p>
	<p>
		These are the only lines I've changed from the previous listing of the test, which now passes.
	</p>
	<p>
		A common criticism of dynamic-mock-heavy tests is that they mostly 'just test the mocks', and this is exactly what happens here.
	</p>
	<p>
		You can make that more explicit by deleting the <code>Create</code> method call:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;dm&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Mock&lt;IReservationsRepository&gt;();
dm.Setup(r&nbsp;=&gt;&nbsp;r.ReadReservation(restaurantId,&nbsp;expected.Id)).ReturnsAsync(expected);
<span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;dm.Object;
 
<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservation(restaurantId,&nbsp;expected.Id);
 
Assert.Equal(expected,&nbsp;actual);</pre>
	</p>
	<p>
		The test still passes. Clearly it only tests the dynamic mock.
	</p>
	<p>
		You may, again, demur that this is expected, and it doesn't demonstrate that dynamic mocks break encapsulation. Keep in mind, however, the nature of the contract: Upon successful completion of <code>Create</code>, the reservation is 'in' the repository and can later be retrieved, either with <code>ReadReservation</code> or <code>ReadReservations</code>.
	</p>
	<p>
		This variation of the test no longer calls <code>Create</code>, yet <code>ReadReservation</code> still returns the <code>expected</code> value.
	</p>
	<p>
		Do <code>SqlReservationsRepository</code> or <code>FakeDatabase</code> behave like that? No, they don't.
	</p>
	<p>
		Try to delete the <code>Create</code> call from the test that exercises <code>SqlReservationsRepository</code>:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;SqlReservationsRepository(connectionString);
 
<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservation(restaurantId,&nbsp;expected.Id);
 
Assert.Equal(expected,&nbsp;actual);</pre>
	</p>
	<p>
		Hardly surprising, the test now fails because <code>actual</code> is null. The same happens if you delete the <code>Create</code> call from the test that exercises <code>FakeDatabase</code>:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;FakeDatabase();
 
<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservation(restaurantId,&nbsp;expected.Id);
 
Assert.Equal(expected,&nbsp;actual);</pre>
	</p>
	<p>
		Again, the assertion fails because <code>actual</code> is null.
	</p>
	<p>
		The classes <code>SqlReservationsRepository</code> and <code>FakeDatabase</code> behave according to contract, while the dynamic mock doesn't.
	</p>
	<h3 id="81c7041024ad4c5d99055494c5b0bdf0">
		Alternative retrieval <a href="#81c7041024ad4c5d99055494c5b0bdf0" title="permalink">#</a>
	</h3>
	<p>
		There's another way in which the dynamic mock breaks encapsulation. Recall what the contract states: Upon successful completion of <code>Create</code>, the reservation is 'in' the repository and can later be retrieved, either with <code>ReadReservation</code> or <code>ReadReservations</code>.
	</p>
	<p>
		In other words, it should be possible to change the interaction from <code>Create</code> followed by <code>ReadReservation</code> to <code>Create</code> followed by <code>ReadReservations</code>.
	</p>
	<p>
		First, try it with <code>SqlReservationsRepository</code>:
	</p>
	<p>
		<pre><span style="color:blue;">await</span>&nbsp;sut.Create(restaurantId,&nbsp;expected);
<span style="color:blue;">var</span>&nbsp;min&nbsp;=&nbsp;expected.At.Date;
<span style="color:blue;">var</span>&nbsp;max&nbsp;=&nbsp;min.AddDays(1);
<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservations(restaurantId,&nbsp;min,&nbsp;max);
 
Assert.Contains(expected,&nbsp;actual);</pre>
	</p>
	<p>
		The test still passes, as expected.
	</p>
	<p>
		Second, try the same change with <code>FakeDatabase</code>:
	</p>
	<p>
		<pre><span style="color:blue;">await</span>&nbsp;sut.Create(restaurantId,&nbsp;expected);
<span style="color:blue;">var</span>&nbsp;min&nbsp;=&nbsp;expected.At.Date;
<span style="color:blue;">var</span>&nbsp;max&nbsp;=&nbsp;min.AddDays(1);
<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservations(restaurantId,&nbsp;min,&nbsp;max);
 
Assert.Contains(expected,&nbsp;actual);</pre>
	</p>
	<p>
		Notice that this is the exact same code as in the <code>SqlReservationsRepository</code> test. That test also passes, as expected.
	</p>
	<p>
		Third, try it with the dynamic mock:
	</p>
	<p>
		<pre><span style="color:blue;">await</span>&nbsp;sut.Create(restaurantId,&nbsp;expected);
<span style="color:blue;">var</span>&nbsp;min&nbsp;=&nbsp;expected.At.Date;
<span style="color:blue;">var</span>&nbsp;max&nbsp;=&nbsp;min.AddDays(1);
<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservations(restaurantId,&nbsp;min,&nbsp;max);
 
Assert.Contains(expected,&nbsp;actual);</pre>
	</p>
	<p>
		Same code, different <code>sut</code>, and the test fails. The dynamic mock breaks encapsulation. You'll have to go and fix the <code>Setup</code> of it to make the test pass again. That's not the case with <code>SqlReservationsRepository</code> or <code>FakeDatabase</code>.
	</p>
	<h3 id="09410dcfb758412d991a47f08be885b5">
		Dynamic mocks break the SUT, not the tests <a href="#09410dcfb758412d991a47f08be885b5" title="permalink">#</a>
	</h3>
	<p>
		Perhaps you're still not convinced that this is of practical interest. After all, <a href="https://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Meyer</a> had limited success getting mainstream adoption of his thought on contract-based programming.
	</p>
	<p>
		That dynamic mocks break encapsulation does, however, have real implications.
	</p>
	<p>
		What if, instead of using <code>FakeDatabase</code>, I'd used dynamic mocks when testing my online restaurant reservation system? A test might have looked like this:
	</p>
	<p>
		<pre>[Theory]
[InlineData(1049,&nbsp;19,&nbsp;00,&nbsp;<span style="color:#a31515;">&quot;juliad@example.net&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Julia&nbsp;Domna&quot;</span>,&nbsp;5)]
[InlineData(1130,&nbsp;18,&nbsp;15,&nbsp;<span style="color:#a31515;">&quot;x@example.com&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Xenia&nbsp;Ng&quot;</span>,&nbsp;9)]
[InlineData(&nbsp;956,&nbsp;16,&nbsp;55,&nbsp;<span style="color:#a31515;">&quot;kite@example.edu&quot;</span>,&nbsp;<span style="color:blue;">null</span>,&nbsp;2)]
[InlineData(&nbsp;433,&nbsp;17,&nbsp;30,&nbsp;<span style="color:#a31515;">&quot;shli@example.org&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Shanghai&nbsp;Li&quot;</span>,&nbsp;5)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;Task&nbsp;PostValidReservationWhenDatabaseIsEmpty(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;days,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;hours,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;minutes,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;email,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;name,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;quantity)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;at&nbsp;=&nbsp;DateTime.Now.Date&nbsp;+&nbsp;<span style="color:blue;">new</span>&nbsp;TimeSpan(days,&nbsp;hours,&nbsp;minutes,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;dm&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Mock&lt;IReservationsRepository&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;dm.Setup(r&nbsp;=&gt;&nbsp;r.ReadReservations(Grandfather.Id,&nbsp;at.Date,&nbsp;at.Date.AddDays(1).AddTicks(-1)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ReturnsAsync(Array.Empty&lt;Reservation&gt;());
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;ReservationsController(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;SystemClock(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;InMemoryRestaurantDatabase(Grandfather.Restaurant),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dm.Object);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;expected&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Reservation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Guid(<span style="color:#a31515;">&quot;B50DF5B1-F484-4D99-88F9-1915087AF568&quot;</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Email(email),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Name(name&nbsp;??&nbsp;<span style="color:#a31515;">&quot;&quot;</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">await</span>&nbsp;sut.Post(expected.ToDto());
 
&nbsp;&nbsp;&nbsp;&nbsp;dm.Verify(r&nbsp;=&gt;&nbsp;r.Create(Grandfather.Id,&nbsp;expected));
}</pre>
	</p>
	<p>
		This is yet another riff on the <code>PostValidReservationWhenDatabaseIsEmpty</code> test - the gift that keeps giving. I've previously discussed this test in other articles:
	</p>
	<ul>
		<li><a href="/2020/12/07/branching-tests">Branching tests</a></li>
		<li><a href="/2021/01/11/waiting-to-happen">Waiting to happen</a></li>
		<li><a href="/2021/01/18/parametrised-test-primitive-obsession-code-smell">Parametrised test primitive obsession code smell</a></li>
		<li><a href="/2021/09/27/the-equivalence-contravariant-functor">The Equivalence contravariant functor</a></li>
	</ul>
	<p>
		Here I've replaced the <code>FakeDatabase</code> Test Double with a dynamic mock. (I am, again, using Moq, but keep in mind that the fallout of using a dynamic mock is unrelated to specific libraries.)
	</p>
	<p>
		To go 'full dynamic mock' I should also have replaced <code>SystemClock</code> and <code>InMemoryRestaurantDatabase</code> with dynamic mocks, but that's not necessary to illustrate the point I wish to make.
	</p>
	<p>
		This, and other tests, describe the desired outcome of making a reservation against the REST API. It's an interaction that looks like this:
	</p>
	<p>
		<pre>POST /restaurants/90125/reservations?sig=aco7VV%2Bh5sA3RBtrN8zI8Y9kLKGC60Gm3SioZGosXVE%3D HTTP/1.1
content-type: application/json
{
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;at&quot;</span>:&nbsp;<span style="color:#a31515;">&quot;2022-12-12T20:00&quot;</span>,
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;name&quot;</span>:&nbsp;<span style="color:#a31515;">&quot;Pearl&nbsp;Yvonne&nbsp;Gates&quot;</span>,
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;email&quot;</span>:&nbsp;<span style="color:#a31515;">&quot;pearlygates@example.net&quot;</span>,
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;quantity&quot;</span>:&nbsp;4
}

HTTP/1.1 201 Created
Content-Length: 151
Content-Type: application/json; charset=utf-8
Location: [...]/restaurants/90125/reservations/82e550b1690742368ea62d76e103b232?sig=fPY1fSr[...]
{
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;id&quot;</span>:&nbsp;<span style="color:#a31515;">&quot;82e550b1690742368ea62d76e103b232&quot;</span>,
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;at&quot;</span>:&nbsp;<span style="color:#a31515;">&quot;2022-12-12T20:00:00.0000000&quot;</span>,
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;email&quot;</span>:&nbsp;<span style="color:#a31515;">&quot;pearlygates@example.net&quot;</span>,
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;name&quot;</span>:&nbsp;<span style="color:#a31515;">&quot;Pearl&nbsp;Yvonne&nbsp;Gates&quot;</span>,
&nbsp;&nbsp;<span style="color:#2e75b6;">&quot;quantity&quot;</span>:&nbsp;4
}</pre>
	</p>
	<p>
		What's of interest here is that the response includes the JSON representation of the resource that the interaction created. It's mostly a copy of the posted data, but enriched with a server-generated ID.
	</p>
	<p>
		The code responsible for the database interaction looks like this:
	</p>
	<p>
		<pre><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">async</span>&nbsp;Task&lt;ActionResult&gt;&nbsp;TryCreate(Restaurant&nbsp;restaurant,&nbsp;Reservation&nbsp;reservation)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">using</span>&nbsp;<span style="color:blue;">var</span>&nbsp;scope&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;TransactionScope(TransactionScopeAsyncFlowOption.Enabled);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;reservations&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;Repository
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ReadReservations(restaurant.Id,&nbsp;reservation.At)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ConfigureAwait(<span style="color:blue;">false</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;now&nbsp;=&nbsp;Clock.GetCurrentDateTime();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!restaurant.MaitreD.WillAccept(now,&nbsp;reservations,&nbsp;reservation))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;NoTables500InternalServerError();
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">await</span>&nbsp;Repository.Create(restaurant.Id,&nbsp;reservation).ConfigureAwait(<span style="color:blue;">false</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;scope.Complete();
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Reservation201Created(restaurant.Id,&nbsp;reservation);
}</pre>
	</p>
	<p>
		The last line of code creates a <code>201 Created</code> response with the <code>reservation</code> as content. Not shown in this snippet is the origin of the <code>reservation</code> parameter, but it's <a href="/2022/07/25/an-applicative-reservation-validation-example-in-c">the input JSON document parsed to a <code>Reservation</code> object</a>. Each <code>Reservation</code> object has <a href="/2022/09/12/coalescing-dtos">an ID that the server creates when it's not supplied by the client</a>.
	</p>
	<p>
		The above <code>TryCreate</code> helper method contains all the database interaction code related to creating a new reservation. It first calls <code>ReadReservations</code> to retrieve the existing reservations. Subsequently, it calls <code>Create</code> if it decides to accept the reservation. The <code>ReadReservations</code> method is actually an <code>internal</code> extension method:
	</p>
	<p>
		<pre><span style="color:blue;">internal</span>&nbsp;<span style="color:blue;">static</span>&nbsp;Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt;&nbsp;ReadReservations(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;IReservationsRepository&nbsp;repository,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;DateTime&nbsp;date)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;min&nbsp;=&nbsp;date.Date;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;max&nbsp;=&nbsp;min.AddDays(1).AddTicks(-1);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;repository.ReadReservations(restaurantId,&nbsp;min,&nbsp;max);
}</pre>
	</p>
	<p>
		Notice how the dynamic-mock-based test has to replicate this <code>internal</code> implementation detail to the <a href="https://docs.microsoft.com/dotnet/api/system.datetime.ticks">tick</a>. If I ever decide to change this just one tick, the test is going to fail. That's already bad enough (and something that <code>FakeDatabase</code> gracefully handles), but not what I'm driving towards.
	</p>
	<p>
		At the moment the <code>TryCreate</code> method echoes back the <code>reservation</code>. What if, however, you instead want to query the database and return the record that you got from the database? In this particular case, there's no reason to do that, but perhaps in other cases, something happens in the data layer that either enriches or normalises the data. So you make an innocuous change:
	</p>
	<p>
		<pre><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">async</span>&nbsp;Task&lt;ActionResult&gt;&nbsp;TryCreate(Restaurant&nbsp;restaurant,&nbsp;Reservation&nbsp;reservation)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">using</span>&nbsp;<span style="color:blue;">var</span>&nbsp;scope&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;TransactionScope(TransactionScopeAsyncFlowOption.Enabled);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;reservations&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;Repository
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ReadReservations(restaurant.Id,&nbsp;reservation.At)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ConfigureAwait(<span style="color:blue;">false</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;now&nbsp;=&nbsp;Clock.GetCurrentDateTime();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!restaurant.MaitreD.WillAccept(now,&nbsp;reservations,&nbsp;reservation))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;NoTables500InternalServerError();
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">await</span>&nbsp;Repository.Create(restaurant.Id,&nbsp;reservation).ConfigureAwait(<span style="color:blue;">false</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;storedReservation&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;Repository
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ReadReservation(restaurant.Id,&nbsp;reservation.Id)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ConfigureAwait(<span style="color:blue;">false</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;scope.Complete();
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Reservation201Created(restaurant.Id,&nbsp;storedReservation!);
}</pre>
	</p>
	<p>
		Now, instead of echoing back <code>reservation</code>, the method calls <code>ReadReservation</code> to retrieve the (possibly enriched or normalised) <code>storedReservation</code> and returns that value. Since this value could, conceivably, be null, for now the method uses the <code>!</code> operator to insist that this is not the case. A new test case might be warranted to cover the scenario where the query returns null.
	</p>
	<p>
		This is perhaps a little less efficient because it implies an extra round-trip to the database, but <em>it shouldn't change the behaviour of the system!</em>
	</p>
	<p>
		But when you run the test suite, that <code>PostValidReservationWhenDatabaseIsEmpty</code> test fails:
	</p>
	<p>
		<pre>Ploeh.Samples.Restaurants.RestApi.Tests.ReservationsTests.PostValidReservationWhenDatabaseIsEmpty(↩
    days: 433, hours: 17, minutes: 30, email: "shli@example.org", name: "Shanghai Li", quantity: 5)↩
    [FAIL]
  System.NullReferenceException : Object reference not set to an instance of an object.
  Stack Trace:
    [...]\Restaurant.RestApi\ReservationsController.cs(94,0): at↩
      [...].RestApi.ReservationsController.Reservation201Created↩
      (Int32 restaurantId, Reservation r)
    [...]\Restaurant.RestApi\ReservationsController.cs(79,0): at↩
      [...].RestApi.ReservationsController.TryCreate↩
      (Restaurant restaurant, Reservation reservation)
    [...]\Restaurant.RestApi\ReservationsController.cs(57,0): at↩
      [...].RestApi.ReservationsController.Post↩
      (Int32 restaurantId, ReservationDto dto)
    [...]\Restaurant.RestApi.Tests\ReservationsTests.cs(73,0): at↩
      [...].RestApi.Tests.ReservationsTests.PostValidReservationWhenDatabaseIsEmpty↩
      (Int32 days, Int32 hours, Int32 minutes, String email, String name, Int32 quantity)
    --- End of stack trace from previous location where exception was thrown ---</pre>
	</p>
	<p>
		Oh, the dreaded <code>NullReferenceException</code>! This happens because <code>ReadReservation</code> returns null, since the dynamic mock isn't configured.
	</p>
	<p>
		The typical reaction that most people have is: <em>Oh no, the tests broke!</em>
	</p>
	<p>
		I think, though, that this is the wrong perspective. The dynamic mock broke the System Under Test (SUT) because it passed an implementation of <code>IReservationsRepository</code> that breaks the contract. The test didn't 'break', because it was never correct from the outset.
	</p>
	<h3 id="f720608a0e3b45aa88f1831a4bb1f4e8">
		Shotgun surgery <a href="#f720608a0e3b45aa88f1831a4bb1f4e8" title="permalink">#</a>
	</h3>
	<p>
		When a test code base uses dynamic mocks, it tends to do so pervasively. Most tests create one or more dynamic mocks that they pass to their SUT. Most of these dynamic mocks break encapsulation, so when you refactor, the dynamic mocks break the SUT.
	</p>
	<p>
		You'll typically need to revisit and 'fix' all the failing tests to accommodate the refactoring:
	</p>
	<p>
		<pre>[Theory]
[InlineData(1049,&nbsp;19,&nbsp;00,&nbsp;<span style="color:#a31515;">&quot;juliad@example.net&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Julia&nbsp;Domna&quot;</span>,&nbsp;5)]
[InlineData(1130,&nbsp;18,&nbsp;15,&nbsp;<span style="color:#a31515;">&quot;x@example.com&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Xenia&nbsp;Ng&quot;</span>,&nbsp;9)]
[InlineData(&nbsp;956,&nbsp;16,&nbsp;55,&nbsp;<span style="color:#a31515;">&quot;kite@example.edu&quot;</span>,&nbsp;<span style="color:blue;">null</span>,&nbsp;2)]
[InlineData(&nbsp;433,&nbsp;17,&nbsp;30,&nbsp;<span style="color:#a31515;">&quot;shli@example.org&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;Shanghai&nbsp;Li&quot;</span>,&nbsp;5)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;Task&nbsp;PostValidReservationWhenDatabaseIsEmpty(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;days,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;hours,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;minutes,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;email,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;name,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;quantity)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;at&nbsp;=&nbsp;DateTime.Now.Date&nbsp;+&nbsp;<span style="color:blue;">new</span>&nbsp;TimeSpan(days,&nbsp;hours,&nbsp;minutes,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;expected&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Reservation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Guid(<span style="color:#a31515;">&quot;B50DF5B1-F484-4D99-88F9-1915087AF568&quot;</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Email(email),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;Name(name&nbsp;??&nbsp;<span style="color:#a31515;">&quot;&quot;</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;dm&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Mock&lt;IReservationsRepository&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;dm.Setup(r&nbsp;=&gt;&nbsp;r.ReadReservations(Grandfather.Id,&nbsp;at.Date,&nbsp;at.Date.AddDays(1).AddTicks(-1)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ReturnsAsync(Array.Empty&lt;Reservation&gt;());
&nbsp;&nbsp;&nbsp;&nbsp;dm.Setup(r&nbsp;=&gt;&nbsp;r.ReadReservation(Grandfather.Id,&nbsp;expected.Id)).ReturnsAsync(expected);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;sut&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;ReservationsController(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;SystemClock(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;InMemoryRestaurantDatabase(Grandfather.Restaurant),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dm.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">await</span>&nbsp;sut.Post(expected.ToDto());
 
&nbsp;&nbsp;&nbsp;&nbsp;dm.Verify(r&nbsp;=&gt;&nbsp;r.Create(Grandfather.Id,&nbsp;expected));
}</pre>
	</p>
	<p>
		The test now passes (until the next change in the SUT), but notice how top-heavy it becomes. That's a test code smell when using dynamic mocks. Everything has to happen in <a href="/2013/06/24/a-heuristic-for-formatting-code-according-to-the-aaa-pattern">the Arrange phase</a>.
	</p>
	<p>
		You typically have many such tests that you need to edit. The name of this antipattern is <a href="https://en.wikipedia.org/wiki/Shotgun_surgery">Shotgun Surgery</a>.
	</p>
	<p>
		The implication is that <em>refactoring</em> by definition is impossible:
	</p>
	<blockquote>
		<p>
			"to refactor, the essential precondition is [...] solid tests"
		</p>
		<footer><cite>Martin Fowler, <a href="/ref/refactoring">Refactoring</a></cite></footer>
	</blockquote>
	<p>
		You need tests that don't break when you refactor. When you use dynamic mocks, tests tend to fail whenever you make changes in SUTs. Even though you have tests, they don't enable refactoring.
	</p>
	<p>
		To add spite to injury, <a href="/2013/04/02/why-trust-tests">every time you edit existing tests, they become less trustworthy</a>.
	</p>
	<p>
		To address these problems, use Fakes instead of Mocks and Stubs. With the <code>FakeDatabase</code> the entire sample test suite for the online restaurant reservation system gracefully handles the change described above. No tests fail.
	</p>
	<h3 id="8b30b068b4a4412ca3a797de2760b2be">
		Spies <a href="#8b30b068b4a4412ca3a797de2760b2be" title="permalink">#</a>
	</h3>
	<p>
		If you spelunk the test code base for the book, you may also find this Test Double:
	</p>
	<p>
		<pre><span style="color:blue;">internal</span>&nbsp;<span style="color:blue;">sealed</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">SpyPostOffice</span>&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;Collection&lt;SpyPostOffice.Observation&gt;,&nbsp;IPostOffice
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Task&nbsp;EmailReservationCreated(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reservation&nbsp;reservation)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add(<span style="color:blue;">new</span>&nbsp;Observation(Event.Created,&nbsp;restaurantId,&nbsp;reservation));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Task.CompletedTask;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Task&nbsp;EmailReservationDeleted(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reservation&nbsp;reservation)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add(<span style="color:blue;">new</span>&nbsp;Observation(Event.Deleted,&nbsp;restaurantId,&nbsp;reservation));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Task.CompletedTask;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Task&nbsp;EmailReservationUpdating(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reservation&nbsp;reservation)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add(<span style="color:blue;">new</span>&nbsp;Observation(Event.Updating,&nbsp;restaurantId,&nbsp;reservation));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Task.CompletedTask;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Task&nbsp;EmailReservationUpdated(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reservation&nbsp;reservation)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add(<span style="color:blue;">new</span>&nbsp;Observation(Event.Updated,&nbsp;restaurantId,&nbsp;reservation));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Task.CompletedTask;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">internal</span>&nbsp;<span style="color:blue;">enum</span>&nbsp;<span style="color:#2b91af;">Event</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Created&nbsp;=&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updating,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updated,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deleted
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">internal</span>&nbsp;<span style="color:blue;">sealed</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Observation</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Observation</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event&nbsp;@event,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;restaurantId,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reservation&nbsp;reservation)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event&nbsp;=&nbsp;@event;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RestaurantId&nbsp;=&nbsp;restaurantId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reservation&nbsp;=&nbsp;reservation;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Event&nbsp;Event&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">int</span>&nbsp;RestaurantId&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Reservation&nbsp;Reservation&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;Equals(<span style="color:blue;">object</span>?&nbsp;obj)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;obj&nbsp;<span style="color:blue;">is</span>&nbsp;Observation&nbsp;observation&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event&nbsp;==&nbsp;observation.Event&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RestaurantId&nbsp;==&nbsp;observation.RestaurantId&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EqualityComparer&lt;Reservation&gt;.Default.Equals(Reservation,&nbsp;observation.Reservation);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">int</span>&nbsp;GetHashCode()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;HashCode.Combine(Event,&nbsp;RestaurantId,&nbsp;Reservation);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		As you can see, I've chosen to name this class with the <em>Spy</em> prefix, indicating that this is a Test Spy rather than a Fake Object. A Spy is a Test Double whose main purpose is to observe and record interactions. Does that break or realise encapsulation?
	</p>
	<p>
		While I favour Fakes whenever possible, consider the interface that <code>SpyPostOffice</code> implements:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IPostOffice</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;EmailReservationCreated(<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;Reservation&nbsp;reservation);
 
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;EmailReservationDeleted(<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;Reservation&nbsp;reservation);
 
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;EmailReservationUpdating(<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;Reservation&nbsp;reservation);
 
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;EmailReservationUpdated(<span style="color:blue;">int</span>&nbsp;restaurantId,&nbsp;Reservation&nbsp;reservation);
}</pre>
	</p>
	<p>
		This interface consist entirely of <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">Commands</a>. There's no way to query the interface to examine the state of the object. Thus, you can't check that postconditions hold <em>exclusively via the interface</em>. Instead, you need an additional <a href="http://xunitpatterns.com/Test%20Spy.html">retrieval interface</a> to examine the posterior state of the object. The <code>SpyPostOffice</code> concrete class exposes such an interface.
	</p>
	<p>
		In a sense, you can view <code>SpyPostOffice</code> as an in-memory message sink. It fulfils the contract.
	</p>
	<h3 id="b36b228b2b4f4187918c8c224c9aed04">
		Concurrency <a href="#b36b228b2b4f4187918c8c224c9aed04" title="permalink">#</a>
	</h3>
	<p>
		Perhaps you're still not convinced. You may argue, for example, that the (partial) contract that I stated is naive. Consider, again, the implications expressed as code:
	</p>
	<p>
		<pre><span style="color:blue;">await</span>&nbsp;sut.Create(restaurantId,&nbsp;expected);
<span style="color:blue;">var</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;sut.ReadReservation(restaurantId,&nbsp;expected.Id);
 
Assert.Equal(expected,&nbsp;actual);</pre>
	</p>
	<p>
		You may argue that in the face of concurrency, another thread or process could be making changes to the reservation <em>after</em> <code>Create</code>, but <em>before</em> <code>ReadReservation</code>. Thus, you may argue, the contract I've stipulated is false. In a real system, we can't expect that to be the case.
	</p>
	<p>
		I agree.
	</p>
	<p>
		Concurrency makes things much harder. Even in that light, I think the above line of reasoning is appropriate, for two reasons.
	</p>
	<p>
		First, I chose to model <code>IReservationsRepository</code> like I did because I didn't expect high contention on individual reservations. In other words, I don't expect two or more concurrent processes to attempt to modify <em>the same reservation</em> at the same time. Thus, I found it appropriate to model the Repository as
	</p>
	<blockquote>
		<p>
			"a collection-like interface for accessing domain objects."
		</p>
		<footer><cite>Edward Hieatt and Rob Mee, in Martin Fowler, <a href="/ref/peaa">Patterns of Enterprise Application Architecture</a>, <em>Repository</em> pattern</cite></footer>
	</blockquote>
	<p>
		A <em>collection-like interface</em> implies both data retrieval and collection manipulation members. In low-contention scenarios like the reservation system, this turns out to be a useful model. As the aphorism goes, <a href="https://en.wikipedia.org/wiki/All_models_are_wrong">all models are wrong, but some models are useful</a>. Treating <code>IReservationsRepository</code> as a collection accessed in a non-concurrent manner turned out to be useful in this code base.
	</p>
	<p>
		Had I been more worried about data contention, a move towards <a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a> seems promising. This leads to another object model, with different contracts.
	</p>
	<p>
		Second, even in the face of concurrency, most unit test cases are implicitly running on a single thread. While they may run in parallel, each unit test exercises the SUT on a single thread. This implies that reads and writes against Test Doubles are serialised.
	</p>
	<p>
		Even if concurrency is a real concern, you'd still expect that <em>if only one thread is manipulating the Repository object</em>, then what you <code>Create</code> you should be able to retrieve. The contract may be a little looser, but it'd still be a violation of the <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least surprise</a> if it was any different.
	</p>
	<h3 id="7db1c826945e417db7eacf65ac5207bb">
		Conclusion <a href="#7db1c826945e417db7eacf65ac5207bb" title="permalink">#</a>
	</h3>
	<p>
		In object-oriented programming, encapsulation is the notion of separating the affordances of an object from its implementation details. I find it most practical to think about this in terms of contracts, which again can be subdivided into sets of preconditions, invariants, and postconditions.
	</p>
	<p>
		Polymorphic objects (like interfaces and base classes) come with contracts as well. When you replace 'real' implementations with Test Doubles, the Test Doubles should also fulfil the contracts. Fake objects do that; Test Spies may also fit that description.
	</p>
	<p>
		When Test Doubles obey their contracts, you can refactor your SUT without breaking your test suite.
	</p>
	<p>
		By default, however, dynamic mocks break encapsulation because they don't fulfil the objects' contracts. This leads to fragile tests.
	</p>
	<p>
		Favour Fakes over dynamic mocks. You can read more about this way to write tests by following many of the links in this article, or by reading my book <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a>.
	</p>
</div>

<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
<div class="comment" id="6b55998427954772bed6da4ed8be8694">
	<div class="comment-author">Matthew Wiemer <a href="#6b55998427954772bed6da4ed8be8694">#</a></div>
	<div class="comment-content">
		<p>
			Excellent article exploring the nuances of encapsulation as it relates to testing. That said, the examples here left me with one big question: what exactly is covered by the tests using `FakeDatabase`?
		</p>
		<p>This line in particular is confusing me (as to its practical use in a "real-world" setting): `var sut = new FakeDatabase();`</p>
		<p>
			How can I claim to have tested the real system's implementation when the "system under test" is, in this approach, explicitly _not_ my real system? It appears the same criticism of dynamic mocks surfaces: "you're only testing the fake database". Does this approach align with any claim you are testing the "real database"?
		</p>
		<p>
			When testing the data-layer, I have historically written (heavier) tests that integrate with a real database to exercise a system's data-layer (as you describe with `SqlReservationsRepository`). I find myself reaching for dynamic mocks in the context of exercising an application's domain layer -- where the data-layer is a dependency providing indirect input/output. Does this use of mocks violate encapsulation in the way this article describes? I _think_ not, because in that case a dynamic mock is used to represent states that are valid "according to the contract", but I'm hoping you could shed a bit more light on the topic. Am I putting the pieces together correctly?
		</p>
		<p>
			Rephrasing the question using your Reservations example code, I would typically inject `IReservationsRepository` into `MaitreD` (which you opt not to do) and outline the posssible database return values (or commands) using dynamic mocks in a test suite of `MaitreD`. What drawbacks, if any, would that approach lead to with respect to encapsulation and test fragility?
		</p>
	</div>
	<div class="comment-date">2022-11-02 20:11 UTC</div>
</div>

	<div class="comment" id="98ef29aec08e408382205b49bea697b6">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a> <a href="#98ef29aec08e408382205b49bea697b6">#</a></div>
		<div class="comment-content">
			<p>
				Matthew, thank you for writing. I apologise if the article is unclear about this, but nowhere in the <em>real</em> code base do I have a test of <code>FakeDatabase</code>. I only wrote the tests that exercise the Test Doubles to illustrate the point I was trying to make. These tests only exist for the benefit of this article.
			</p>
			<p>
				The first <code>CreateAndReadRoundTrip</code> test in the article shows a real integration test. The System Under Test (SUT) is the <code>SqlReservationsRepository</code> class, which is part of the production code - not a Test Double.
			</p>
			<p>
				That class implements the <code>IReservationsRepository</code> interface. The point I was trying to make is that the <code>CreateAndReadRoundTrip</code> test already exercises a particular subset of the contract of the interface. Thus, if one replaces one implementation of the interface with another implementation, according to the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a> (LSP) the test should still pass.
			</p>
			<p>
				This is true for <code>FakeDatabase</code>. While the behaviour is different (it doesn't persist data), it still fulfils the contract. Dynamic mocks, on the other hand, don't automatically follow the LSP. Unless one is careful and explicit, dynamic mocks tend to weaken postconditions. For example, a dynamic mock doesn't automatically return the added reservation when you call <code>ReadReservation</code>.
			</p>
			<p>
				This is an essential flaw of dynamic mock objects that is independent of where you use them. My article <a href="#09410dcfb758412d991a47f08be885b5">already describes</a> how a fairly innocuous change in the production code will cause a dynamic mock to break the test.
			</p>
			<p>
				I no longer inject dependencies into domain models, since doing so <a href="/2017/01/27/from-dependency-injection-to-dependency-rejection">makes the domain model impure</a>. Even if I did, however, I'd still have the same problem with dynamic mocks breaking encapsulation.
			</p>
		</div>
		<div class="comment-date">2022-11-04 7:06 UTC</div>
	</div>
</div>