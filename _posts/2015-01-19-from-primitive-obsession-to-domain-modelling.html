---
layout: post
title: "From Primitive Obsession to Domain Modelling"
description: "A string is sometimes not a string. Model it accordingly."
date: 2015-01-19 8:15 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>{{ page.description }}</em>
  </p>
  <p>
    Recently, I was reviewing some code that looked like this:
  </p>
  <p>
    <pre><span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IHttpActionResult</span>&nbsp;Get(<span style="color:blue;">string</span>&nbsp;userName)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(<span style="color:blue;">string</span>.IsNullOrWhiteSpace(userName))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.BadRequest(<span style="color:#a31515;">&quot;Invalid&nbsp;user&nbsp;name.&quot;</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;user&nbsp;=&nbsp;<span style="color:blue;">this</span>.repository.FindUser(userName.ToUpper());
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.Ok(user);
}</pre>
  </p>
  <p>
    There was a few things with this that struck me as a bit odd; most notably the use of IsNullOrWhiteSpace. When I review code, IsNullOrWhiteSpace is one of the many things I look for, because most people <a href="/2014/11/18/the-isnullorwhitespace-trap">use it incorrectly</a>.
  </p>
  <p>
    This made me ask the author of the code why he had chosen to use IsNullOrWhiteSpace, or, more specifically, what was wrong with a string with white space in it?
  </p>
  <p>
    The answer wasn't what I expected, though. The answer was that it was a <em>business rule</em> that the user name can't be all white space.
  </p>
  <p>
    You can't really argue about business logic.
  </p>
  <p>
    In this case, the rule even seems quite reasonable, but I was just <em>so</em> ready to have a discussion about invariants (pre- and postconditions) that I didn't see that one coming. It got me thinking, though.
  </p>
  <h3 id="d41d5e10b2f64e74a3d782d2c88bed62">
    Where should business rules go? <a href="#d41d5e10b2f64e74a3d782d2c88bed62" title="permalink">#</a>
  </h3>
  <p>
    It seems like a reasonable business rule that a user name can't consist entirely of white space, but is it reasonable to put that business rule in a Controller? Does that mean that everywhere you have a user name string, you <em>must</em> remember to add the business rule to that code, in order to validate it? That sounds like the kind of duplication that actually hurts.
  </p>
  <p>
    Shouldn't business rules go in a proper Domain Model?
  </p>
  <p>
    This is where many programmers would start to write extension methods for strings, but that's just putting lipstick on a pig. What if you forget to call the appropriate extension method? What if a new developer on the team doesn't know about the appropriate extension method to use?
  </p>
  <p>
    The root problem here is <a href="/2011/05/25/DesignSmellPrimitiveObsession">Primitive Obsession</a>. Just because you <em>can</em> represent a value as a string, it doesn't mean that you always should.
  </p>
  <p>
    The <code>string</code> data type literally can represent <em>any</em> text. A <em>user name</em> (in the example domain above) can <em>not</em> be any text - we've already established that.
  </p>
  <h3 id="71902c06c9594f53b248ed9b6f70aa98">
    Make it a type <a href="#71902c06c9594f53b248ed9b6f70aa98" title="permalink">#</a>
  </h3>
  <p>
    Instead of string, you can (and should) make <em>user name</em> a type. That type can encapsulate all the business rules in a single place, without violating DRY. This is what is meant by a <a href="http://martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a>. In <a href="http://amzn.to/WBCwx7">Domain-Driven Design</a> terminology, a primitive like a string or a number can be turned into a Value Object. <a href="http://lostechies.com/jimmybogard">Jimmy Bogard</a> already <a href="http://grabbagoft.blogspot.dk/2007/12/dealing-with-primitive-obsession.html">covered that ground years ago</a>, but here's how I would define a UserName class:
  </p>
  <p>
    <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">UserName</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:blue;">string</span>&nbsp;value;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;UserName(<span style="color:blue;">string</span>&nbsp;value)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(value&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:#a31515;">&quot;value&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!<span style="color:#2b91af;">UserName</span>.IsValid(value))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentException</span>(<span style="color:#a31515;">&quot;Invalid&nbsp;value.&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;value&quot;</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.value&nbsp;=&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;IsValid(<span style="color:blue;">string</span>&nbsp;candidate)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(<span style="color:blue;">string</span>.IsNullOrEmpty(candidate))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;candidate.Trim().ToUpper()&nbsp;==&nbsp;candidate;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;TryParse(<span style="color:blue;">string</span>&nbsp;candidate,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:#2b91af;">UserName</span>&nbsp;userName)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userName&nbsp;=&nbsp;<span style="color:blue;">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(<span style="color:blue;">string</span>.IsNullOrWhiteSpace(candidate))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userName&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">UserName</span>(candidate.Trim().ToUpper());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">implicit</span>&nbsp;<span style="color:blue;">operator</span>&nbsp;<span style="color:blue;">string</span>(<span style="color:#2b91af;">UserName</span>&nbsp;userName)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;userName.value;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">string</span>&nbsp;ToString()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.value.ToString();
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;Equals(<span style="color:blue;">object</span>&nbsp;obj)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;other&nbsp;=&nbsp;obj&nbsp;<span style="color:blue;">as</span>&nbsp;<span style="color:#2b91af;">UserName</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(other&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">base</span>.Equals(obj);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">object</span>.Equals(<span style="color:blue;">this</span>.value,&nbsp;other.value);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">int</span>&nbsp;GetHashCode()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.value.GetHashCode();
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
  </p>
  <p>
    As you can tell, this class protects its invariants. In case you were wondering about the use of ToUpper, it turns out that there's also another business rule that states that user names are case-insensitive, and one of the ways you can implement that is by converting the value to upper case letters. All business rules pertaining to user names are now nicely encapsulated in this single class, so you don't need to remember where to apply them to strings.
  </p>
  <p>
    If you want to know the underlying string, you can either invoke ToString, or take advantage of the implicit conversion from UserName to string. You can also compare two UserName instances, because the class overrides Equals. If you have a string, and want to convert it to a UserName, you can use TryParse.
  </p>
  <p>
    The original code example above can be refactored to use the UserName class instead:
  </p>
  <p>
    <pre><span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IHttpActionResult</span>&nbsp;Get(<span style="color:blue;">string</span>&nbsp;candidate)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">UserName</span>&nbsp;userName;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!<span style="color:#2b91af;">UserName</span>.TryParse(candidate,&nbsp;<span style="color:blue;">out</span>&nbsp;userName))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.BadRequest(<span style="color:#a31515;">&quot;Invalid&nbsp;user&nbsp;name.&quot;</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;user&nbsp;=&nbsp;<span style="color:blue;">this</span>.repository.FindUser(userName);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.Ok(user);
}</pre>
  </p>
  <p>
    This code has the same complexity as the original example, but now it's much clearer what's going on. You don't have to wonder about what looks like arbitrary rules; they're all nicely encapsulated in the UserName class.
  </p>
  <p>
    Furthermore, as soon as you've left the <a href="/2011/05/31/AttheBoundaries,ApplicationsareNotObject-Oriented">not Object-Oriented boundary of your system</a>, you can express the rest of your code in terms of the Domain Model; in this case, the UserName class. Here's the IUserRepository interface's Find method:
  </p>
  <p>
    <pre><span style="color:#2b91af;">User</span>&nbsp;FindUser(<span style="color:#2b91af;">UserName</span>&nbsp;userName);
</pre>
  </p>
  <p>
    As you can tell, it's expressed in terms of the Domain Model, so you can't accidentally pass it a string. From that point, since you're receiving a UserName instance, you <em>know</em> that it conforms to all business rules encapsulated in the UserName class.
  </p>
  <h3 id="39e98690413d4675888c69f77f82421d">
    Not only for OOP <a href="#39e98690413d4675888c69f77f82421d" title="permalink">#</a>
  </h3>
  <p>
    While I've used the term <em>encapsulation</em> once or twice here, this way of thinking is in no way limited to Object-Oriented Programming. <a href="http://fsharpforfunandprofit.com">Scott Wlaschin</a> describes how to <a href="http://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus">wrap primitives in meaningful types in F#</a>. The motivation and the advantages you gain are the same in Functional F# as what I've described here.
  </p>
  <h3 id="7172fd9ca69c467e8123a20f43ea76c2">
    Over-engineering? <a href="#7172fd9ca69c467e8123a20f43ea76c2" title="permalink">#</a>
  </h3>
  <p>
    Isn't this over-engineering? A 56 lines of code class instead of a string? Really? The answer to such a question is always context-dependent, but I rarely find that it is (over-engineering). You can create a Value Object like the above UserName class in less than half an hour - even if you use Test-Driven Development. When I created this example, I wrote 27 test cases distributed over five test methods in order to make sure that I hadn't done something stupid. It took me 15 minutes.
  </p>
  <p>
    You may argue that 15 minutes is a lot, compared to the 0 minutes it would take you if you'd 'just' use a string. On the surface, that seems like a valid counter-argument, but perhaps you're forgetting that with a primitive string, you still need to write validation and business logic 'around' the string, and you have to remember to apply that logic consistently across your entire code base. My guess is that you'll spend more than 15 minutes on doing this, and troubleshooting defects that occur when someone forgets to apply one of those rules to a string in some other part of the code base.
  </p>
  <h3 id="71a8b13b5dc346beb0203e5c63e1ddcc">
    Summary <a href="#71a8b13b5dc346beb0203e5c63e1ddcc" title="permalink">#</a>
  </h3>
  <p>
    Primitive values such as strings, integers, decimal numbers, etc. often represent concepts that are constrained in some ways; they're not just <em>any</em> string, <em>any</em> integer, or <em>any</em> decimal number. Ask yourself if extreme values (like the entire <a href="http://amzn.to/19W4JHk">APPP</a> manuscript, <a href="http://msdn.microsoft.com/en-us/library/system.int32.minvalue.aspx">Int32.MinValue</a>, and so on) are suitable for such variables. If that's not the case, consider introducing a Value Object instead.
  </p>
  <p>
    If you want to learn more about Encapsulation, you can watch my <a href="{{ site.production_url }}/encapsulation-and-solid">Encapsulation and SOLID Pluralsight course</a>.
  </p>
</div>


<div id="comments">
    <hr>
    <h2 id="comments-header">
        Comments
    </h2>
    <div class="comment" id="2e2ffc9b7d104c118a84ae218a7beea2">
        <div class="comment-author">Johannes</div>
        <div class="comment-content">
            <p>
Mark, I enjoyed your article. I feel that this is the way to go. Too often have I seen people using 
arrays if bytes for images and strings for email addresses.
</p>
<p>
An important aspect of DDD is within the language and when there are people talking
about user names all the time, that usually indicates that usernames are 
an important aspect of what is going on and should be modeled explicitly and not use primitives.
</p>
<p>
The solution doesn't look overengineered to me, although I had to defend similar code
before for the same reason. Not only is it now a good place to put further validation, but also allows further distinction
using other types and a polymorphism (if carefully used, they can be a delight), each 
of which covers different invariants. 
</p>
<p>
A UserName can be moved around and used to retrieve objects. But maybe you
can't do that with a class of the type InvalidUsername. In another example, maybe 
there are functions that deal with email eddresses 
- which I have often seen modeled as strings. Some accept InvalidEmailAddress objects, 
others accept ValidEmail addresses. While it doesn't reduce the amount of boilerplate null checks,
a SendEmail function wouldn't have to do 
</p>
<pre><code>
... SendEmail(EmailAddress email)
{
    if(email.IsValid()) {
        email.Send()
    }
}
</code></pre>
<p>
One could simply make it to only accept valid email addresses. Their mere existence
would guarantee, that the email address is valid. One could then write functions dealing with 
valid email addresses and some dealing with invalid ones. You can log and analyze bad
account creation requests with the invalid ones, but not send email to them and prevent
everyone else from doing so, depending on what kind of email address is being passed around. 
</p>

        </div>
        <div class="comment-date">2015-01-20 08:16 UTC</div>
    </div>
  <div class="comment" id="a639df29250f4dcd8431008be665bd8b">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Johannes, thank you for writing. You are right, it's possible to take the idea further in the way you describe. Again, such techniques aren't even limited to OOP; for instance, Scott Wlaschin explains <a href="http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable">how to make illegal states unrepresentable</a> in F#.
      </p>
      <p>
        In fact, the Functional approach using Sum Types (Discriminated Unions) is nicer, because it doesn't rely on inheritance :)
      </p>
    </div>
    <div class="comment-date">2015-01-20 08:52 UTC</div>
  </div>
  <div class="comment" id="c54d27e6cfcd4a87b97369fc11b2d24b">
    <div class="comment-author"><a href="http://www.scrambledbrains.net">Mike McG</a></div>
    <div class="comment-content">
      <p>
        Interesting article. I have no qualms about creating domain types around primitives per se, but IMHO there should be a bit more complexity in the invariants than a single condition before resorting to that. In this case, I would think that the username constraint should be implemented in the User class. If other entities shared the constraint (e.g. Company.AccountName), the logic might be refactored into a NameValidator, and then referenced concretely by the entities.
      </p>
      <p>
        A string holding a strong password would be a good candidate for promoting to something smarter.
      </p>
    </div>
    <div class="comment-date">2015-01-20 23:10 UTC</div>
  </div>  
  <div class="comment" id="fc8ca9be75c94e9d96d7e50580a0bc27">
    <div class="comment-author">Suamere</div>
    <div class="comment-content">
      <p>
        Mark,</p>

      <p>
        This is exactly right.  I honestly have no comment on the concept because I have changed primitives to value objects a number of times and use something similar.
      </p>
      <p>
        Quick side-note, and this may just be a preference:  In the TryParse, a Trim()'d value is being passed into the constructor.  So if I want to create two usernames &quot;&nbsp;Suamere&nbsp;&quot; and &quot;Suamere&quot;, the second will fail since, unbeknownst to me, the first had been successfully created with Trim().  It seems to me that &quot;Do not allow pre/post white-space&quot; is a business rule.  Therefore, if there is white-space, I consider that to be breaking a business rule.
      </p>
      <p>
        My main motivation for this comment is that this UserName Object shows a perfect example of a pattern I've seen when using the TryParse pattern (or Monads).  That is: The logic in the TryParse is frequently an exact duplicate of logic in another method such as the constructor.  Though instead of throwing exceptions, TryParse gracefully informs the consumer of success/failure.
      </p>
      <p>
        So business logic is duplicated in the CTOR(), IsValid(), and the TryParse().  Instead, I consider this pattern:
      </p>
      <p>
        <pre>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;UserName(<span style="color:blue;">string</span>&nbsp;<span style="color:blue;">value</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckIsValid(<span style="color:blue;">value</span>,&nbsp;<span style="color:blue;">true</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.<span style="color:blue;">value</span>&nbsp;=&nbsp;<span style="color:blue;">value</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;TryParse(<span style="color:blue;">string</span>&nbsp;candidate,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:#2b91af;">UserName</span>&nbsp;userName)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userName&nbsp;=&nbsp;<span style="color:blue;">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!CheckIsValid(candidate,&nbsp;<span style="color:blue;">false</span>))&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userName&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">UserName</span>(candidate);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;IsValid(<span style="color:blue;">string</span>&nbsp;candidate)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;CheckIsValid(candidate,&nbsp;<span style="color:blue;">false</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;CheckIsValid(<span style="color:blue;">string</span>&nbsp;candidate,&nbsp;<span style="color:blue;">bool</span>&nbsp;throwExceptions)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000;">//Brevity&nbsp;follows,&nbsp;but&nbsp;can&nbsp;be&nbsp;split&nbsp;up&nbsp;into&nbsp;more&nbsp;granular&nbsp;rules&nbsp;and&nbsp;exceptions</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(<span style="color:blue;">string</span>.IsNullOrWhiteSpace(candidate))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(throwExceptions)&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(&quot;candidate&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!<span style="color:blue;">string</span>.Equals(candidate,&nbsp;candidate.Trim(),&nbsp;<span style="color:#2b91af;">StringComparison</span>.OrdinalIgnoreCase))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(throwExceptions)&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentException</span>(&quot;Invalid&nbsp;value.&quot;,&nbsp;&quot;candidate&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
		</pre>
      </p>
	  
    

      <p>
        Let me know what you think!<br />
		~Suamere, Steven Fletcher
      </p>
    </div>
    <div class="comment-date">2015-01-20 22:00 UTC</div>
  </div>
  <div class="comment" id="f51a309f5b4441d09cd108665cf81474">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Mike, thank you for writing. A business rule doesn't have to be complex in order to be important. The point isn't only to encapsulate complex logic, but to make sure that (any) business logic is applied <em>consistently</em>.
      </p>
      <p>
        In my experience, things often start simple, but evolve (or do they devolve?) into something more complex; when do you draw the line?
      </p>
    </div>
    <div class="comment-date">2015-01-21 12:57 UTC</div>
  </div>
  <div class="comment" id="4a2c83372fd949d0a5b2c7524d557025">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Steven, thank you for writing. You exhibit traits of critical thinking, which is always good when dealing with business logic :) In the end, it all boils down to what exactly the business rule is. As you interpret the business rule, you rephrase it as "Do not allow pre/post white-space", but that's not the business rule I had in mind.
      </p>
      <p>
        Since I'm the author of the blog post, I have the luxury of coming up with the example, and thus, in this case, defining the business rule. The business rule I had in mind is that user names are case-insensitive, and they're also insensitive to leading and trailing white space. Thus, " Suamere " and "Suamere" are considered to be <em>two representations</em> of the same user name, just as "FOO" and "foo" represent the same user name. The <em>canonicalised</em> representation of these two user names are "SUAMERE" and "FOO", respectively.
      </p>
      <p>
        That's also the reason I chose the name TryParse; it's equivalent to <a href="https://msdn.microsoft.com/en-us/library/system.datetime.tryparse.aspx">DateTime.TryParse</a>, which should be a well-known .NET idiom. If I parse the two strings "2015-01-21" and " 21. januar 2015 " on my machine (which is running with the da-DK locale), I get the exact same value from both strings. Notice that DateTime.TryParse also blissfully ignores leading and trailing white space. This is all correct according to <a href="http://en.wikipedia.org/wiki/Robustness_principle">Postel's law</a>.
      </p>
      <p>
        If all I'd wanted to do was to convert an already valid string into a UserName instance, I'd have implemented an explicit conversion, which is <a href="http://grabbagoft.blogspot.dk/2007/12/dealing-with-primitive-obsession.html">what Jimmy Bogard did in his article</a>. In fact, such an explicit conversion doesn't conflict with the current TryParse method, so I'd find it quite reasonable to add that as well, if any client had the need for it.
      </p>
    </div>
    <div class="comment-date">2015-01-21 13:35 UTC</div>
  </div>
 <div class="comment" id="cbfc02fd9bb64455b3e835d2a7c3fb89">
<div class="comment-author">Jeff Soper</div>
<div class="comment-content">
<p>
This question might be slightly besides the point, but I'm having trouble with the bit about UserName values being case-insensitive. I take that to mean that you can create a UserName with all uppercase, all lowercase, or any combination thereof, and they'll all be treated equally.
</p>
<p>
To me, that doesn't mean that you have to pass in an uppercase-only value to the constructor (or TryParse() method, for that matter) in order to successfully instantiate a UserName. Was that your intent?
</p>
<p>
I created a <a href="https://gist.github.com/Lumirris/fefc77e7abc655630124">Gist</a> with some tests to illustrate what I'm talking about: I can instantiate with "JEFF", but not with "jeff", using either the constructor directly or the TryParse method.
</p>
</div>
<div class="comment-date">2015-01-23 17:27 UTC</div>
</div>  
  <div class="comment" id="63ead916bc6942c08248818c55998851">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Jeff, I attempted to run your unit tests, and the only one that fails is, as expected, if you attempt to use the constructor with "jeff"; TryParse with "jeff" works.
      </p>
      <p>
        Would it have helped if the constructor was private?
      </p>
    </div>
    <div class="comment-date">2015-01-23 19:08 UTC</div>
  </div>
  <div class="comment" id="2b9eb0e8e339498a999292a0bd7f4ffd">
    <div class="comment-author">Jeff Soper</div>
    <div class="comment-content">
      <p>
        I stand corrected regarding the failing tests; I worked with the tests again, and indeed, only the constructor method failed passing in "jeff" in lowercase.
      </p>
      <p>
      	Making the constructor private would clarify things in that there would only be one way for a client to instantiate UserName, which happens to ensure anything passed into the private constructor is all upper-case.
      </p>
      <p>
      	That seems to better match the stated business rule, that UserName values are case-insensitive, rather than a rule that prohibits anything but upper-case values. In any case, it's not quite central to the point of your article, so I thank you for taking the time to reply anyway.
      </p>
    </div>
    <div class="comment-date">2015-01-28 19:42 UTC</div>
  </div>
  <div class="comment" id="e76fb4746ebb40cf90a322d4f6f8f39c">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Jeff, I think we fundamentally agree, and I <em>do</em> understand why you'd find it surprising that the constructor accepts "JEFF", but not "jeff". FWIW, I follow (a lot) of rules (of thumb) when I design APIs, and one of them is that the purpose of constructors is to initialise objects. A constructor may perform validation, but must not perform work in the sense of transforming the input or producing side-effects. In other words, constructors are used to initialise objects with <em>valid</em> values.
      </p>
      <p>
        Whenever I need to transform data as part of initialisation, I often create some sort of factory method for that explicit purpose. A static TryParse method is one of many options available when such a need arises. The point is exactly that the input may not start out being 'valid', but it can be transformed into a valid representation. Going from "jeff" to UserName("JEFF") is a <em>conversion</em>.
      </p>
      <p>
        This idea of constructors only accepting valid values may seem a bit foreign at first, but if you follow it as a general principle, you get a code base that's easier to reason about, because it's <em>consistent</em>. It's probably because I'm so used to this principle that I just left the constructor public, following another principle of mine, which is that there's no reason to make anything internal or private if the class or member can properly protect its invariants.
      </p>
      <p>
        Sorry to rant; you just inspired me to explain some of my underlying design thoughts that caused me to arrive at this particular solution.
      </p>
    </div>
    <div class="comment-date">2015-01-28 21:19 UTC</div>
  </div>
  <div class="comment" id="4399eda07fd0412a9a90326f0f0bfffa">
    <div class="comment-author">Julien Vulliet</div>
    <div class="comment-content">
      <p>
		Thanks for your post, very informative as usual. I would add a few insights. 
      </p>
	  <p>As much as it can feel Over engineering, I would totally agree and say it doesn't. I deal with GPU resource creation (Direct3D11) on a daily basis and this has helped me so much and saved me headaches (for example a Buffer size must have more than 0 elements, failing to do so gives you a cryptic runtime error than you can only catch error message by enabling Debug Device and looking at Debug output window!</p>
	  <p>Using a simple BufferElementCount in that case enforces the fact that I provide a correct value, and throw a meaningful exception early in the process. By passing a BufferElementCount I can (almost) safely expect that my buffer gets created.</p>
	  <p>On the lines of code, I would expect that the initial 50 lines would largely be overtaken by rewriting the same logic, but scattered across the whole code (plus likely adding try/catch blocks in many places on top of it), so I'm pretty sure doing the 0 lines version would lead to more code at the end. Plus 50 lines of code to save be a deep debug session on half million lines code base is a trade-off I'll happily take!</p>
	  <p>Also as a little bonus, for simple cases I wrote a little snippet so I guess I would share it here <a href="https://gist.github.com/mrvux/fd4d8db7e950727afa46">Domain Primitive</a>. Now it takes even less than 2 minutes in most simple cases.</p>	  
    </div>
    <div class="comment-date">2015-03-18 14:41 UTC</div>
  </div>
   <div class="comment" id="de671e0ed74148b28561f37f0c1a4818">
    <div class="comment-author">Alan Evans</div>
    <div class="comment-content">
      <p>
	Your Equals is fragile. Because the class is not sealed, one could descend from it and break the equality contract.
      </p>
	  <p>Example of how to break through descending:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;public class Domain​UserName : UserName{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private string domain;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Equals written to compare both username and domain
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;UserName u1 = new DomainUserName("BOB", "GITHUB");
&nbsp;&nbsp;&nbsp;&nbsp;UserName u2 = new UserName("BOB");

&nbsp;&nbsp;&nbsp;&nbsp;u1.Equals(u2) //will use DomainUserName's Equals and return false
&nbsp;&nbsp;&nbsp;&nbsp;u2.Equals(u1) //will use UserName's Equals and return true

	</pre>
	</p>
<p>
But equality contract must be symmetrical. So either seal the class or else compare GetTypes() as example here: <a href="https://msdn.microsoft.com/en-us/library/vstudio/336aedhh%28v=vs.100%29.aspx">msdn.microsoft.com/en-us/library/vstudio/336aedhh%28v=vs.100%29.aspx</a>
	
</p>	  
    </div>
    <div class="comment-date">2015-03-18 14:41 UTC</div>
  </div>
  <div class="comment" id="89e3584c29524090968dbabc26003f35">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Alan, thank you for writing. You're right; I'd never considered this - most likely because I never use inheritance. Therefore, my default coping strategy would most likely be to make the class sealed by default, but otherwise, explicitly comparing GetType() return values would have to do.
      </p>
      <p>
        Thank you for teaching me something today!
      </p>
    </div>
    <div class="comment-date">2015-04-10 16:08 UTC</div>
  </div>
  <div class="comment" id="ef864dfebdb14e7386ff2feedcbb8d67">
  <div class="comment-author"><a href="http://www.rahulpnath.com">Rahul Nath</a></div>
  <div class="comment-content">
    <p>
      Great article and completely agree on having primitive types wrapped up into its own class. I had few questions around how this would be applied to provide a good validation feedback to consuming clients. If we want to provide more details on why the 'user name is invalid', like say 'User name should not be small letters' and 'User name should not have trailing spaces' how would we handle this in the class. How would  the class communicate out the details of the rules that it is abstracting to its consuming clients.
    </p>
    <p>
      When accepting multiple such 'classes' in a endpoint, what would be a suggested validation approach. For instance if we are to look at a similar endpoint, which takes in 'Name' and 'Phone' number(or even more in the case of POST endpoint where we are creating a new user), wouldnt the controller soon be overladed with a lot of such TryParse calls.
    </p>
    <p> 
      From the above comment of constructor only accepting valid values, where would it make sense to use the constructor as opposed to TryParse. Is it at the persistence boundary of the application?
    </p>
  </div>
  <div class="comment-date">2015-11-21 0:51 UTC</div>
</div>
  <div class="comment" id="5afdaffc886343cf85fbb4a082842a82">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Rahul, thank you for writing. As a general rule, at the boundary of an application, all input must be considered evil until proven otherwise. That means that if you try to pass unvalidated input values into constructors, you should expect exceptions to be thrown on a regular basis. Since exceptions are for <em>exceptional</em> cases, that's most likely not the best way to go forward.
      </p>
      <p>
        Instead, domain objects could offer Validate methods. These would be a bit like TryParse methods, but instead of returning a primitive boolean value, they'd have to return a list of messages. If there are no messages, the input is good. If there are messages, the input is bad. You can encapsulate such a validation result in an object if you think the rule about messages/no messages is too implicit. Such Validate methods could still take <code>out</code> parameters like TryParse methods if you want to validate and potentially convert into a domain object in one go.
      </p>
      <p>
        This isn't particularly elegant in languages like C# or Java, but due to the lack of sum types in these languages, that's the best we can do.
      </p>
      <p>
        In languages with sum types, you can use the Either monad and applicative composition to address this type of problem much more elegantly. A good place to start would be <a href="http://fsharpforfunandprofit.com">Scott Wlaschin</a>'s article on <a href="http://fsharpforfunandprofit.com/posts/recipe-part2">Railway Oriented Programming</a>.
      </p>
    </div>
    <div class="comment-date">2015-11-21 11:44 UTC</div>
  </div>
  <div class="comment" id="e69240be7d4f41e68cf5a170e2a4e467">
    <div class="comment-author">Eugene Grebenyuk</div>
    <div class="comment-content">
      <p>
        Mark, implicit conversion operator should never throw exception. In the example, it can throw NullReferenceException when UserName is null. What would you recommend to fix that issue?
      </p>
    </div>
    <div class="comment-date">2016-05-25 14:54 UTC</div>
  </div>
  <div class="comment" id="e25d87a1d37c4ead8b51857c430a97ff">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Eugene, thank you for writing. That's probably a good rule, but I admit I hadn't thought about it. One option is to convert it to an explicit conversion instead. Another option is to forgo the conversion operators all together. The conversion ability isn't the important point in this article.
      </p>
      <p>
        A third option is to leave it as is. In the code bases I control, null is never an appropriate value, so if null appears anywhere, I'd consider it a bug somewhere else.
      </p>
      <p>
        To be realistic, though, I think I'd prefer one of the two first options, as I tend to agree with the <a href="https://www.python.org/dev/peps/pep-0020">Zen of Python</a>: <em>Explicit is better than implicit.</em>
      </p>
    </div>
    <div class="comment-date">2016-05-25 16:15 UTC</div>
  </div>

<div class="comment" id="9a75fa8ea2214f848bd7591b6d23b70c">
    <div class="comment-author">Moiz</div>
    <div class="comment-content">
        <p>
    Insightful post Mark!
    <br /><br />
    I have a question, if we are implementing a class that implements Parse and TryParse menthods and this class requires
    dependency, how should that be passed?
    <br /><br />
    Consider following example - MobileNumber requires a list of valid area codes, I am passing this dependency in the
    constructor and Parse and TryParse method:
    <pre>
    public class MobileNumber
    {
    &nbsp;&nbsp;&nbsp;&nbsp;public MobileNumber(IEnumerable<string> areaCodes, string countryCode, string phoneNumber)
    &nbsp;&nbsp;&nbsp;&nbsp;{
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Something */
    &nbsp;&nbsp;&nbsp;&nbsp;}

    &nbsp;&nbsp;&nbsp;&nbsp;public static MobileNumber Parse(IEnumerable<string> areaCodes, string countryCode, string phoneNumber)
    &nbsp;&nbsp;&nbsp;&nbsp;{
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Something */
    &nbsp;&nbsp;&nbsp;&nbsp;}

    &nbsp;&nbsp;&nbsp;&nbsp;public static bool TryParse(IEnumerable<string> areaCodes, string countryCode, string phoneNumber, out MobileNumber mobileNumber)
    &nbsp;&nbsp;&nbsp;&nbsp;{
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Something */
    &nbsp;&nbsp;&nbsp;&nbsp;}
    }
        </pre>
    Is it a right design?
</p>
    </div>
    <div class="comment-date">2018-02-14 11:46 UTC</div>
</div>

  <div class="comment" id="99b5036b792844dea2a5291883270831">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Moiz, thank you for writing. Is it the right design? As usual, It Depends™. Which problem are you trying to solve? What does the input look like? What should the result be of attempting to parse various examples?
      </p>
      <p>
        It can often be illuminating to write a couple of parametrised tests. What would such tests look like?
      </p>
    </div>
    <div class="comment-date">2018-02-14 18:20 UTC</div>
  </div>

  <div class="comment" id="0bc3789035754663aa52d7e1f5ff11a0">
    <div class="comment-author"><a href="http://blog.peterritchie.com">Peter Ritchie</a></div>
    <div class="comment-content">
      <p>
	      A benefit of this technique is that it doesn't prescribe <i>where</i> the business logic should be; only where <ul>access to it</ul> should be.  And in Domain Modelling that's through a Domain type (entity). That entity can certainly delegate to something else, but the entity controls the unit of work in which that business rule applies.
      </p>
    </div>
    <div class="comment-date">2019-11-26 14:14 UTC</div>
  </div>
</div>
