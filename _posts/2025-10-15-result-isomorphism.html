---
layout: post
title: "Result isomorphism"
description: "Result types are roughly equivalent to exceptions."
date: 2025-10-15 14:47 UTC
tags: [Software Design]
image: "/content/binary/result-exception-equivalence.png"
image_alt: "Two boxes labelled 'exception' and 'result', respectively, with curved arrows pointing from each to the other."
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        This article is part of a <a href="/2018/01/08/software-design-isomorphisms">a series about software design isomorphisms</a>, although naming this one an <em>isomorphism</em> is a stretch. A real isomorphism is when a lossless translation exists between two or more different representations. This article series has already shown a few examples that fit the definition better than what the present article will manage.
    </p>
    <p>
        The reader, I hope, will bear with me. The overall series of software design isomorphisms establishes a theme, and even when a topic doesn't fit the definition to a T, I find that it harmonizes well enough that it still belongs.
    </p>
    <p>
        In short, the claim made here is that 'Result' (or <a href="/2018/06/11/church-encoded-either">Either</a>) types are equivalent to exceptions.
    </p>
    <p>
        <img src="/content/binary/result-exception-equivalence.png" alt="Two boxes labelled 'exception' and 'result', respectively, with curved arrows pointing from each to the other." width="400">
    </p>
    <p>
        I've deliberately drawn the arrows in such a way that they fade or wash out as they approach their target. My intent is to suggest that there is <em>some</em> loss of information. We may consider exceptions and result types to be roughly equivalent, but they do, in general, have different semantics. The exact semantics are language-dependent, but most languages tend to align with each other when it comes to exceptions. If they have exceptions at all.
    </p>
    <h3 id="7ee6ef778c2e4268a2b6e02af7babb60">
        Checked exceptions <a href="#7ee6ef778c2e4268a2b6e02af7babb60">#</a>
    </h3>
    <p>
        As far as I'm aware, the language where exceptions and results are most similar may be <a href="https://www.java.com">Java</a>, which has <em>checked exceptions</em>. This means that a method may declare that it throws certain exceptions. Any callers must either handle all declared exceptions, or rethrow them, thereby transitively declare to <em>their</em> callers that they must expect certain exceptions to be thrown.
    </p>
    <p>
        Imagine, for example, that you want to create a library of basic statistical calculations. You may start out with this variation of <code>mean</code>:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">double</span>&nbsp;<span style="color:#2b91af;">mean</span>(<span style="color:blue;">double</span>[]&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(values&nbsp;==&nbsp;<span style="color:blue;">null</span>&nbsp;||&nbsp;values.length&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">IllegalArgumentException</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#a31515;">&quot;The&nbsp;parameter&nbsp;&#39;values&#39;&nbsp;must&nbsp;not&nbsp;be&nbsp;null&nbsp;or&nbsp;empty.&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">for</span>&nbsp;(<span style="color:blue;">double</span>&nbsp;value&nbsp;<span style="color:blue;">:</span>&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;sum&nbsp;/&nbsp;values.length;
}</pre>
    </p>
    <p>
        Since it's impossible to calculate the mean for an empty data set, this method throws an exception. If we had omitted the Guard Clause, the method would have returned <code>NaN</code>, a questionable language design choice, if you ask me.
    </p>
    <p>
        One would think that you could add <code>throws&nbsp;IllegalArgumentException</code> to the method declaration in order to force callers to deal with the problem, but alas, <code>IllegalArgumentException</code> is a <code>RuntimeException</code>, so no caller is forced to deal with this exception, after all.
    </p>
    <p>
        Purely for the sake of argument, we may introduce a special <code>StatisticsException</code> class as a checked exception, and change the <code>mean</code> method to this variation:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">double</span>&nbsp;<span style="color:#2b91af;">mean</span>(<span style="color:blue;">double</span>[]&nbsp;values)&nbsp;<span style="color:blue;">throws</span>&nbsp;<span style="color:blue;">StatisticsException</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(values&nbsp;==&nbsp;<span style="color:blue;">null</span>&nbsp;||&nbsp;values.length&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">StatisticsException</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#a31515;">&quot;The&nbsp;parameter&nbsp;&#39;values&#39;&nbsp;must&nbsp;not&nbsp;be&nbsp;null&nbsp;or&nbsp;empty.&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">for</span>&nbsp;(<span style="color:blue;">double</span>&nbsp;value&nbsp;<span style="color:blue;">:</span>&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;sum&nbsp;/&nbsp;values.length;
}</pre>
    </p>
    <p>
        Since the new <code>StatisticsException</code> class is a checked exception, callers must handle that exception, or declare that they themselves throw that exception type. Even unit tests have to do that:
    </p>
    <p>
        <pre><span style="color:blue;">@Test</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="color:#2b91af;">meanOfOneValueIsTheValueItself</span>()&nbsp;<span style="color:blue;">throws</span>&nbsp;<span style="color:blue;">StatisticsException</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:blue;">Statistics</span>.mean(<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">double</span>[]&nbsp;{&nbsp;42.0&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;assertEquals(42.0,&nbsp;actual);
}</pre>
    </p>
    <p>
        Instead of 'rethrowing' checked exceptions, you may also handle them, if you can.
    </p>
    <h3 id="f2f5c2189839481b823dbdfde3a6de62">
        Handling checked exceptions <a href="#f2f5c2189839481b823dbdfde3a6de62">#</a>
    </h3>
    <p>
        If you have a sensible way to deal with error values, you may handle checked exceptions. Let's assume, mostly to have an example to look at, that we also need a function to calculate the empirical <a href="https://en.wikipedia.org/wiki/Variance">variance</a> of a data set. Furthermore, for the sole benefit of the example, let's handwave and say that if the data set is empty, this means that the variance is zero. (I <em>do</em> understand that that's not how variance is defined, but work with me: It's only for the sake of the example.)
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">double</span>&nbsp;<span style="color:#2b91af;">variance</span>(<span style="color:blue;">double</span>[]&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">try</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;mean&nbsp;=&nbsp;mean(values);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;sumOfSquares&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">for</span>&nbsp;(<span style="color:blue;">double</span>&nbsp;value&nbsp;<span style="color:blue;">:</span>&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;deviation&nbsp;=&nbsp;value&nbsp;-&nbsp;mean;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sumOfSquares&nbsp;+=&nbsp;deviation&nbsp;*&nbsp;deviation;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;sumOfSquares&nbsp;/&nbsp;values.length;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span style="color:blue;">catch</span>&nbsp;(<span style="color:blue;">StatisticsException</span>&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        Since the <code>variance</code> function handles <code>StatisticsExceptions</code> in a <code>try/catch</code> construction, the function doesn't throw that exception, and therefore doesn't have to declare that it throws anything. To belabour the obvious: The method is <em>not</em> adorned with any <code>throws StatisticsException</code> declaration.
    </p>
    <h3 id="fe60742833bf4e37ac67ab91b9e507ba">
        Refactoring to Result values <a href="#fe60742833bf4e37ac67ab91b9e507ba">#</a>
    </h3>
    <p>
        The claim in this article is that throwing exceptions is sufficiently equivalent to returning Result values that it warrants investigation. As far as I can tell, Java doesn't come with any built-in <code>Result</code> type (and neither does C#), mostly, it seems, because Result values seem rather redundant in a language with checked exceptions.
    </p>
    <p>
        Still, imagine that we define a <a href="/2018/06/11/church-encoded-either">Church-encoded Either</a>, but call it <code><span style="color:#2b91af;">Result</span>&lt;Succ,&nbsp;Fail&gt;</code>. You can now refactor <code>mean</code> to return a <code>Result</code> value:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">Result&lt;Double,&nbsp;StatisticsException&gt;</span>&nbsp;<span style="color:#2b91af;">mean</span>(<span style="color:blue;">double</span>[]&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(values&nbsp;==&nbsp;<span style="color:blue;">null</span>&nbsp;||&nbsp;values.length&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">Result</span>.failure(<span style="color:blue;">new</span>&nbsp;<span style="color:blue;">StatisticsException</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#a31515;">&quot;The&nbsp;parameter&nbsp;&#39;values&#39;&nbsp;must&nbsp;not&nbsp;be&nbsp;null&nbsp;or&nbsp;empty.&quot;</span>));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">for</span>&nbsp;(<span style="color:blue;">double</span>&nbsp;value&nbsp;<span style="color:blue;">:</span>&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">Result</span>.success(sum&nbsp;/&nbsp;values.length);
}</pre>
    </p>
    <p>
        In order to make the change as understandable as possible, I've only changed the function to return a <code>Result</code> value, while most other design choices remain as before. Particularly, the failure case contains <code>StatisticsException</code>, although as a general rule, I'd consider that an anti-pattern: <a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/">You're better off using exceptions</a> if exceptions are what your are dealing with.
    </p>
    <p>
        That said, the above variation of <code>mean</code> no longer has to declare that it <code>throws StatisticsException</code>, because it implicitly does that by its static return type.
    </p>
    <p>
        Furthermore, <code>variance</code> can still handle both success and failure cases with <code>match</code>:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">double</span>&nbsp;<span style="color:#2b91af;">variance</span>(<span style="color:blue;">double</span>[]&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;mean(values).match(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mean&nbsp;-&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;sumOfSquares&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">for</span>&nbsp;(<span style="color:blue;">double</span>&nbsp;value&nbsp;<span style="color:blue;">:</span>&nbsp;values)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">double</span>&nbsp;deviation&nbsp;=&nbsp;value&nbsp;-&nbsp;mean;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sumOfSquares&nbsp;+=&nbsp;deviation&nbsp;*&nbsp;deviation;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;sumOfSquares&nbsp;/&nbsp;values.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;-&gt;&nbsp;0.0
&nbsp;&nbsp;&nbsp;&nbsp;);
}</pre>
    </p>
    <p>
        Just like <code>try/catch</code> enables you to 'escape' having to propagate a checked exception, <code>match</code> allows you to handle both cases of a <a href="https://en.wikipedia.org/wiki/Tagged_union">sum type</a> in order to instead return an 'unwrapped' value, like a <code>double</code>.
    </p>
    <h3 id="8844ff0b0a3f459f9e110c54afcd47ba">
        Not a true isomorphism <a href="#8844ff0b0a3f459f9e110c54afcd47ba">#</a>
    </h3>
    <p>
        Some languages (e.g. <a href="https://fsharp.org/">F#</a> and <a href="https://www.haskell.org/">Haskell</a>) already have built-in Result types (although they may instead be called <code>Either</code>). In other languages, you can either find a reusable library that provides such a type, or you can add one yourself.
    </p>
    <p>
        Once you have a Result type, you can always refactor exception-throwing code to Result-returning code. This applies even if the language in question doesn't have checked exceptions. In fact, I've mostly performed this manoeuvre in C#, which doesn't have checked exceptions.
    </p>
    <p>
        Most mainstream languages also support exceptions, so if you have a Result-valued method, you can also refactor the 'other way'. For the above statistics example, you simply read the examples from bottom toward the top.
    </p>
    <p>
        Because it's possible to go back and forth like that, this relationship looks like a software design isomorphism. It's not quite, however, since information is lost in both directions.
    </p>
    <p>
        When you refactor from throwing an exception to returning a Result value, you lose the stack trace embedded in the exception. Additionally, languages that support exceptions have very specific semantics for that language construct. Specifically, an unhandled exception crashes its program, and although this may look catastrophic, it usually happens in an orderly way. The compiler or language runtime makes sure that the process exits with a proper error code. Usually, an unhandled exception is communicated to the operating system, which logs the error, including the stack trace. All of this happens automatically.
    </p>
    <p>
        As <a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/">Eirik Tsarpalis points out</a>, you lose all of this 'convenience' if you instead use Result values. A Result is just another data structure, and the semantics associated with failure cases are entirely your responsibility. If you need an 'unhandled' failure case to crash the program, you must explicitly write code to make the program return an error code to the operating system.
    </p>
    <p>
        So why would you ever want to use Result types? Because you also, typically, lose information going from Result-valued operations to throwing exceptions.
    </p>
    <p>
        Most importantly, you lose static type information about error conditions. Java is the odd man out in this respect, since checked exceptions actually <em>do</em> statically advertise to callers the error cases with which they must deal. Even so, in the first example, above, <code>IllegalArgumentException</code> is not part of the statically-typed method signature, since <code>IllegalArgumentException</code> is not a checked exception. Consequently, I had to invent the custom <code>StatisticsException</code> to make the example work. Other languages don't support checked exceptions, so there, a compiler or static analyser can't help you identify whether or not you've dealt with all error cases.
    </p>
    <p>
        Thus, in statically typed languages, a Result value contains information about error cases. A compiler or static analyser can check whether you've dealt with all possible errors. If you refactor to throwing exceptions, this information is lost.
    </p>
    <p>
        The bottom line is that you can refactor from exceptions to Results, or from Results to exceptions. As far as I can tell, these refactorings are always possible, but you gain and lose some capabilities in both directions.
    </p>
    <h3 id="90ea11bc449b4e93a9d167796f118cc3">
        Other languages <a href="#90ea11bc449b4e93a9d167796f118cc3">#</a>
    </h3>
    <p>
        So far, I've only shown a single example in Java. You can, however, easily do the same exercise in other languages that support exceptions. My article <a href="/2020/02/03/non-exceptional-averages">Non-exceptional averages</a> goes over some of the same ground in C#, and <a href="/2024/05/06/conservative-codomain-conjecture">Conservative codomain conjecture</a> expands on the <em>average</em> example in both C# and F#.
    </p>
    <p>
        You can even implement Result types in <a href="https://www.python.org/">Python</a>; the reusable library <a href="https://github.com/dry-python/returns">returns</a>, for example, comes with <a href="/2022/04/25/the-maybe-monad">Maybe</a> and Result. Given that Python is fundamentally dynamically typed, however, I'm not sure I'm convinced of the utility of that.
    </p>
    <p>
        At the other extreme, Haskell idiomatically uses <code>Either</code> for most error handling. Even so, the language also has exceptions, and even if some may think that they're mostly present for historical reasons, they're still used in modern Haskell code to model <a href="/2024/01/29/error-categories-and-category-errors">predictable errors that you probably can't handle</a>, such as various IO-related problems: The file is gone, the network is down, the database is not responding, etc.
    </p>
    <p>
        Finally, we should note that the similarity between exceptions and Result values depends on the language in question. Some languages don't support <a href="https://en.wikipedia.org/wiki/Parametric_polymorphism">parametric polymorphism</a> (AKA <em>generics</em>), and while I haven't tried, I'd expect the utility of Result values to be limited in those cases. On the other hand, some languages don't have exceptions, <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a> being perhaps the most notable example.
    </p>
    <h3 id="89c5ca8ff8e949fd85318d64c36cbabb">
        Conclusion <a href="#89c5ca8ff8e949fd85318d64c36cbabb">#</a>
    </h3>
    <p>
        All programs can fail. Over the decades, various languages have had different approaches to error handling. Exceptions, including mechanisms for throwing and catching them, is perhaps the most common. Another strategy is to rely on Result values. In their given contexts, each offer benefits and drawbacks.
    </p>
    <p>
        In many languages, you have a choice of both. In Haskell, Results (<code>Either</code>) is the idiomatic solution, but exceptions are still possible. In C-like languages, ironically, exceptions are the norm, but in many (like Java and C#) you can bolt on Results if you so decide, although it's likely to alienate some developers. In a language like F#, both options are present at an almost equal proportion. I'd consider it idiomatic to use <a href="https://learn.microsoft.com/dotnet/fsharp/language-reference/results">Result</a> in 'native' F# code, while when interoperating with the rest of the .NET ecosystem (which is almost exclusively written in C#) it may be more prudent to just stick to exceptions.
    </p>
    <p>
        In those languages where you have both options, you can go back and forth between exceptions and Result values. Since you can refactor both ways, this relationship looks like a software design isomorphism. It isn't, though. There are differences in language semantics between the two, so a choice of one or the other has consequences. Recall, however, as <a href="https://en.wikipedia.org/wiki/Jean-Paul_Sartre">Sartre</a> said, not making a choice is also making a choice.
    </p>
    <p>
        <strong>Next:</strong> <a href="/2020/02/10/builder-isomorphisms">Builder isomorphisms</a>.
    </p>
</div>
<div id="comments">
    <hr>
    <h2 id="comments-header">
        Comments
    </h2>
    <div class="comment" id="4a0723fd432d4b00889ade3dea8de8c3">
        <div class="comment-author"><a href="https://medium.com/@denis.bredikhin">Denis Bredikhin</a> <a href="#4a0723fd432d4b00889ade3dea8de8c3">#</a></div>
        <div class="comment-content">
            <p>
                Thank you for the article — an interesting perspective on comparing exceptions and the Result pattern.
                I recently wrote an article where I explored specific scenarios in which the Result pattern offers advantages over exceptions, and vice versa.
                <a href="https://medium.com/@denis.bredikhin/exception-handling-in-net-59123c36240a">Exception Handling in .NET</a>
                I’d be very interested to hear your thoughts on it.
            </p>
        </div>
        <div class="comment-date">2025-10-17 08:34 UTC</div>
    </div>

    <div class="comment" id="dd40b4e5f049448e98b44069529b1650">
        <div class="comment-author"><a href="/">Mark Seemann</a> <a href="#dd40b4e5f049448e98b44069529b1650">#</a></div>
        <div class="comment-content">
            <p>
                Thank you for writing. Proper exception-throwing and -handling is indeed complicated, and I can tell from your article that you've seen many of the same antipatterns and much of the same cargo-cult programming that I have. Clearly, there's a need for content such as your article to educate people on better modelling of errors.
            </p>
        </div>
        <div class="comment-date">2025-10-22 05:49 UTC</div>
    </div>
</div>
