---
layout: post
title: "Service Locator violates SOLID"
date: 2014-05-15 18:51 UTC
tags: [Software Design, Dependency Injection]
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>Yet another reason to avoid the Service Locator anti-pattern is that it violates the principles of Object-Oriented Design.</em>
  </p>
  <p>
    Years ago, I wrote an article about <a href="http://martinfowler.com/articles/injection.html">Service Locator</a>. Regular readers of this blog may already know that <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern">I consider Service Locator an anti-pattern</a>. That hasn't changed, but I recently realized that there's another way to explain why Service Locator is the inverse of good Object-Oriented Design (OOD). My original article didn't include that perspective at all, so perhaps this is a clearer way of explaining it.
  </p>
  <p>
    In this article, I'll assume that you're familiar with the <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID principles</a> (also known as <em>the Principles of OOD</em>), and that you accept them as generally correct. It's not because I wish to argue by an appeal to authority, but rather because threre's already a large body of work that explains why these principles are beneficial to software design.
  </p>
  <p>
    In short, Service Locator violates SOLID because it violates the <a href="http://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle</a> (ISP). That's because a Service Locator effectively has <em>infinitely</em> many members.
  </p>
  <p>
    <strong>Service Locator deconstructed</strong>
  </p>
  <p>
    In order to understand why a Service Locator has infinitely many members, you'll need to understand what a Service Locator is. Often, it's a class or interface with various members, but it all boils down to a single member:
  </p>
  <p>
    <pre style="font-family:Consolas;font-size:13;color:black;">T&nbsp;Create&lt;T&gt;();
</pre>
  </p>
  <p>
    Sometimes the method <a href="http://blog.ploeh.dk/2010/11/01/PatternRecognitionAbstractFactoryorServiceLocator">takes one or more parameters</a>, but that doesn't change the conclusion, so I'm leaving out those input parameters to keep things simple.
  </p>
  <p>
    A common variation is the untyped, non-generic variation:
  </p>
  <p>
    <pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">object</span>&nbsp;Create(<span style="color:#2b91af;">Type</span>&nbsp;type);
</pre>
  </p>
  <p>
    Since my overall argument relies on the generic version, first I'll need to show you why those two methods are equivalent. If you imagine that all you have is the non-generic version, you can easily write a generic extension method for it:
  </p>
  <p>
    <pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">ServiceLocatorEnvy</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;T&nbsp;Create&lt;T&gt;(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IServiceLocator</span>&nbsp;serviceLocator)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;(T)serviceLocator.Create(<span style="color:blue;">typeof</span>(T));
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
  </p>
  <p>
    As you can see, this extension method has exactly the same signature as the generic version; you can always create a generic Service Locator based on a non-generic Service Locator. Thus, while my main argument (coming up next) is based on a generic Service Locator, it also applies to non-generic Service Locators.
  </p>
  <p>
    <strong>Infinite methods</strong>
  </p>
  <p>
    From a client's perspective, there no limit to how many variations of the Create method it can invoke:
  </p>
  <p>
    <pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">var</span>&nbsp;foo&nbsp;=&nbsp;serviceLocator.Create&lt;<span style="color:#2b91af;">IFoo</span>&gt;();
<span style="color:blue;">var</span>&nbsp;bar&nbsp;=&nbsp;serviceLocator.Create&lt;<span style="color:#2b91af;">IBar</span>&gt;();
<span style="color:blue;">var</span>&nbsp;baz&nbsp;=&nbsp;serviceLocator.Create&lt;<span style="color:#2b91af;">IBaz</span>&gt;();
<span style="color:green;">//&nbsp;etc.</span></pre>
  </p>
  <p>
    Again, from the client's perspective, that's equivalent to multiple method definitions like:
  </p>
  <p>
    <pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:#2b91af;">IFoo</span>&nbsp;CreateFoo();
<span style="color:#2b91af;">IBar</span>&nbsp;CreateBar();
<span style="color:#2b91af;">IBaz</span>&nbsp;CreateBaz();
<span style="color:green;">//&nbsp;etc.</span></pre>
  </p>
  <p>
    However, the client can <em>keep coming up with new types to request</em>, so effectively, the number of Create methods is infinite!
  </p>
  <p>
    <strong>Relation to the Interface Segregation Principle</strong>
  </p>
  <p>
    By now, you understand that a Service Locator is an interface or class with effectively an infinite number of methods. That violates the ISP, which states:
    <blockquote>
      <a href="http://amzn.to/19W4JHk">Clients should not be forced to depend on methods they do not use.</a>
    </blockquote>
    However, since a Service Locator exposes an infinite number of methods, any client using it is forced to depend on infinitely many methods it doesn't use.
  </p>
  <p>
    <strong>Quod Erat Demonstrandum</strong>
  </p>
  <p>
    The Service Locator anti-pattern violates the ISP, and thus it also violates SOLID as a whole. SOLID is also known as <em>the Principles of OOD</em>. Therefore, Service Locator is bad Objected-Oriented Design.
  </p>
</div>


<div id="comments">
  <hr>
  <h2 id="comments-header">
	  Comments
  </h2>
	<div class="comment">
		<div class="comment-author">Nelson LaQuet</div>
		<div class="comment-content">
		  Doesn't this argument also apply to any method that takes a generic parameter? Meaning
		  any use of generic methods also violate ISP?
		</div>
		<div class="comment-date">2014-05-15 21:06 UTC</div>
	</div>
</div>
