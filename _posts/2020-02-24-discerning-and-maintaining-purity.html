---
layout: post
title: "Discerning and maintaining purity"
description: "Functional programming depends on referential transparency, but identifying and keeping functions pure requires deliberate attention."
date: 2020-02-24 7:31 UTC
tags: [Functional Programming, Unit Testing, Architecture]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		<a href="https://en.wikipedia.org/wiki/Referential_transparency">Referential transparency</a> is the essence of functional programming. Most other traits that people associate with functional programming emerge from it: immutability, recursion, <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order functions</a>, <a href="/2018/03/22/functors">functors</a> and monads, etcetera.
	</p>
	<p>
		To summarise, a <a href="https://en.wikipedia.org/wiki/Pure_function">pure function</a> has to obey two rules:
		<ul>
			<li>The same input always produces the same output.</li>
			<li>Calling it causes no side effects.</li>
		</ul>
		While those rules are easy to understand and remember, in practice they're harder to follow than most people realise.
	</p>
	<h3 id="8435839fae0b484399d4ada9f06e695d">
		Lack of abstraction <a href="#8435839fae0b484399d4ada9f06e695d" title="permalink">#</a>
	</h3>
	<p>
		Mainstream programming languages don't distinguish between pure functions and impure actions. I'll use C# for examples, but you can draw the same conclusions for Java, C, C++, Visual Basic .NET and so on - even for <a href="https://fsharp.org">F#</a> and <a href="https://clojure.org">Clojure</a>.
	</p>
	<p>
		Consider this line of code:
	</p>
	<p>
		<pre><span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">validationMsg</span>&nbsp;=&nbsp;<span style="color:#2b91af;">Validator</span>.<span style="color:#74531f;">Validate</span>(<span style="font-weight:bold;color:#1f377f;">dto</span>);</pre>
	</p>
	<p>
		Is <code>Validate</code> a pure function?
	</p>
	<p>
		You might want to look at the method signature before you answer:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Validate</span>(<span style="color:#2b91af;">ReservationDto</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>)</pre>
	</p>
	<p>
		This is, unfortunately, not helpful. Will <code>Validate</code> always return the same <code>string</code> for the same <code>dto</code>? Can we guarantee that there's no side effects?
	</p>
	<p>
		You can't answer these questions only by examining the method signature. You'll have to go and <em>read</em> the code.
	</p>
	<p>
		This breaks <a href="/encapsulation-and-solid">encapsulation</a>. It ruins abstraction. It makes code harder to maintain.
	</p>
	<p>
		I can't stress this enough. This is what I've attempted to describe in my <a href="https://cleancoders.com/episode/humane-code-real-episode-1/show">Humane Code</a> video. We waste significant time <em>reading</em> existing code. Mostly because it's difficult to understand. It doesn't fit in our brains.
	</p>
	<p>
		<a href="http://amzn.to/19W4JHk">Agile Principles, Patterns, and Practices</a> defines an <em>abstraction</em> as
		<blockquote>
			<p>
				"the amplification of the essential and the elimination of the irrelevant"
			</p>
			<footer><cite>Robert C. Martin</cite></footer>
		</blockquote>
		This fits with the definition of encapsulation from <a href="http://amzn.to/1claOin">Object-Oriented Software Construction</a>. You should be able to interact with an object without knowledge of its implementation details.
	</p>
	<p>
		When you have to read the code of a method, it indicates a lack of abstraction and encapsulation. Unfortunately, that's the state of affairs when it comes to referential transparency in mainstream programming languages.
	</p>
	<h3 id="eabec7ed53c3482d86d1e4968101741f">
		Manual analysis <a href="#eabec7ed53c3482d86d1e4968101741f" title="permalink">#</a>
	</h3>
	<p>
		If you read the source code of the <code>Validate</code> method, however, it's easy to figure out whether it's pure:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Validate</span>(<span style="color:#2b91af;">ReservationDto</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(!<span style="color:#2b91af;">DateTime</span>.<span style="color:#74531f;">TryParse</span>(<span style="font-weight:bold;color:#1f377f;">dto</span>.Date,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="color:blue;">_</span>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">$&quot;Invalid&nbsp;date:&nbsp;</span>{<span style="font-weight:bold;color:#1f377f;">dto</span>.Date}<span style="color:#a31515;">.&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;&quot;</span>;
}</pre>
	</p>
	<p>
		Is the method deterministic? It seems like it. In fact, in order to answer that question, you need to know if <code>DateTime.TryParse</code> is deterministic. Assume that it is. Apart from the <code>TryParse</code> call, you can easily reason about the rest of this method. There's no randomness or other sources of non-deterministic behaviour in the method, so it seems reasonable to conclude that it's deterministic.
	</p>
	<p>
		Does the method produce side effects? Again, you have to know about the behaviour of <code>DateTime.TryParse</code>, but I think it's safe to conclude that there's no side effects.
	</p>
	<p>
		In other words, <code>Validate</code> is a pure function.
	</p>
	<h3 id="58667892c58f45ebac8e50946a9f1f2a">
		Testability <a href="#58667892c58f45ebac8e50946a9f1f2a" title="permalink">#</a>
	</h3>
	<p>
		Pure functions are <a href="/2015/05/07/functional-design-is-intrinsically-testable">intrinsically testable</a> because they depend exclusively on their input.
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">ValidDate</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ReservationDto</span>&nbsp;{&nbsp;Date&nbsp;=&nbsp;<span style="color:#a31515;">&quot;2021-12-21&nbsp;19:00&quot;</span>,&nbsp;Quantity&nbsp;=&nbsp;2&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#2b91af;">Validator</span>.<span style="color:#74531f;">Validate</span>(<span style="font-weight:bold;color:#1f377f;">dto</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Empty</span>(<span style="font-weight:bold;color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		This unit test creates a reservation <a href="https://en.wikipedia.org/wiki/Data_transfer_object">Data Transfer Object</a> (DTO) with a valid date string and a positive quantity. There's no error message to produce for a valid DTO. The test asserts that the error message is empty. It passes.
	</p>
	<p>
		You can with similar ease write a test that verifies what happens if you supply an invalid <code>Date</code> string.
	</p>
	<h3 id="de8e9b17b8c14448a76165337ebdc410">
		Maintaining purity <a href="#de8e9b17b8c14448a76165337ebdc410" title="permalink">#</a>
	</h3>
	<p>
		The problem with manual analysis of purity is that any conclusion you reach only lasts until someone edits the code. Every time the code changes, you must re-evaluate.
	</p>
	<p>
		Imagine that you need to add a new validation rule. The system shouldn't accept reservations in the past, so you edit the <code>Validate</code> method:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Validate</span>(<span style="color:#2b91af;">ReservationDto</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(!<span style="color:#2b91af;">DateTime</span>.<span style="color:#74531f;">TryParse</span>(<span style="font-weight:bold;color:#1f377f;">dto</span>.Date,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">date</span>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">$&quot;InvalidÂ date:Â </span>{<span style="font-weight:bold;color:#1f377f;">dto</span>.Date}<span style="color:#a31515;">.&quot;</span>;

&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">date</span>&nbsp;<span style="font-weight:bold;color:#74531f;">&lt;</span>&nbsp;<span style="color:#2b91af;">DateTime</span>.Now)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">$&quot;InvalidÂ date:Â </span>{<span style="font-weight:bold;color:#1f377f;">dto</span>.Date}<span style="color:#a31515;">.&quot;</span>;

&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;&quot;</span>;
}</pre>
	</p>
	<p>
		Is the method still pure? No, it's not. It's now non-deterministic. One way to observe this is to let time pass. Assume that you wrote the above unit test well before December 21, 2021. That test still passes when you make the change, but months go by. One day (on December 21, 2021 at 19:00) the test starts failing. No code changed, but now you have a failing test.
	</p>
	<p>
		I've made sure that the examples in this article are simple, so that they're easy to follow. This could mislead you to think that the shift from referential transparency to impurity isn't such a big deal. After all, the test is easy to read, and it's clear why it starts failing.
	</p>
	<p>
		Imagine, however, that the code is as complex as the code base you work with professionally. A subtle change to a method deep in the bowels of a system can have profound impact on the entire architecture. You thought that you had a <a href="/2018/11/19/functional-architecture-a-definition">functional architecture</a>, but you probably don't.
	</p>
	<p>
		Notice that no types changed. The method signature remains the same. It's surprisingly difficult to maintain purity in a code base, even if you explicitly set out to do so. There's no <a href="https://en.wikipedia.org/wiki/Poka-yoke">poka-yoke</a> here; constant vigilance is required.
	</p>
	<h3 id="dcf2b00c3b4f49d192a10f0cb269d427">
		Automation attempts <a href="#dcf2b00c3b4f49d192a10f0cb269d427" title="permalink">#</a>
	</h3>
	<p>
		When I explain these issues, people typically suggest some sort of annotation mechanism. Couldn't we use attributes to identify pure functions? Perhaps like this:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Pure</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Validate</span>(<span style="color:#2b91af;">ReservationDto</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>)</pre>
	</p>
	<p>
		This doesn't solve the problem, though, because this still still compiles:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Pure</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Validate</span>(<span style="color:#2b91af;">ReservationDto</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(!<span style="color:#2b91af;">DateTime</span>.<span style="color:#74531f;">TryParse</span>(<span style="font-weight:bold;color:#1f377f;">dto</span>.Date,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">date</span>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">$&quot;InvalidÂ date:Â </span>{<span style="font-weight:bold;color:#1f377f;">dto</span>.Date}<span style="color:#a31515;">.&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">date</span>&nbsp;<span style="font-weight:bold;color:#74531f;">&lt;</span>&nbsp;<span style="color:#2b91af;">DateTime</span>.Now)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">$&quot;InvalidÂ date:Â </span>{<span style="font-weight:bold;color:#1f377f;">dto</span>.Date}<span style="color:#a31515;">.&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;&quot;</span>;
}</pre>
	</p>
	<p>
		That's an impure action annotated with the <code>[Pure]</code> attribute. It still compiles and passes all tests (if you run them before December 21, 2021). The annotation is a lie.
	</p>
	<p>
		As I've already implied, you also have the compound problem that you need to know the purity (or lack thereof) of all APIs from the base library or third-party libraries. Can you be sure that no pure function becomes impure when you update a library from version 2.3.1 to 2.3.2?
	</p>
	<p>
		I'm not aware of any robust automated way to verify referential transparency in mainstream programming languages.
	</p>
	<h3 id="5413987a6af14316aee1b1de82aee73d">
		Language support <a href="#5413987a6af14316aee1b1de82aee73d" title="permalink">#</a>
	</h3>
	<p>
		While no mainstream languages distinguish between pure functions and impure actions, there are languages that do. The most famous of these is <a href="https://www.haskell.org">Haskell</a>, but other examples include <a href="http://www.purescript.org">PureScript</a> and <a href="https://www.idris-lang.org">Idris</a>.
	</p>
	<p>
		I find Haskell useful for exactly that reason. The compiler enforces the functional interaction law. You can't call impure actions from pure functions. Thus, you wouldn't be able to make a change to a function like <code>Validate</code> without changing its type. That would break most consuming code, which is a good thing.
	</p>
	<p>
		You could write an equivalent to the original, pure version of <code>Validate</code> in Haskell like this:
	</p>
	<p>
		<pre><span style="color:#2b91af;">validateReservation</span>&nbsp;::&nbsp;<span style="color:blue;">ReservationDTO</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Either</span>&nbsp;<span style="color:#2b91af;">String</span>&nbsp;<span style="color:blue;">ReservationDTO</span>
validateReservation&nbsp;r@(ReservationDTO&nbsp;_&nbsp;d&nbsp;_&nbsp;_&nbsp;_)&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">case</span>&nbsp;readMaybe&nbsp;d&nbsp;<span style="color:blue;">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;Nothing&nbsp;-&gt;&nbsp;Left&nbsp;$&nbsp;<span style="color:#a31515;">&quot;Invalid&nbsp;date:&nbsp;&quot;</span>&nbsp;++&nbsp;d&nbsp;++&nbsp;<span style="color:#a31515;">&quot;.&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;Just&nbsp;(_&nbsp;::&nbsp;LocalTime)&nbsp;-&gt;&nbsp;Right&nbsp;r</pre>
	</p>
	<p>
		This is a pure function, because all Haskell functions are pure by default.
	</p>
	<p>
		You can change it to also check for reservations in the past, but only if you also change the type:
	</p>
	<p>
		<pre><span style="color:#2b91af;">validateReservation</span>&nbsp;::&nbsp;<span style="color:blue;">ReservationDTO</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">IO</span>&nbsp;(<span style="color:#2b91af;">Either</span>&nbsp;<span style="color:#2b91af;">String</span>&nbsp;<span style="color:blue;">ReservationDTO</span>)
validateReservation&nbsp;r@(ReservationDTO&nbsp;_&nbsp;d&nbsp;_&nbsp;_&nbsp;_)&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">case</span>&nbsp;readMaybe&nbsp;d&nbsp;<span style="color:blue;">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;Nothing&nbsp;-&gt;&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;Left&nbsp;$&nbsp;<span style="color:#a31515;">&quot;Invalid&nbsp;date:&nbsp;&quot;</span>&nbsp;++&nbsp;d&nbsp;++&nbsp;<span style="color:#a31515;">&quot;.&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;Just&nbsp;date&nbsp;-&gt;&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;utcNow&nbsp;&lt;-&nbsp;getCurrentTime
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tz&nbsp;&lt;-&nbsp;getCurrentTimeZone
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;now&nbsp;=&nbsp;utcToLocalTime&nbsp;tz&nbsp;utcNow
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;date&nbsp;&lt;&nbsp;now
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;Left&nbsp;$&nbsp;<span style="color:#a31515;">&quot;Invalid&nbsp;date:&nbsp;&quot;</span>&nbsp;++&nbsp;d&nbsp;++&nbsp;<span style="color:#a31515;">&quot;.&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;Right&nbsp;r</pre>
	</p>
	<p>
		Notice that I had to change the return type from <code>Either String ReservationDTO</code> to <code>IO (Either String ReservationDTO)</code>. The presence of <code>IO</code> marks the 'function' as impure. If I hadn't changed the type, the code simply wouldn't have compiled, because <code>getCurrentTime</code> and <code>getCurrentTimeZone</code> are impure actions. These types ripple through entire code bases, enforcing the functional interaction law at every level of the code base.
	</p>
	<h3 id="938b7dc2db644b6b94f6a484d65bb320">
		Pure date validation <a href="#938b7dc2db644b6b94f6a484d65bb320" title="permalink">#</a>
	</h3>
	<p>
		How would you validate, then, that a reservation is in the future? In Haskell, like this:
	</p>
	<p>
		<pre><span style="color:#2b91af;">validateReservation</span>&nbsp;::&nbsp;<span style="color:blue;">LocalTime</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">ReservationDTO</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Either</span>&nbsp;<span style="color:#2b91af;">String</span>&nbsp;<span style="color:blue;">ReservationDTO</span>
validateReservation&nbsp;now&nbsp;r@(ReservationDTO&nbsp;_&nbsp;d&nbsp;_&nbsp;_&nbsp;_)&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">case</span>&nbsp;readMaybe&nbsp;d&nbsp;<span style="color:blue;">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;Nothing&nbsp;-&gt;&nbsp;Left&nbsp;$&nbsp;<span style="color:#a31515;">&quot;Invalid&nbsp;date:&nbsp;&quot;</span>&nbsp;++&nbsp;d&nbsp;++&nbsp;<span style="color:#a31515;">&quot;.&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;Just&nbsp;date&nbsp;-&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;date&nbsp;&lt;&nbsp;now
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;Left&nbsp;$&nbsp;<span style="color:#a31515;">&quot;Invalid&nbsp;date:&nbsp;&quot;</span>&nbsp;++&nbsp;d&nbsp;++&nbsp;<span style="color:#a31515;">&quot;.&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;Right&nbsp;r</pre>
	</p>
	<p>
		This function remains pure, although it still changes type. It now takes an additional <code>now</code> argument that represents the current time. You can retrieve the current time as an impure action before you call <code>validateReservation</code>. Impure actions can always call pure functions. This enables you to keep your complex domain model pure, which makes it simpler, and easier to test.
	</p>
	<p>
		Translated to C#, that corresponds to this version of <code>Validate</code>:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Validate</span>(<span style="color:#2b91af;">DateTime</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">now</span>,&nbsp;<span style="color:#2b91af;">ReservationDto</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(!<span style="color:#2b91af;">DateTime</span>.<span style="color:#74531f;">TryParse</span>(<span style="font-weight:bold;color:#1f377f;">dto</span>.Date,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">date</span>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">$&quot;Invalid&nbsp;date:&nbsp;</span>{<span style="font-weight:bold;color:#1f377f;">dto</span>.Date}<span style="color:#a31515;">.&quot;</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">date</span>&nbsp;<span style="font-weight:bold;color:#74531f;">&lt;</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">now</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">$&quot;Invalid&nbsp;date:&nbsp;</span>{<span style="font-weight:bold;color:#1f377f;">dto</span>.Date}<span style="color:#a31515;">.&quot;</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;&quot;</span>;
}</pre>
	</p>
	<p>
		This version takes an additional <code>now</code> input parameter, but remains deterministic and free of side effects. Since it's pure, it's trivial to unit test.
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2010-01-01&nbsp;00:01&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2011-09-11&nbsp;18:30&quot;</span>,&nbsp;3)]
[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2019-11-26&nbsp;13:59&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2019-11-26&nbsp;19:00&quot;</span>,&nbsp;2)]
[<span style="color:#2b91af;">InlineData</span>(<span style="color:#a31515;">&quot;2030-10-02&nbsp;23:33&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;2030-10-03&nbsp;00:00&quot;</span>,&nbsp;2)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">ValidDate</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">now</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">reservationDate</span>,&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">quantity</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ReservationDto</span>&nbsp;{&nbsp;Date&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">reservationDate</span>,&nbsp;Quantity&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">quantity</span>&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#2b91af;">Validator</span>.<span style="color:#74531f;">Validate</span>(<span style="color:#2b91af;">DateTime</span>.<span style="color:#74531f;">Parse</span>(<span style="font-weight:bold;color:#1f377f;">now</span>),&nbsp;<span style="font-weight:bold;color:#1f377f;">dto</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Empty</span>(<span style="font-weight:bold;color:#1f377f;">actual</span>);
}</pre>
	</p>
	<p>
		Notice that while the <code>now</code> parameter plays the <em>role</em> of the current time, the fact that it's just a value makes it trivial to run <em>simulations</em> of what would have happened if you ran this function in 2010, or what will happen when you run it in 2030. A test is really just a simulation by another name.
	</p>
	<h3 id="67101ecee7b94a849b24126ac01851fe">
		Summary <a href="#67101ecee7b94a849b24126ac01851fe" title="permalink">#</a>
	</h3>
	<p>
		Most programming languages don't explicitly distinguish between pure and impure code. This doesn't make it impossible to do functional programming, but it makes it arduous. Since the language doesn't help you, you must constantly review changes to the code and its dependencies to evaluate whether code that's supposed to be pure remains pure.
	</p>
	<p>
		Tests can help, particularly if you employ <a href="/property-based-testing-intro">property-based testing</a>, but vigilance is still required.
	</p>
	<p>
		While Haskell isn't a mainstream programming language, I find that it helps me flush out my wrong assumptions about functional programming. I write many prototypes and proofs of concept in Haskell for that reason.
	</p>
	<p>
		Once you get the hang of it, it becomes easier to spot sources of impurity in other languages as well.
		<ul>
			<li>Anything with the <code>void</code> return type must be assumed to induce side effects.</li>
			<li>Everything that involves random numbers is non-deterministic.</li>
			<li>Everything that relies on the system clock is non-deterministic.</li>
			<li>Generating a GUID is non-deterministic.</li>
			<li>Everything that involves input/output is non-deterministic. That includes the file system and everything that involves network communication. In C# this implies that all <a href="/2016/04/11/async-as-surrogate-io">asynchronous APIs should be considered highly suspect</a>.</li>
		</ul>
		If you want to harvest the benefits of functional programming in a mainstream language, you must look out for such pitfalls. There's no tooling to assist you.
	</p>
</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	<div class="comment" id="1925963B8A194CF9BC44E0EB59E92C9C">
		<div class="comment-author"><a href="http://criticalsoftwareblog.com">Yacoub Massad</a></div>
		<div class="comment-content">
			<p>
				You might be interested in taking a look at <a href="https://github.com/ymassad/PurityAnalyzer">PurityAnalyzer</a>; An open source roslyn-based analyzer for C# that I started developing to help maintain pure C# code.
			</p>
			<p>
				Unfortunately, it is still not production-ready yet and I didn't have time to work on it in the last year. I was hoping contributors would help.
			</p>
		</div>
		<div class="comment-date">2020-02-24 08:16 UTC</div>
	</div>

	<div class="comment" id="50049d1906e04e1ab3811765ca5c3156">
	    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
	    <div class="comment-content">
	    	<p>
	    		Yacoub, thank you for writing. I wasn't aware of PurityAnalyzer. Do I understand it correctly that it's based mostly on a table of methods known (or assumed) to be pure? It also seems to look for certain attributes, under the assumption that if a <code>[Pure]</code> attribute is present, then one can trust it. Did I understand it correctly?
	    	</p>
	    	<p>
	    		The fundamental problems with such an approach aside, I can't think of a better solution for the current .NET platform. If you want contributors, though, you should edit the repository's readme-file so that it explains how the tool works, and how contributors could get involved.
	    	</p>
	    </div>
	    <div class="comment-date">2020-02-26 7:12 UTC</div>
	</div>
	<div class="comment" id="D45AAB9A9C2C4625BD949B2130416D79">
		<div class="comment-author"><a href="http://criticalsoftwareblog.com">Yacoub Massad</a></div>
		<div class="comment-content">
			<p >Here are the answers to your questions:</p>

			<p >1.it's based mostly on a table of methods known (or assumed) to be pure?</p>

			<p >This is true for compiled methods, e.g., methods in the .NET frameworks. There are lists maintained for .NET methods that are pure. The lists of course are still incomplete.</p>

			<p >For methods in the source code, the analyzer checks if they call impure methods, but it also checks other things like whether they access mutable state. The list of other things is not trivial. If you are interested in the details, see <a href="https://www.dotnetcurry.com/csharp/1464/pure-code-csharp"> this article</a>. It shows some of the details.</p>

			<p >2. It also seems to look for certain attributes, under the assumption that if a [Pure] attribute is present, then one can trust it. Did I understand it correctly?</p>

			<p >I don't use the [Pure] attribute because I think that the definition of pure used by Microsoft with this attribute is different than what I consider to be pure. I used a special [IsPure] attribute. There are also other attributes like [IsPureExceptLocally], [IsPureExceptReadLocally], [ReturnsNewObject], etc. The article I mentioned above explains some differences between these.</p>

			<p >I agree with you that I should work on readme file to explain details and ask for contributors.</p>
		</div>
		<div class="comment-date">2020-02-26 09:51 UTC</div>
	</div>
	<div class="comment" id="d28c24c07228400f9ed141f97b5c72b5">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<p>
				I love this post and enthusiastically agree with all the points you made.
			</p>
			<blockquote>
				Is the method deterministic? It seems like it. In fact, in order to answer that question, you need to know if <code>DateTime.TryParse</code> is deterministic. Assume that it is.
			</blockquote>
			<p>
				For what its worth, that <a href="https://referencesource.microsoft.com/#mscorlib/system/datetime.cs,1466">overload of <code>DateTime.TryParse</code></a> is impure because it depends on <a href="https://referencesource.microsoft.com/#mscorlib/system/globalization/datetimeformatinfo.cs,d8a79667802e6102"><code>DateTimeFormatInfo.CurrentInfo</code></a>, which depends on <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.currentculture?view=netframework-4.8#System_Threading_Thread_CurrentCulture"><code>System.Threading.Thread.CurrentThread.CurrentCulture</code></a>, which is mutable.
			</p>
			<blockquote>
				There are lists maintained for .NET methods that are pure.
			</blockquote>
			<p>
				Yacoub, could you share some links to such lists?
			</p>
		</div>
		<div class="comment-date">2020-02-26 20:14 UTC</div>
	</div>

	<div class="comment" id="d2cd79f75b0c4904bd55f34887513b61">
	    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
	    <div class="comment-content">
	    	<p>
	    		Tyson, I actually knew that, but in order to keep the example simple and compelling, I chose to omit that fact. That's why I phrased the sentence "<em>Assume</em> that it is" (my emphasis) ðŸ˜‰
	    	</p>
	    </div>
	    <div class="comment-date">2020-02-26 21:56 UTC</div>
	</div>
	<div class="comment" id="CED4372686884B47B7FCC4CC03A50C47">
		<div class="comment-author"><a href="http://criticalsoftwareblog.com">Yacoub Massad</a></div>
		<div class="comment-content">
			<p>
				Tyson, I meant lists maintained as part of the PurityAnalyzer project. You can find them <a href="https://github.com/ymassad/PurityAnalyzer/tree/master/PurityAnalyzer/Resources">here</a>.
			</p>
		</div>
		<div class="comment-date">2020-02-27 07:48 UTC</div>
	</div>

	<div class="comment" id="0d0c85170c1c4062addf406f189c0984">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<blockquote>
				The [Haskell] compiler enforces the functional interaction law. You can't call impure actions from pure functions.
			</blockquote>
			<p>
				And in contrast, the C# compiler does not enfore the functional interaction law, right?
			</p>
			<p>
				For exampe, suppose <code>Foo</code> and <code>Bar</code> are pure functions such that <code>Foo</code> calls <code>Bar</code> and the code compiles.  Then only change the implementation of <code>Bar</code> in such a way that it is now impure and the code still compiles, which is possible.  So <code>Foo</code> is now also impure as well, but its implementation didn't change.  Therefore, the C# compiler does not enfore the functional interaction law.
			</p>
			<p>
				Is this consistent with what you mean by the functional interaction law?
			</p>
		</div>
		<div class="comment-date">2020-03-07 12:59 UTC</div>
	</div>

	<div class="comment" id="2d47bc8c9c07456091f923ea5298cd7e">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Tyson, thank you for writing. The C# compiler doesn't help protect your <em>intent</em>, if your intent is to apply a functional architecture.
			</p>
			<p>
				In your example, <code>Foo</code> starts out pure, but becomes impure. That's a <em>result</em> of the law. The law itself isn't broken, but the relationships change. That's often not what you want, so you can say that the compiler doesn't help you maintain a functional architecture.
			</p>
			<p>
				A compiler like Haskell protects the intent of the law. If <code>foo</code> (Haskell functions <em>must</em> start with a lower-case letter) and <code>bar</code> both start out pure, <code>foo</code> can call <code>bar</code>. When <code>bar</code> later becomes impure, its type changes and <code>foo</code> can no longer invoke it.
			</p>
			<p>
				I can try to express the main assertion of the functional interaction law like this: <em>a pure function can't call an impure action.</em> This has different implications in different compiler contexts. In Haskell, functions can be statically declared to be either pure or impure. This means that the Haskell compiler can prevent pure functions from calling impure actions. In C#, there's no such distinction at the type level. The implication is therefore different: that if <code>Foo</code> calls <code>Bar</code> and <code>Bar</code> is impure, then <code>Foo</code> must also be impure. This follows by elimination, because a pure function can't call an impure action. Therefore, since <code>Foo</code> <em>can</em> call <code>Bar</code>, and <code>Bar</code> is impure, then <code>Foo</code> must also be impure.
			</p>
			<p>
				The causation is reversed, so to speak.
			</p>
			<p>
				Does that answer your question?
			</p>
		</div>
		<div class="comment-date">2020-03-08 11:32 UTC</div>
	</div>

	<div class="comment" id="32759f1428c34fd0860e57c077df2972">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<p>
				Yes, that was a good answer.  Thank you.
			</p>
			<blockquote>
				...a pure function can't call an impure action.
			</blockquote>
			<p>
				We definitely want this to be true, but let's try to make sure it is.  What do you think about the C# function <code>void Foo() =&gt; DateTime.Now;</code>?  It has lots of good propertie: it alreays returns the same value (something isomorphic to <code>Unit</code>), and it does not mutate anything.  However, it calls the impure property <code>DateTime.Now</code>.  I think a reasonable person could argue that this function is pure.  My guess is that you would say that it is impure.  Am I right?  I am willing to accept that.
			</p>
			<blockquote>
				...a <a href="https://en.wikipedia.org/wiki/Pure_function">pure function</a> has to obey two rules:
				<ul>
					<li>The same input always produces the same output.</li>
					<li>Calling it causes no side effects.</li>
				</ul>
			</blockquote>
			<p>
				Is it possible for a function to violate the first rule but not violate the second rule?
			</p>
		</div>
		<div class="comment-date">2020-03-09 04:12 UTC</div>
	</div>

	<div class="comment" id="a7375c806c1147c1b37187834fb04153">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Tyson, I'm going to assume that you mean something like <code>void Foo() { var _ = DateTime.Now; }</code>, since the code you ask about doesn't compile ðŸ˜‰
			</p>
			<p>
				That function is, indeed pure, because it has no observable side effects, and it always <a href="/2018/01/15/unit-isomorphisms">returns unit</a>. Purity is mostly a question of what we can observe if we consider the function a black box.
			</p>
			<p>
				Obviously, based on that criterion, we can refactor the function to <code>void Foo() { }</code> and we wouldn't be able to tell the difference. This version of <code>Foo</code> is clearly pure, although degenerate.
				<blockquote>
					Is it possible for a function to violate the first rule but not violate the second rule?
				</blockquote>
				Yes, the following method is non-deterministic, but has no side effects: <code>DateTime Foo() =&gt; DateTime.Now;</code> The input is always <em>unit</em>, but the return value can change.
			</p>
		</div>
		<div class="comment-date">2020-03-10 9:03 UTC</div>
	</div>

	<div class="comment" id="60eb2b1f83dd4b2fbc0be684d729af96">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<p>
				I think I need to practice test driven comment writing ;)  Thanks for seeing through my syntax errors again.
			</p>
			<p>
				Oh, you think that that function is pure.  Interesting.  It follows then that the functional interaction law (pure functions cannot call impure actions) does <i>not</i> follow from the definition of a pure function.  It is possible, in theory and in practice, for a pure function to call an impure action.  Instead, the functional interaction law is "just" a goal to aspire to when designing a programming language.  Haskell achieved that goal while C# and F# did not.  Do you agree with this?  (This is really what I was driving towards in <a href="https://blog.ploeh.dk/2020/02/24/discerning-and-maintaining-purity/#0d0c85170c1c4062addf406f189c0984">this comment above</a>, but I was trying to approach this "blasphemous" claim slowly.)
			</p>
			<p>
				Just as you helped me distinguish between function purity and totality in <a href="https://blog.ploeh.dk/2015/05/07/functional-design-is-intrinsically-testable/#97e4ae29436e4828813bf445ee1c37dc">this comment</a>, I think it would be helpful for us to consider separately the two defining properties of a pure function.  The first property is "the same input always produces the same output".  Let's call this weak determinism.  <a href="https://en.wikipedia.org/wiki/Deterministic_algorithm">Determinism</a> is could be defined as "the same input always produces the same sequence of states", which includes the state of the output, so determinism is indeed stronger than weak determinism.  The second property is "causes no side effect".  It seems to me that there is either a lack of consensus or a lack of clarity about what constitutes a side effect.  One definition I like is mutation of state outside of the current stack frame.
			</p>
			<p>
				One reason the functional interaction law is false in general is because the corresponding interaction law for weak determinism also false in general.  The function I gave above (that called <code>DateTime.Now</code> and then returned unit) is a trivial example of that.  A nontrivial example is <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a>.
			</p>
			<p>
				At this point, I wanted to claim that the side effect interaction law is true in general, but it is not.  This law says that a function that is side-effect free cannot call a function that causes a side effect.  A counterexample is <code>void Foo() { int i = 0; Bar(ref i); }</code> with <code>void Bar(ref int i) => i++;</code>.  That is, <code>Bar</code> mutates state outside of its stack frame, namely in the stack frame of <code>Foo</code>, so it is not side-effect free, but <code>Foo</code> is.  (And I promise that I tested that code for compiler errors.)
			</p>
			<p>
				I need to think more about that.  Is there a better definition of side effect, one for which the side effect interaction law is true?
			</p>
			<p>
				I just realized something that I think is interesting.  Purely functional programming languages enforce a property of functions stronger than purity.  With respect to the first defining property of a pure function (aka weak determinism), purely functional programming languages enforce the stronger notion of determinism.  Otherwise, the compiler would need to realize that functions like quicksort should be allowed (because it is  weakly deterministic).  This reminds me of the debate between static and dynamic programming languages.  In the process of forbidding certain unsafe code, static languages end up forbidding some safe code as well.
			</p>
		</div>
		<div class="comment-date">2020-03-10 14:05 UTC</div>
	</div>

	<div class="comment" id="dd776b1b8b0d43c58171ff7fec311c2c">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Tyson, I disagree with your basic premise:
				<blockquote>
					"It follows then that the functional interaction law (pure functions cannot call impure actions) does not follow from the definition of a pure function."
				</blockquote>
				I don't think that this follows.
			</p>
			<p>
				The key is that your example is <em>degenerate</em>. The <code>Foo</code> function is only pure because <code>DateTime.Now</code> isn't used. The actual, underlying property that we're aiming for is <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>. Can you replace <code>Foo</code> with its value? Yes, you can.
			</p>
			<p>
				Perhaps you think this is a hand-wavy attempt to dodge a bullet, but I don't think that it is. You can write the equivalent function in Haskell like this:
			</p>
			<p>
				<pre><span style="color:#2b91af;">foo</span>&nbsp;::&nbsp;()&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;()
foo&nbsp;<span style="color:blue;">()</span>&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;_&nbsp;=&nbsp;getCurrentTime
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;<span style="color:blue;">()</span></pre>
			</p>
			<p>
				I don't recall if you're familiar with Haskell, but for the benefit of any reader who comes by and wishes to follow this discussion, here are the important points:
				<ul>
					<li>The function calls <code>getCurrentTime</code>, which is an impure action. Its type is <code>IO UTCTime</code>. The <code>IO</code> <a href="https://bartoszmilewski.com/2014/01/14/functors-are-containers">container</a> marks the action as impure.</li>
					<li>The underscore is a <em>wildcard</em> that tells Haskell to discard the value.</li>
					<li>The type of <code>foo</code> is <code>() -&gt; ()</code>. It takes <a href="/2018/01/15/unit-isomorphisms">unit</a> as input and returns <em>unit</em>. There's no <code>IO</code> container involved, so the function is pure.</li>
				</ul>
				This works because Haskell is a strictly functional language. Every expression is referentially transparent. The implication is that something like <code>IO UTCTime</code> is an <em>opaque</em> container of <code>UTCTime</code> values. A pure caller can see the container, but not its contents. A common interpretation of this is that <code>IO</code> represents the superposition of all possible values, just like <a href="https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat">SchrÃ¶dinger's box</a>. Also, since Haskell is a lazily evaluated language, actions are only evaluated when their values are needed for something. Since the value of <code>getCurrentTime</code> is discarded, the impure action never runs (the box is never opened). This may be clearer with this example:
			</p>
			<p>
				<pre><span style="color:#2b91af;">bar</span>&nbsp;::&nbsp;()&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;()
bar&nbsp;<span style="color:blue;">()</span>&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;_&nbsp;=&nbsp;<span style="color:blue;">putStrLn</span>&nbsp;<span style="color:#a31515;">&quot;Bar!&quot;</span>
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;<span style="color:blue;">()</span></pre>
			</p>
			<p>
				Like <code>foo</code>, <code>bar</code> calls an impure action: <code>putStrLn</code>, which corresponds to <code>Console.WriteLine</code>. Having the type <code>String -&gt; IO ()</code> it's impure. It works like this:
			</p>
			<p>
				<pre>&gt; putStrLn "Example"
Example</pre>
			</p>
			<p>
				None the less, because <code>bar</code> discards the <code>IO ()</code> return value after it calls <code>putStrLn</code>, it never evaluates:
			</p>
			<p>
				<pre>&gt; bar ()
()</pre>
			</p>
			<p>
				Perhaps a subtle rephrasing of the functional interaction law would be more precise. Perhaps it should say that a pure function can't <em>evaluate</em> an impure action.
			</p>
			<p>
				Bringing this back to C#, we have to keep in mind that C# doesn't enforce the functional interaction law in any way. Thus, the law works ex-post, instead of in Haskell, where it works ex-ante. Is the <code>Foo</code> C# code pure? Yes, it is, because it's referentially transparent.
			</p>
			<p>
				Regarding the purity of QuickSort, you may find <a href="https://stackoverflow.com/q/7717691/126014">this discussion</a> interesting.
			</p>
		</div>
		<div class="comment-date">2020-03-12 7:40 UTC</div>
	</div>

	<div class="comment" id="a06da27b57944c89aefc16914234939c">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<blockquote>
				...Haskell is a strictly functional language. Every expression is referentially transparent. ... Is the <code>Foo</code> C# code pure? Yes, it is, because it's referentially transparent.
			</blockquote>
			<p>
				So every function in Haskell is referentially transparent, and if a funciton in C# is referentially transparent, then it is pure.  Is C# necessary there?  Does referential transparency impliy purity regardless of langauge?  Do you consider purity and referential transparency to be concepts that imply each other regulardless of language?  I think a function is referential transparency if and only if it is pure, and I think this is independent of the langauge.
			</p>
			<p>
				If C# is not necessary, then it follows that every function in Haskell is pure.  This seems like a contradiction with this statement.
			</p>
			<blockquote>
				The function calls <code>getCurrentTime</code>, which is an impure action. Its [return] type is <code>IO UTCTime</code>. The <code>IO</code> <a href="https://bartoszmilewski.com/2014/01/14/functors-are-containers">container</a> marks the action as impure.
			</blockquote>
			<p>
				You cited Bartosz Milewski there.  <a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/3-pure-functions-laziness-io#pure-functions">He also says</a> that every function in Haskell is pure.  He calls Haskell functions returning IO a pure action.  I agree with Milewski; I think every function in Haskell is pure.
			</p>
			<blockquote>
				Perhaps a subtle rephrasing of the functional interaction law would be more precise. Perhaps it should say that a pure function can't <em>evaluate</em> an impure action.
			</blockquote>
			<p>
				How does this rephrasing help?  In the exmaple from my previous comment, <code>bar</code> is impure while <code>foo</code> is pure even though <code>foo</code> evaluates <code>bar</code>, which can be verified by putting a breakpoint in <code>bar</code> when evaluating <code>foo</code> or by observing that <code>i</code> has value <code>1</code> when <code>foo</code> returns.  If Haskell contained impure functions, then replacing "calls" with "evalutes" helps because everything is lazy in Haskell, but I don't see how it helps in an eager langauge like C#.
			</p>
			<blockquote>
				Regarding the purity of QuickSort, you may find <a href="https://stackoverflow.com/q/7717691/126014">this discussion</a> interesting.
			</blockquote>
			<p>
				Oh, sorry.  I now see that my reference to quicksort was unclear.  I meant the randomized version of quicksort for the pivot is selected uniformily at random from all elements being sorted.  That refrasing of the functional interaction law doesn't address the issue I am trying to point out with quicksort.  To elborate, consider this randomized version of quicksort that has no side effects.  I think this function is pure even though it uses randomness, which is necessarily obtained from an impure function.
			</p>
		</div>
		<div class="comment-date">2020-07-06 13:57 UTC</div>
	</div>

	<div class="comment" id="9f9664e29c3f4fafa786abae039eb20e">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Tyson, my apologies that I've been so dense. I think that I'm beginning to understand where you're going with this. Calling out randomised pivot selection in quicksort helped, I think.
			</p>
			<p>
				I would consider a quicksort function referentially transparent, even if it were to choose the pivot at random. Even if it does that, you can replace a given function call with its output. The only difference you might observe across multiple function calls would be varying execution time, due to lucky versus unlucky random pivot selection. Execution time is, however, not a property that impacts whether or not we consider a function pure.
			</p>
			<p>
				<em>Safe Haskell</em> can't do that, though, so you're correct when you say:
				<blockquote>
					"In the process of forbidding certain unsafe code, static languages end up forbidding some safe code as well."
				</blockquote>
				(Actually, you <em>can</em> implement quicksort like that in Haskell as well. In order to not muddy the waters, I've so far ignored that the language has an escape hatch for (among other purposes) this sort of scenario: <code>unsafePerformIO</code>. In <em>Safe Haskell</em>, however, you can't use it, and I've never myself had to use it.)
			</p>
			<p>
				I'm going to skip the discussion about whether or not all of Haskell is pure, because I think it's a red herring. We can discuss it later, if you're interested.
			</p>
			<p>
				I think that you're right, though, that the functional interaction law has to come with a disclaimer. I'm not sure exactly how to formulate it, but I need to take a detour around side effects, and then perhaps you can help me with that.
			</p>
			<p>
				Functional programmers know that every execution has side effects. In the extreme, running any calculation on a computer produces heat. There could be other side effects as well, such as CPU registers changing values, data moving in and out of processor caches, and so on. The question is: when do side effects become significant?
			</p>
			<p>
				We don't consider the generation of heat a significant side effect. What about a debug trace? If it doesn't affect the state of the system, does it count? If not, then how about logging or auditing?
			</p>
			<p>
				We usually draw the line somewhere and say that anything on one side counts, and things on the other side don't. The bottom line is, though, that we consider some side effects insignificant.
			</p>
			<p>
				I think that you have now demonstrated that there's symmetry. Not only are there insignificant side effects, but insignificant randomness also exists. The randomness involved in choosing a pivot in quicksort has no significant impact on the output.
			</p>
			<p>
				Was that what you meant by <em>weak determinism?</em>
			</p>
		</div>
		<div class="comment-date">2020-07-07 19:53 UTC</div>
	</div>
</div>
