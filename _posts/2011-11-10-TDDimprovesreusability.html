---
layout: post
tags: [Unit Testing]
date: 2011-11-10 16:55:10 UTC
title: "TDD improves reusability"
description: "The unit tests are the first client of the production API. Production code is reuse."
---
{% include JB/setup %}

<div id="post">
	<p>There's this meme going around that software <a href="http://www.udidahan.com/2009/06/07/the-fallacy-of-reuse/">reuse is a fallacy</a>. Bollocks! The <em>reuse is a fallacy meme</em> is a fallacy :) To be fair, I'm not claiming that everything can and should be reused, but my claim is that all code produced by Test-Driven Development (TDD) is being reused. Here's why:</p> <p>When tests are written first, they act as a kind of <a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>. Tests tease out the API of the <a href="http://xunitpatterns.com/SUT.html">SUT</a>, as well as its behavior. In this point in the development process, the tests serve as a feedback mechanism. Only later, when the tests and the SUT stabilize, will the tests be repurposed (dare I say â€˜reused'?) as regression tests. In other words: over time, tests written during TDD have more than one role:</p> <ol> <li>Feedback mechanism  <li>Regression test</li></ol> <p>Each test plays one of these roles at a time, but not both.</p> <p>While the purpose of TDD is to evolve the SUT, the process produces two types of artifacts:</p> <ol> <li>Tests  <li>Production code</li></ol> <p>Notice how the tests appear <em>before</em> the production code, which is an artifact of the test code.</p> <blockquote> <p>The unit tests are the <em>first</em> client of the production API.</p></blockquote> <p>When the production code is composed into an application, that application becomes the <em>second</em> client, so it <em>reuses</em> the API. This is a very beneficial effect of TDD, and probably one of the main reasons why TDD, if done correctly, produces code of high quality.</p> <p>A colleague once told me (when referring to scale-out) that the hardest step is to go from one server to two servers, and I've later found that principle to apply much more broadly. Generalizing from a single case to two distinct cases is often the hardest step, and it becomes much easier to generalize further from two to an arbitrary number of cases.</p> <p>This explains why TDD is such an efficient process. Apart from the beneficial side effect of producing a regression test suite, it also ensures that at the time the API goes into production, it's already being shared (or reused) between at least two distinct clients. If, at a later time, it becomes necessary to add a third client, the hard part is already done.</p> <p>TDD produces reusable code because the production application reuses the API which were realized by the tests.</p>
</div>
	
<div id="comments">
<hr>
<h2 id="comments-header">
	Comments
</h2>
	<div class="comment" id="e6e9f5bade0d4e08912eaa5b24da1760">
	<div class="comment-author">Martin</div>
	<div class="comment-content">I am a junior developer and I am doing TDD for a small project right now and I can only agree. My code looks much better because i really use it instead of making assumptions how it should be used (ADD - Assumption Driven Development)</div>
	<div class="comment-date">2011-11-10 18:59 UTC</div>
</div>
<div class="comment" id="b599aa90fb2d499aa274a9c5a9d317b1">
	<div class="comment-author"><a href="http://writesoft.wordpress.com">Karep</a></div>
	<div class="comment-content">Hi all TDD fans.<br>
If you are using NUnit for TDD you may find useful NUnit.Snippets NuGet package - &quot;almost every assert is only few keystrokes away&quot; TM ;)<br>
http://writesoft.wordpress.com/2011/08/14/nunit-snippets/<br>
http://nuget.org/List/Packages/NUnit.Snippets </div>
	<div class="comment-date">2011-11-11 12:03 UTC</div>
</div>
<div class="comment" id="0628c767bce948489080ae30c7ea93b0">
	<div class="comment-author"><a href="http://www.udidahan.com">Udi Dahan</a></div>
	<div class="comment-content">I think that you're equating *using* a class with reusing a class - the two aren't the same.</div>
	<div class="comment-date">2011-11-16 23:04 UTC</div>
</div>
<div class="comment" id="78466c1b528040a5b781958e0e960e4a">
	<div class="comment-author">Simple</div>
	<div class="comment-content">Hello Mark!<br>
<br>
Do you use some test coverage software? <br>
<br>
Is there some free test coverage tools thats worth to use? )<br>
<br>
<br>
<br>
<br>
</div>
	<div class="comment-date">2012-05-11 07:11 UTC</div>
</div>
<div class="comment" id="726e6004ea6c4870b2ec3a5e0162e97e">
	<div class="comment-author">Simple</div>
	<div class="comment-content">Or if you dont know free tools - maybe some commercial tools - but not very expensive ))<br>
<br>
I have found for example &quot;dotcover&quot; from jetbrains - 140 its ok for the company )</div>
	<div class="comment-date">2012-05-11 09:13 UTC</div>
</div>
<div class="comment" id="a5628abcf451420fa9304ad4e275b209">
	<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
	<div class="comment-content">I rarely use code coverage tools. Since I develop code almost exclusively with TDD, I know my coverage is good.<br>
<br>
I still occasionally use code coverage tools when I work in a team environment, so I have nothing against them. When I do, I just use the coverage tool which is built into Visual Studio. When used with the TestDriven.NET Visual Studio add-in it's quite friction-less.</div>
	<div class="comment-date">2012-05-11 18:56 UTC</div>
</div>
</div>