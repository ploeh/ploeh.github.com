---
layout: post
title: "Outside In TDD versus DDD"
date: 2013-03-04 08:01:00 UTC
tags: [Software Design, Unit Testing]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>Is there a conflict between Outside-In TDD and DDD? I don't think so.</em>
	</p>
	<p>
		A reader of <a href="http://affiliate.manning.com/idevaffiliate.php?id=1150_236">my book</a> recently asked me a question:
	</p>
	<blockquote>
		<p>
			"you are a DDD and TDD fan and at the same time you like to design your User Interfaces first. I have been reading about DDD and TDD for some time now and your approach confuses me, TDD is about writing tests first to lead the design, DDD is focusing on the domain yet you start with the UI."
		</p>
	</blockquote>
	<p>
		In my opinion there's no conflict between Outside-In TDD and DDD, but I must admit that I was a bit surprised by the question. It never occurred to me that there's an apparent conflict between these two approaches, but now that I was asked the question, I understand why one would think so. In other words, I think it's a good question that warrants a proper answer.
	</p>
	<p>
		Before discussing the synthesis of Outside-In TDD and DDD I think we need to examine each concept individually.
	</p>
	<p>
		<strong>DDD</strong>
	</p>
	<p>
		As far as I can tell, <a href="http://amzn.to/WBCwx7">Domain-Driven Design</a> is a horribly misunderstood book. By corollary, so is the DDD concept itself. The problem with the book is that it provides value and guidance along two axes:
		<ul>
			<li>Patterns and other coding advice</li>
			<li>Principles for analysis and modeling</li>
		</ul>
		The 'problem' is that all the patterns and coding concepts, such as <em>Aggregate Root</em>, <em>Specification</em>, <em>Factories</em>, <em>Value Objects</em>, <em>Entities</em>, <em>Services</em>, etc. are very useful. However, here's the catch: Many of these constructs are useful in themselves. They aren't really related to <em>Domain</em>-Driven Design. If Eric Evans had written a book called <em>Design Patterns for Supple Design</em>, there would have been much less confusion. He could have written <em>another</em> book with all the rest of the content and called that book "Domain-Driven Design," and less confusion would have ensued.
	</p>
	<p>
		Don't let the fact that all these patterns are described in a book called <em>Domain-Driven Design</em> trick you into thinking that they are intrinsically bound to DDD. Using the patterns don't make your code Domain-Driven, and you can do DDD <em>without</em> them. Obviously, you can also combine them.
	</p>
	<p>
		This provides a partial answer to the original question. Outside-In TDD doesn't conflict with the patterns described in <em>Domain-Driven Design</em>, just as it doesn't conflict with most other design patterns.
	</p>
	<p>
		That still leaves the 'true' DDD: the principles for analyzing and modeling the subject matter for a piece of software. If that is a design technique, and Outside-In TDD is also a design technique, isn't there a conflict?
	</p>
	<p>
		<strong>Outside-In TDD</strong>
	</p>
	<p>
		Outside-In TDD, as I describe it in <a href="http://pluralsight.com/training/Courses/TableOfContents/outside-in-tdd">my Pluralsight course</a>, isn't a design technique. <a href="http://blog.ploeh.dk/2010/12/22/TheTDDApostate">TDD isn't a design technique.</a> Granted, TDD provides fast <em>feedback</em> about the design you are implementing, but it's not a blind design technique.
	</p>
	<p>
		<strong>Outside-In TDD and DDD</strong>
	</p>
	<p>
		Once you realize that a major reason that Outside-In TDD and DDD seems to be at odds, is because of the false premise that TDD is a design technique, you should also realize that there isn't, after all, any conflict. There's no reason that you can't do both, but it doesn't mean you always should.
		<ul>
			<li>You can do Outside-In TDD without DDD. If you are building a CRUD application, DDD is probably going to be overkill. If so, skip it.</li>
			<li>You can do DDD without Outside-In TDD. If you are being paid to build or extract a true Domain Model, it makes sense to do so decoupled from any sort of application boundaries.</li>
			<li>You can combine Outside-In TDD with DDD, but I think this will often make best sense as an iterative approach. First you build the application. Then you realize that the business logic within the application is so complex that you'll need to extract a proper Domain Model in order to keep it maintainable.</li>
		</ul>
		In the end, remember that your employer/customer pays you to solve a particular problem with software, not to follow a particular software design principle. The reason I often start with the UI or perhaps a RESTful API is that this is the part of the application that the product owner cares about.
	</p>
	<p>
		In my Pluralsight course, I also discuss the <a href="http://martinfowler.com/bliki/TestPyramid.html">Test Pyramid</a>. While it makes sense to <em>begin</em> development at the boundary (e.g. UI) of an application, you shouldn't <em>stay</em> at the boundary. Most tests should still be unit tests. Once you reach the phase where you realize that you'll need to evolve a proper Domain Model, you should do that with unit tests, not boundary tests. Domain Models should be implemented decoupled from all boundaries (UI, I/O and persistence), so you can only directly test a Domain Model with unit tests.
	</p>
	<p>
		In the end, it's all a question of perspective. Outside-In TDD states that you should begin your TDD process at the boundary. In the beginning, it will focus on the externally visible behavior of the system, but as development progresses, other parts of the system must be dealt with. This is where DDD can be valuable. The lack of conflict eventually stems from the fact that Outside-In TDD and DDD operate on different levels of application architecture, with little overlap.
	</p>
	<p>
		In my experience, a lot of applications can be written with Outside-In TDD without a Domain Model ever having to evolve - and still be maintainable. These applications may still employ the 'Supple Design Patterns', but that doesn't mean that they are Domain-Driven.
	</p>
</div>
<hr/>
<div id="comments">
<h2 id="comments-header">Comments</h2>
<div class="comment">
	<div class="comment-author"><a href="http://gorodinski.com">Lev Gorodinski</a></div>
	<div class="comment-content"><p>Thank for this insightful post. It inspired me to write a <a href="http://gorodinski.com/blog/2013/03/11/the-two-sides-of-domain-driven-design/">post</a> about the two sides of DDD.</p>
		<p>PS: IMO, commenting via pull-request is too burdensome. Have you considered Disqus?</p>
	</div>
	<div class="comment-date">2013-03-15 12:22 MST</div>
</div>
</div>
