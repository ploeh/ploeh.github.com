---
layout: post
tags: [Dependency Injection, Software Design]
date: 2011-04-27 12:14:52 UTC
title: "Provider is not a pattern"
---
{% include JB/setup %}

<div id="post">
	<p align="left">Developers exposed to ASP.NET are likely to be familiar with the so-called <a href="http://msdn.microsoft.com/en-us/library/ms972319.aspx">Provider pattern</a>. You see it a lot in that part of the BCL: <a href="http://msdn.microsoft.com/en-us/library/6b241xwt.aspx">Role Provider</a>, <a href="http://msdn.microsoft.com/en-us/library/sx3h274z.aspx">Membership Provider</a>, <a href="http://msdn.microsoft.com/en-us/library/014bec1k.aspx">Profile Provider</a>, etc. Lots of text has already been written about Providers, but the reason I want to add yet another blog post on the topic is because once in a while I get the question on how it relates to Dependency Injection (DI).</p> <p align="left">Is Provider a proper way to do DI?</p> <p align="left">No, it has nothing to do with DI, but as it tries to mimic loose coupling I can understand the confusion.</p> <p align="left">First things first. Let's start with the name. Is it a pattern at all? Regular readers of this blog may get the impression that I'm fond of calling everything and the kitchen sink an anti-pattern. That's not true because I <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorIsAnAntiPattern.aspx">only make that claim when I'm certain I can hold that position</a>, so I'm not going to denounce Provider as an anti-pattern. On the contrary I will make the claim that Provider is not a pattern at all.</p> <p align="left">A design pattern is not <em>invented</em>  -  it's <em>discovered</em> as a repeated solution to a commonly recurring problem. Providers, on the other hand, were invented by Microsoft, and I've rarely seen them used outside their original scope. Secondly I'd also dispute that they solve anything.</p> <p align="left">That aside, however, I want to explain why Provider is bad design:</p> <ul> <li> <div align="left">It uses the Constrained Construction anti-pattern</div> <li> <div align="left">It hides complexity</div> <li> <div align="left">It prevents proper lifetime management</div> <li> <div align="left">It's not testable</div></li></ul> <p align="left">In the rest of this post I will explain each point in detail, but before I do that we need an example to look at. The <a href="http://blog.ploeh.dk/2010/02/02/RefactoringToAggregateServices.aspx">old OrderProcessor example</a> suffices, but instead of injecting IOrderValidator, IOrderCollector, and IOrderShipper this variation uses Providers to provide instances of the Services:</p> <div style="font-family: ; background: white; color: "><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"> <span style="color: "><font color="#2b91af">SuccessResult</font></span> Process(<span style="color: "><font color="#2b91af">Order</font></span> order)</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">{</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#2b91af">IOrderValidator</font></span> validator = </font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#2b91af">ValidatorProvider</font></span>.Validator;</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">bool</font></span> isValid = validator.Validate(order);</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">if</font></span> (isValid)</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; {</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#2b91af">CollectorProvider</font></span>.Collector.Collect(order);</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#2b91af">ShipperProvider</font></span>.Shipper.Ship(order);</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; }</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">return</font></span> <span style="color: "><font color="#0000ff">this</font></span>.CreateStatus(isValid);</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">}</font></pre></div>
<p align="left">The ValidatorProvider uses the configuration system to create and return an instance of IOrderValidator:</p>
<div style="font-family: ; background: white; color: "><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"> <span style="color: "><font color="#0000ff">static</font></span> <span style="color: "><font color="#2b91af">IOrderValidator</font></span> Validator</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">{</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">get</font></span> </font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; {</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">var</font></span> section = </font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font style="font-size: 10pt" color="#2b91af">OrderValidationConfigurationSection</font></span></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .GetSection();</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">var</font></span> typeName = section.ValidatorTypeName;</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">var</font></span> type = <span style="color: "><font color="#2b91af">Type</font></span>.GetType(typeName, <span style="color: "><font color="#0000ff">true</font></span>);</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">var</font></span> obj = <span style="color: "><font color="#2b91af">Activator</font></span>.CreateInstance(type);</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#0000ff">return</font></span> (<span style="color: "><font color="#2b91af">IOrderValidator</font></span>)obj;</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; }</font></pre><pre style="margin: 0px"><font style="font-size: 10pt">}</font></pre></div>
<p align="left">There are lots of details I omitted here. I could have saved the reference for later use instead of creating a new instance each time the property is accessed. In that case I would also have had to make the code thread-safe, so I decided to skip that complexity. The code could also be more defensive, but I'm sure you get the picture.</p>
<p align="left">The type name is defined in the app.config file like this:</p>
<div style="font-family: ; background: white; color: "><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&lt;</font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#a31515">orderValidation</font></span></font><span style="color: "><font style="font-size: 10pt" color="#0000ff"> </font></span></pre><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&nbsp; </font></font></span><font style="font-size: 10pt"><span style="color: "><font color="#ff0000">type</font></span><span style="color: "><font color="#0000ff">=</font></span>"</font><span style="color: "><font style="font-size: 10pt" color="#0000ff">Ploeh.Samples.OrderModel.UnitTest.TrueOrderValidator,</font></span></pre><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ploeh.Samples.OrderModel.UnitTest</font></font></span><font style="font-size: 10pt">"</font><span style="color: "><font style="font-size: 10pt" color="#0000ff"> /&gt;</font></span></pre></div>
<p align="left">Obviously, CollectorProvider and ShipperProvider follow the sameâ€¦ blueprint.</p>
<p align="left">This should be well-known to most .NET developers, so what's wrong with this model?</p>
<p align="left"><strong>Constrained Construction</strong></p>
<p>In <a href="http://affiliate.manning.com/idevaffiliate.php?id=1150_236">my book</a>'s chapter on DI anti-patterns I describe the <em>Constrained Construction</em> anti-pattern. Basically it occurs every time there's an implicit constraint on the constructor of an implementer. In the case of Providers the constraint is that each implementer must have a default constructor. In the example the culprit is this line of code:</p>
<div style="font-family: ; background: white; color: "><pre style="margin: 0px"><span style="color: "><font color="#0000ff"><font style="font-size: 10pt">var</font></font></span><font style="font-size: 10pt"> obj = <span style="color: "><font color="#2b91af">Activator</font></span>.CreateInstance(type);</font></pre></div>
<p>This constrains any implementation of IOrderValidator to have a default constructor, which obviously means that the most fundamental DI pattern Constructor Injection is out of the question.</p>
<p>Variations of the Provider idiom is to supply an Initialize method with a context, but this creates a temporal coupling while still not enabling us to inject arbitrary Services into our implementations. I'm not going to repeat six pages of detailed description of Constrained Construction here, but the bottom line is that you can't fix it  -  you have to refactor towards true DI  -  preferably Constructor Injection.</p>
<p><strong>Hidden complexity</strong></p>
<p>Providers hide the complexity of their implementations. This is not the same as <em>encapsulation</em>. Rather it's a dishonest API and the problem is that it just postpones the moment when you discover how complex the implementation really is.</p>
<p>When you implement a client and use code like the following everything looks <em>deceptively</em> simple:</p>
<div style="font-family: ; background: white; color: "><pre style="margin: 0px"><span style="color: "><font color="#2b91af"><font style="font-size: 10pt">IOrderValidator</font></font></span><font style="font-size: 10pt"> validator = </font></pre><pre style="margin: 0px"><font style="font-size: 10pt">&nbsp;&nbsp;&nbsp; <span style="color: "><font color="#2b91af">ValidatorProvider</font></span>.Validator;</font></pre></div>
<p>However, if this is the only line of code you write it will fail, but you will not notice until run-time. Check back to the implementation of the Validator property if you need to refresh the implementation: there's a lot of things that can go wrong here:</p>
<ul>
<li>The appropriate configuration section is not available in the app.config file. 
<li>The ValidatorTypeName is not provided, or is null, or is malformed. 
<li>The ValidatorTypeName is correctly formed, but the type in question cannot be located by Fusion. 
<li>The Type doesn't have a default constructor. This is one of the other problems of Constrained Construction: it can't be statically enforced because a constructor is not part of an <a href="http://blog.ploeh.dk/2011/02/28/InterfacesAreAccessModifiers.aspx">abstraction's API</a>. 
<li>The created type doesn't implement IOrderValidator.</li></ul>
<p>I'm sure I even forgot a thing or two, but the above list is sufficient for me. None of these problems are caught by the compiler, so you don't discover these issues until you run an integration test. So much for rapid feedback.</p>
<p>I don't like APIs that lie about their complexity.</p>
<blockquote>
<p>Hiding complexity does not make an API easier to use; it makes it harder.</p></blockquote>
<p>An API that hides necessary complexity makes it impossible to discover problems at compile time. It simply creates more friction.</p>
<p><strong>Lifetime management issues</strong></p>
<p>A Provider exerts too much control over the instances it creates. This is a variation of the <em>Control Freak</em> anti-pattern (also from my book). In the current implementation the Validator property totally violates the <a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment">Principle of least surprise</a> since it returns a new instance every time you invoke the getter. I did this to keep the implementation simple (this is, after all, example code), but a more normal implementation would reuse the same instance every time.</p>
<p>However, reusing the same instance every time may be problematic in a multi-threaded context (such as a web application) because you'll need to make sure that the implementation is thread-safe. Often, we'd much prefer to scope the lifetime of the Service to each HTTP request.</p>
<p>HTTP request scoping <em>can</em> be built into the Provider, but then it would <em>only</em> work in web applications. That's not very flexible.</p>
<p>What's even more problematic is that once we move away from the Singleton lifestyle (not to be confused with the Singleton design pattern) we may have a memory leak at hand, since the implementation may implement IDisposable. This can be solved by adding a Release method to each Provider, but now we are moving so far into DI Container territory that I find it far more reasonable to just use proper DI instead of trying to reinvent the wheel.</p>
<p>Furthermore, the fact that each Provider owns the lifetime of the Service it controls makes it impossible to share resources. What if the implementation we want to use implements several <a href="http://martinfowler.com/bliki/RoleInterface.html">Role Interfaces</a> each served up by a different Provider? We might want to use that common implementation to share or coordinate state across different Services, but that's not possible because we can't share an instance across multiple providers.</p>
<p>Even if we configure all Providers with the same concrete class, each will instantiate and serve its own separate instance.</p>
<p><strong>Testability</strong></p>
<p>The Control Freak also impacts testability. Since a Provider creates instances of interfaces based on XML configuration and Activator.CreateInstance, there's no way to inject a dynamic mock.</p>
<p>It <em>is</em> possible to use hard-coded <a href="http://xunitpatterns.com/Test%20Double.html">Test Doubles</a> such as <a href="http://xunitpatterns.com/Test%20Stub.html">Stubs</a> or <a href="http://xunitpatterns.com/Fake%20Object.html">Fakes</a> because we can configure the XML with their type names, but even a <a href="http://xunitpatterns.com/Test%20Spy.html">Spy</a> is problematic because we'll rarely have an object reference to the Test Double.</p>
<p>In short, the Provider idiom is not a good approach to loose coupling. Although Microsoft uses it in some of their products, it only leads to problems, so there's no reason to mimic it. Instead, use Constructor Injection to create loosely coupled components and wire them in the application's <em>Composition Root</em> using the <a href="http://blog.ploeh.dk/2010/09/29/TheRegisterResolveReleasePattern.aspx">Register Resolve Release</a> pattern.</p>
</div>
	
<div id="comments">
<hr>
<h2 id="comments-header">
	Comments
</h2>
	<div class="comment">
	<div class="comment-author"><a href="http://mcdaniel.ws">Michael McDaniel</a></div>
	<div class="comment-content">I have to disagree with your statement that the provider is not a pattern at all.  The provider (in .NET) is a specific implementation of the bridge pattern as defined in &quot;Design Patterns&quot; by Gamma, Helm, Johnson, and Vlissides.  I believe that this description has been lost over the past 10 years as people in the industry have resorted to calling it the &quot;Provider Pattern.&quot;  <br>
<br>
When used correctly as a bridge pattern, the provider does actually solve reoccuring problems very eloquently.  It decouples the interface from the implementation so that the implementation details are hidden from the client.  You can extend the implementation by building on existing implementations to reduce the complexity.  Complexity is only introduced as a by-product of bad design.  <br>
<br>
The notion that the provider interfers with testability is incorrect.  Each individual implementation should be designed from the beginning to be testable.  The bridge is not the entry point for testing the implementor.  The bridge should only be responsible for forwarding client requests to its implementor.  (Therefore the bridge should be testable as well.)  I am not stating that there aren't providers out there that violate this priciple.  I'm merely stating that providers which do this are poorly designed.</div>
	<div class="comment-date">2011-06-27 16:43 UTC</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
	<div class="comment-content">I just reread the Bridge pattern and while I agree that Provider is a specialization of Bridge, I don't agree that this relationship goes the other way. If you read the description of Provider provided in the link above, you'll notice that it goes into very specific details on how a Provider should be implemented, including how it should be backed by the configuration system and that it must be created by clients by a static factory.<br>
<br>
This goes way beyond what the Bridge pattern describes, so I hardly think you can equate the two.<br>
<br>
Especially the part about being created by a static factory which can only read from the configuration system is testability poison.</div>
	<div class="comment-date">2011-06-27 19:25 UTC</div>
</div><div class="comment">
	<div class="comment-author"><a href="http://candordeveloper.com/">Michael Lang</a></div>
	<div class="comment-content">I disagree with your analysis.  Provider model is a pattern.<br>
<br>
I realize this is a year late, but I just found your article a few days ago via a reference on scott hanselmans blog (in comments).  Here is my rebuttal.<br>
http://candordeveloper.com/2012/06/26/provider-model-is-a-solid-pattern/</div>
	<div class="comment-date">2012-06-29 11:31 UTC</div>
</div>
</div>