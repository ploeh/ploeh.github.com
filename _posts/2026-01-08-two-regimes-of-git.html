---
layout: post
title: "Two regimes of Git"
description: "Using Git for CI is not the same as Tactical Git."
date: 2026-01-08 7:37 UTC
tags: [Productivity]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        <a href="https://git-scm.com/">Git</a> is such a versatile tool that when discussing it, interlocutors may often talk past each other. One person's use is so different from the way the next person uses it that every discussion is fraught with risk of misunderstandings. This happens to me a lot, because I use Git in two radically different ways, depending on context.
    </p>
    <p>
        Should you rebase? Merge? Squash? Cherry-pick?
    </p>
    <p>
        Often, being more explicit about a context can help address confusion.
    </p>
    <p>
        I know of at least two ways of using Git that differ so much from each other that I think we may term them two different regimes. The rules I follow in one regime don't all apply in the other, and vice versa.
    </p>
    <p>
        In this article I'll describe both regimes.
    </p>
    <h3 id="d0a8a4be292646719815e959011a0e9d">
        Collaboration <a href="#d0a8a4be292646719815e959011a0e9d">#</a>
    </h3>
    <p>
        Most people use Git because it facilitates collaboration. Like other source-control systems, it's a way to share a code base with coworkers, or open-source contributors. <a href="https://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration</a> is a subset in this category, and to my knowledge still the best way to collaborate.
    </p>
    <p>
        When I work in this regime, I follow one dominant rule: Once history is shared with others, it should be considered immutable. When you push to a shared instance of the repository, other people may pull your changes. Changing the history after having shared it is going to confuse most Git clients. It's much easier to abstain from editing shared history.
    </p>
    <p>
        What if you shared something that contains an error? Then fix the error and push that update, too. Sometimes, you can use <a href="https://git-scm.com/docs/git-revert">git revert</a> for this.
    </p>
    <p>
        A special case is reserved for mistakes that involve leaking security-sensitive data. If you accidentally share a password, a revert doesn't rectify the problem. The data is still in the history, so this is a singular case where I know of no better remedy than rewriting history. That is, however, quite bothersome, because you now need to communicate to every other collaborator that this is going to happen, and that they may be best off making a new clone of the repository. If there's a better way to address such situations, I don't know of it, but would be happy to learn.
    </p>
    <p>
        In GitHub, sending a pull request is a two-step process: First you push a branch, and then you click a button to send the pull request. I usually use the GitHub web user interface to review my own pull-request branch before pushing the button. Occasionally I spot an error. At this point I consider the branch 'unshared', so I may decide to rewrite the history of that branch and force-push it. Once, however, I've clicked the button and sent the pull request, I consider the branch shared, and the same rules apply: Rewriting history is not allowed.
    </p>
    <p>
        One implication of this is that the set of Git actions you need to know is small: You can effectively get by with <a href="https://git-scm.com/docs/git-add">git add</a>, <a href="https://git-scm.com/docs/git-commit">commit</a>, <a href="https://git-scm.com/docs/git-pull">pull</a>, <a href="https://git-scm.com/docs/git-push">push</a>, and possibly a few more.
    </p>
    <p>
        Many of the 'advanced' Git features, such as <a href="https://git-scm.com/docs/git-rebase">rebase</a> and squash, allow you to rewrite history, so aren't allowed in this regime.
    </p>
    <h3 id="513088e0595e493a94a6aa96fa0ae92d">
        Tactical Git <a href="#513088e0595e493a94a6aa96fa0ae92d">#</a>
    </h3>
    <p>
        As far as I can tell, Git wasn't originally created for this second use case, but it just turns out that it's incredibly useful for local management of code files. This is what I've previously described as <a href="https://stackoverflow.blog/2022/12/19/use-git-tactically/">Tactical Git</a>.
    </p>
    <p>
        Once you realize that you have a version-control system at your fingertips, the opportunities are manifold. You can perform experiments in a branch that only exists on your machine. You may, for example, test alternative API design ideas, implementations, etc. There's no reason to litter the code base with commented-out code because you're afraid that you'll need something later. Just commit it on a local branch. If it later turns out that the experiment didn't turn out to your liking, commit it anyway, but check out <code>master</code>. You'll leave the experiment on your local machine, and it's there if you need it later.
    </p>
    <p>
        You can even used failed experiments as evidence that a particular idea has undesirable consequences. Have you ever been in a situation where a coworker suggests a new way of doing things. You may have previously responded that you've already tried that, and it didn't work. How well did that answer go over with your coworker?
    </p>
    <p>
        He or she probably wasn't convinced.
    </p>
    <p>
        What if, however, you've <em>kept that experiment on your own machine?</em> Now you can say: "Not only have I already tried this, but I'm happy to share the relevant branch with you."
    </p>
    <p>
        You can see an example of that in listing 8.10 in <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a>. This code listing is based on a side-branch never merged into <code>master</code>. If you have the book, you also have access to the entire Git repository, and you can check for yourself that commit <code>0bb8068</code> is a dead-end branch named <code>explode-maitre-d-arguments</code>.
    </p>
    <p>
        Under the Tactical Git regime, you can also go back and edit mistakes when working on code that you haven't yet shared. I use <a href="https://www.industriallogic.com/blog/whats-this-about-micro-commits/">micro-commits</a>, so I tend to check in small commits often. Sometimes, as I'm working with the code, I notice that I made a mistake a few commits ago. Since I'm a neat freak, I often use interactive rebase to go back and correct my mistakes before sharing the history with anyone else. I don't do that to look perfect, but rather to leave behind a legible trail of changes. If I already know that I made a mistake before I've shared my code with anyone else, there's no reason to burden others with both the mistake and its rectification.
    </p>
    <p>
        In general, I aim to leave as nice a Git history as possible. This is not only for my collaborators' sake, but for my own, too. Legible Git histories and micro-commits make it easier to troubleshoot later, as <a href="/2020/10/05/fortunately-i-dont-squash-my-commits">this story demonstrates</a>.
    </p>
    <p>
        The toolset useful for Tactical Git is different than for collaboration. You still use <code>add</code> and <code>commit</code>, of course, but I also use (interactive) <code>rebase</code> often, as well as <a href="https://git-scm.com/docs/git-stash">stash</a> and <a href="https://git-scm.com/docs/git-branch">branch</a>. Only rarely do I need <a href="https://git-scm.com/docs/git-cherry-pick">cherry-pick</a>, but it's useful when I do need it.
    </p>
    <h3 id="47b93db51f6a422296ebbd3fb0439401">
        Conclusion <a href="#47b93db51f6a422296ebbd3fb0439401">#</a>
    </h3>
    <p>
        When discussing good Git practices, it's easy to misunderstand each other because there's more than one way to use Git. I know of at least two radically different modes: Collaboration and Tactical Git. The rules that apply under the Collaboration regime should not all be followed slavishly when in the Tactical Git regime. Specifically, the rule about rewriting history is almost turned on its head. Under the Collaboration regime, do not rewrite Git history; under the Tactical Git regime, rewriting history is encouraged.
    </p>
</div>