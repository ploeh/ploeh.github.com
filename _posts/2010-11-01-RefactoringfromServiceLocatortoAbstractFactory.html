---
layout: post
tags: [Dependency Injection, Software Design]
date: 2010-11-01 19:43:24 UTC
title: "Refactoring from Service Locator to Abstract Factory"
comments: true
---
{% include JB/setup %}

<div id="post">
	<p>One of the readers of <a href="http://affiliate.manning.com/idevaffiliate.php?id=1150_236">my book</a> recently asked me an interesting question that relates to the disadvantages of the <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorIsAnAntiPattern.aspx">Service Locator</a> anti-pattern. I found both the question and the potential solution so interesting that I would like to share it.</p> <p>In short, the reader's organization currently uses Service Locator in their code, but don't really see a way out of it. This post demonstrates how we can refactor from Service Locator to <a href="http://en.wikipedia.org/wiki/Abstract_factory_pattern">Abstract Factory</a>. Here's the original question:</p> <blockquote> <p>“We have been writing a WCF middle tier using DI”</p> <p>“Our application talks to multiple databases.&nbsp; There is one Global database which contains Enterprise records, and each Enterprise has the connection string of a corresponding Enterprise database.”</p> <p>“The trick is when we want to write a service which connects to an Enterprise database.&nbsp; The context for which enterprise we are dealing with is not available until one of the service methods is called, so what we do is this:”</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">void</font></span> MyServiceOperation(<br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">EnterpriseContext</font></span> context)<br>{<br>&nbsp;&nbsp;&nbsp; </font></font><font face="Consolas"><font style="font-size: 12pt"><font color="#008000"><span>/* Get a Customer repository operating</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * in the given enterprise's context</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (database) */</span></font><br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> customerRepository = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.FindRepository&lt;<span><font color="#2b91af">Customer</font></span>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.EnterpriseId);<br>&nbsp;&nbsp;&nbsp; <span><font color="#008000">// ...</font></span><br>}</font></font></pre>
<p>“I'm not sure how, in this case, we can turn what we've got into a more pure DI system, since we have the dependency on the EnterpriseContext passed in to each service method.&nbsp; We are mocking and testing just fine, and seem reasonably well decoupled.&nbsp; Any ideas?”</p></blockquote>
<p>When we look at the FindRepository method we <a href="http://blog.ploeh.dk/2010/11/01/PatternRecognitionAbstractFactoryOrServiceLocator.aspx">quickly find that it's a Service Locator</a>. There are <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorIsAnAntiPattern.aspx">many problems with Service Locator</a>, but the general issue is that the generic argument can be one of an unbounded set of types.</p>
<p>The problem is that seen from the outside, the consuming type (MyService in the example) doesn't advertise its dependencies. In the example the dependency is a CustomerRepository, but you could later go into the implementation of MyServiceOperation and change the call to context.FindRepository&lt;Qux&gt;(context.EnterpriseId) and everything would still compile. However, at run-time, you'd likely get an exception.</p>
<p>It would be much safer to use an Abstract Factory, but how do we get there from here, and will it be better?</p>
<p>Let's see how we can do that. First, we'll have to make some assumptions on how EnterpriseContext works. In the following, I'll assume that it looks like this  -  warning: it's ugly, but that's the point, so don't give up reading just yet:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">class</font></span>&nbsp;<span><font color="#2b91af">EnterpriseContext</font></span><br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">private</font></span>&nbsp;<span><font color="#0000ff">readonly</font></span>&nbsp;<span><font color="#0000ff">int</font></span> enterpriseId;<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">private</font></span>&nbsp;<span><font color="#0000ff">readonly</font></span>&nbsp;<span><font color="#2b91af">IDictionary</font></span>&lt;<span><font color="#0000ff">int</font></span>, <span><font color="#0000ff">string</font></span>&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionStrings;<br> <br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">public</font></span> EnterpriseContext(<span><font color="#0000ff">int</font></span> enterpriseId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">this</font></span>.enterpriseId = enterpriseId;<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">this</font></span>.connectionStrings =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">new</font></span>&nbsp;<span><font color="#2b91af">Dictionary</font></span>&lt;<span><font color="#0000ff">int</font></span>, <span><font color="#0000ff">string</font></span>&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">this</font></span>.connectionStrings[1] = <span><font color="#a31515">"Foo"</font></span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">this</font></span>.connectionStrings[2] = <span><font color="#a31515">"Bar"</font></span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">this</font></span>.connectionStrings[3] = <span><font color="#a31515">"Baz"</font></span>;<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">public</font></span>&nbsp;<span><font color="#0000ff">virtual</font></span>&nbsp;<span><font color="#0000ff">int</font></span> EnterpriseId<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">get</font></span> { <span><font color="#0000ff">return</font></span>&nbsp;<span><font color="#0000ff">this</font></span>.enterpriseId; }<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">public</font></span>&nbsp;<span><font color="#0000ff">virtual</font></span>&nbsp;<span><font color="#2b91af">IRepository</font></span>&lt;T&gt; FindRepository&lt;T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">int</font></span> enterpriseId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">if</font></span> (<span><font color="#0000ff">typeof</font></span>(T) == <span><font color="#0000ff">typeof</font></span>(<span><font color="#2b91af">Customer</font></span>))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">return</font></span> (<span><font color="#2b91af">IRepository</font></span>&lt;T&gt;)<span><font color="#0000ff">this</font></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .FindCustomerRepository(enterpriseId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">if</font></span> (<span><font color="#0000ff">typeof</font></span>(T) == <span><font color="#0000ff">typeof</font></span>(<span><font color="#2b91af">Campaign</font></span>))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">return</font></span> (<span><font color="#2b91af">IRepository</font></span>&lt;T&gt;)<span><font color="#0000ff">this</font></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .FindCampaignRepository(enterpriseId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">if</font></span> (<span><font color="#0000ff">typeof</font></span>(T) == <span><font color="#0000ff">typeof</font></span>(<span><font color="#2b91af">Product</font></span>))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">return</font></span> (<span><font color="#2b91af">IRepository</font></span>&lt;T&gt;)<span><font color="#0000ff">this</font></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .FindProductRepository(enterpriseId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">throw</font></span>&nbsp;<span><font color="#0000ff">new</font></span>&nbsp;<span><font color="#2b91af">InvalidOperationException</font></span>(<span><font color="#a31515">"..."</font></span>);<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">private</font></span>&nbsp;<span><font color="#2b91af">IRepository</font></span>&lt;<span><font color="#2b91af">Campaign</font></span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FindCampaignRepository(<span><font color="#0000ff">int</font></span> enterpriseId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> cs = <span><font color="#0000ff">this</font></span>.connectionStrings[enterpriseId];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">return</font></span>&nbsp;<span><font color="#0000ff">new</font></span>&nbsp;<span><font color="#2b91af">CampaignRepository</font></span>(cs);<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">private</font></span>&nbsp;<span><font color="#2b91af">IRepository</font></span>&lt;<span><font color="#2b91af">Customer</font></span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FindCustomerRepository(<span><font color="#0000ff">int</font></span> enterpriseId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> cs = <span><font color="#0000ff">this</font></span>.connectionStrings[enterpriseId];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">return</font></span>&nbsp;<span><font color="#0000ff">new</font></span>&nbsp;<span><font color="#2b91af">CustomerRepository</font></span>(cs);<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">private</font></span>&nbsp;<span><font color="#2b91af">IRepository</font></span>&lt;<span><font color="#2b91af">Product</font></span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FindProductRepository(<span><font color="#0000ff">int</font></span> enterpriseId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> cs = <span><font color="#0000ff">this</font></span>.connectionStrings[enterpriseId];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">return</font></span>&nbsp;<span><font color="#0000ff">new</font></span>&nbsp;<span><font color="#2b91af">ProductRepository</font></span>(cs);<br>&nbsp;&nbsp;&nbsp; }<br>}</font></font></pre>
<p>That's pretty horrible, but that's exactly the point. Every time we need to to add a new type of repository, we'll need to modify this class, so it's one big violation of the <a href="http://en.wikipedia.org/wiki/Open/closed_principle">Open/Closed Principle</a>.</p>
<blockquote>
<p>I didn't implement EnterpriseContext with a DI Container on purpose. Yes: using a DI Container would make it <em>appear</em> less ugly, but it would only <em>hide</em> the design issue  -  not address it. I chose the above implementation to demonstrate just how ugly this sort of design really is.</p></blockquote>
<p>So, let's start refactoring.</p>
<p><strong>Step 1</strong></p>
<p>We change <em>each</em> of the private finder methods to public methods.</p>
<blockquote>
<p>In this example, there are only three methods, but I realize that in a real system there might be many more. However, we'll end up with only a single interface and its implementation, so don't despair just yet. It'll turn out just fine.</p></blockquote>
<p>As a single example the FindCustomerRepository method is shown here:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#2b91af">IRepository</font></span>&lt;<span><font color="#2b91af">Customer</font></span>&gt;<br>&nbsp;&nbsp;&nbsp; FindCustomerRepository(<span><font color="#0000ff">int</font></span> enterpriseId)<br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> cs = <span><font color="#0000ff">this</font></span>.connectionStrings[enterpriseId];<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">return</font></span>&nbsp;<span><font color="#0000ff">new</font></span>&nbsp;<span><font color="#2b91af">CustomerRepository</font></span>(cs);<br>}</font></font></pre>
<p>For <em>each</em> of the methods we extract an interface, like this:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">interface</font></span>&nbsp;<span><font color="#2b91af">ICustomerRepositoryFinder</font></span><br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">int</font></span> EnterpriseId { <span><font color="#0000ff">get</font></span>; }<br> <br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">IRepository</font></span>&lt;<span><font color="#2b91af">Customer</font></span>&gt; FindCustomerRepository(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">int</font></span> enterpriseId);<br>}</font></font></pre>
<p>We also include the EnterpriseId property because we'll need it soon. This is just an intermediary artifact which is not going to survive until the end.</p>
<blockquote>
<p>This is very reminiscent of the steps described by <a href="http://www.udidahan.com/">Udi Dahan</a> in his excellent talk <a href="http://www.infoq.com/presentations/Making-Roles-Explicit-Udi-Dahan">Intentions &amp; Interfaces: Making patterns concrete</a>. We make the <em>roles</em> of finding repositories explicit.</p></blockquote>
<p>This leaves us with three distinct interfaces that EnterpriseContext can implement:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">class</font></span>&nbsp;<span><font color="#2b91af">EnterpriseContext</font></span> : <br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">ICampaignRepositoryFinder</font></span>,<br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">ICustomerRepositoryFinder</font></span>,<br>&nbsp;&nbsp;&nbsp; </font><span><font style="font-size: 12pt" color="#2b91af">IProductRepositoryFinder</font></span></font></pre>
<p>Until now, we haven't touched the service.</p>
<p><strong>Step 2</strong></p>
<p>We can now change the implementation of MyServiceOperation to explicitly require only the role that it needs:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">void</font></span> MyServiceOperation(<br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">ICustomerRepositoryFinder</font></span> finder)<br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> customerRepository = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finder.FindCustomerRepository(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finder.EnterpriseId);<br>}</font></font></pre>
<p>Since we now only consume the strongly typed role interfaces, we can now delete the original FindRepository&lt;T&gt; method from EnterpriseContext.</p>
<p><strong>Step 3</strong></p>
<p>At this point, we're actually already done, since <a href="http://blog.ploeh.dk/2010/11/01/PatternRecognitionAbstractFactoryOrServiceLocator.aspx">ICustomerRepositoryFinder is an Abstract Factory</a>, but we can make the API even better. When we consider the implementation of MyServiceOperation, it should quickly become clear that there's a sort of local <a href="http://c2.com/cgi/wiki?FeatureEnvySmell">Feature Envy</a> in play. Why do we need to access finder.EnterpriseId to invoke finder.FindCustomerRepository? Shouldn't it rather be the finder's own responsibility to figure that out for us?</p>
<p>Instead, let us change the implementation so that the method does not need the enterpriseId parameter:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#2b91af">IRepository</font></span>&lt;<span><font color="#2b91af">Customer</font></span>&gt; FindCustomerRepository()<br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> cs = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">this</font></span>.connectionStrings[<span><font color="#0000ff">this</font></span>.EnterpriseId];<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">return</font></span>&nbsp;<span><font color="#0000ff">new</font></span>&nbsp;<span><font color="#2b91af">CustomerRepository</font></span>(cs);<br>}</font></font></pre>
<p>Notice that the EnterpriseId can be accessed just as well from the implementation of the method itself. This change requires us to also change the interface:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">interface</font></span>&nbsp;<span><font color="#2b91af">ICustomerRepositoryFinder</font></span><br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">IRepository</font></span>&lt;<span><font color="#2b91af">Customer</font></span>&gt; FindCustomerRepository();<br>}</font></font></pre>
<p>Notice that we removed the EnterpriseId property, as well as the enterpriseId parameter. The fact that there's an enterprise ID in play is now an implementation detail.</p>
<p>MyServiceOperation now looks like this:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">void</font></span> MyServiceOperation(<br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">ICustomerRepositoryFinder</font></span> finder)<br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> customerRepository = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finder.FindCustomerRepository();<br>}</font></font></pre>
<p>This takes care of the Feature Envy smell, but still leaves us with a lot of very similarly looking interfaces: ICampaignRepositoryFinder, ICustomerRepositoryFinder and IProductRepositoryFinder.</p>
<p><strong>Step 4</strong></p>
<p>We can collapse all the very similar interfaces into a single generic interface:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">interface</font></span>&nbsp;<span><font color="#2b91af">IRepositoryFinder</font></span>&lt;T&gt;<br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">IRepository</font></span>&lt;T&gt; FindRepository();<br>}</font></font></pre>
<p>With that, MyServiceOperation now becomes:</p><pre style="font-family: "><font face="Consolas"><span><font color="#0000ff"><font style="font-size: 12pt">public</font></font></span><font style="font-size: 12pt">&nbsp;<span><font color="#0000ff">void</font></span> MyServiceOperation(<br>&nbsp;&nbsp;&nbsp; <span><font color="#2b91af">IRepositoryFinder</font></span>&lt;<span><font color="#2b91af">Customer</font></span>&gt; finder)<br>{<br>&nbsp;&nbsp;&nbsp; <span><font color="#0000ff">var</font></span> customerRepository = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finder.FindRepository();<br>}</font></font></pre>
<p>Now that we only have a single generic interface (which is still an Abstract Factory), we can seriously consider getting rid of all the very similarly looking implementations in EnterpriseContext and instead just create a single generic class. We now have a more explicit API that better communicates intent.</p>
<p>How is this better? What if a method needs both an IRepository&lt;Customer&gt; and an IRepository&lt;Product&gt;? We'll now have to pass two parameters instead of one.</p>
<p>Yes, but that's good because it explicitly calls to your attention exactly which collaborators are involved. With the original Service Locator, you might not notice the responsibility creep as you over time request more and more repositories from the EnterpriseContext. With Abstract Factories in play, violations of the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> (SRP) becomes much more obvious.</p>
<blockquote>
<p>Refactoring from Service Locator to Abstract Factories make it more painful to violate the SRP.</p></blockquote>
<p>You can always make roles explicit to get rid of Service Locators. This is likely to result in a more explicit design where doing the right thing feels more natural than doing the wrong thing.</p>
</div>
	