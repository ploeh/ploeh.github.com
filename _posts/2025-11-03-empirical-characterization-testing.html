---
layout: post
title: "Empirical Characterization Testing"
description: "Gathering empirical evidence while adding tests to legacy code."
date: 2025-11-03 13:08 UTC
tags: [Unit Testing]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        This article is part of a short series on <a href="/2025/10/27/empirical-test-after-development">empirical test-after techniques</a>. Sometimes, test-driven development (TDD) is impractical. This often happens when faced with legacy code. Although there's a dearth of hard data, I guess that most code in the world falls into this category. Other <a href="https://x.com/hillelogram/status/1445435617047990273">software thought leaders</a> seem to suggest the same notion.
    </p>
    <p>
        For the purposes of this discussion, the definition of <em>legacy code</em> is code without automated tests.
    </p>
    <blockquote>
        <p>
            "Code without tests is bad code. It doesn't matter how well written it is; it doesn't matter how pretty or object-oriented or well-encapsulated it is. With tests, we can change the behavior of our code quickly and verifiably. Without them, we really don't know if our code is getting better or worse."
        </p>
        <footer><a href="/ref/wewlc">Working Effectively with Legacy Code</a>, preface, Michael C. Feathers, Prentice Hall, 2005</footer>
    </blockquote>
    <p>
        As Michael Feathers suggest, the accumulation of knowledge is at the root of this definition. As I outlined in <a href="/2025/10/20/epistemology-of-software">Epistemology of software</a>, tests are the source of empirical evidence. In principle it's possible to apply a rigorous testing regimen with manual testing, but in most cases this is (also) impractical for reasons that are different from the barriers to automated testing. In the rest of this article, I'll exclusively discuss automated testing.
    </p>
    <p>
        We may reasonably extend the definition of legacy code to a code base without adequate testing support.
    </p>
    <h3 id="53c15894a2b14adcb0f6f2476fedbd52">
        When do we have enough tests? <a href="#53c15894a2b14adcb0f6f2476fedbd52">#</a>
    </h3>
    <p>
        What, exactly, is <em>adequate testing support?</em> The answer is the same as in science, overall. When do you have enough scientific evidence that a particular theory is widely accepted? There's no universal answer to that, and no, <a href="https://xkcd.com/882/">p-values less than 0.05 isn't the answer, either</a>.
    </p>
    <p>
        In short, adequate empirical evidence is when a hypothesis is sufficiently corroborated to be accepted. Keep in mind that science can never prove a theory correct, but performing experiments against <a href="https://en.wikipedia.org/wiki/Falsifiability">falsifiable</a> predictions can disprove it. This applies to software, too.
    </p>
    <blockquote>
        <p>
            "Testing shows the presence, not the absence of bugs."
        </p>
        <footer><cite>Software Engineering Techniques, April 1970. Report on a conference sponsored by the NATO Science Committee</cite>, Edsger W. Dijkstra, Rome, Italy, 1969.</footer>
    </blockquote>
    <p>
        The terminology of hypothesis, corroboration, etc. may be opaque to many software developers. Here's what it means in terms of software engineering: You have unspoken and implicit hypotheses about the code you're writing. Usually, once you're done with a task, your hypothesis is that the code makes the software work as intended. Anyone who's written more than a <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">hello-world program</a> knows, however, that believing the code to be correct is not enough. How many times have you written code that you assumed correct, only to find that it was not?
    </p>
    <p>
        That's the lack of knowledge that testing attempts to address. Even manual testing. A test is an experiment that produces empirical evidence. As Dijkstra quipped, passing tests don't prove the software correct, but the more passing tests we have, the more confidence we gain. <a href="/2018/11/12/what-to-test-and-not-to-test">At some point</a>, the passing tests provide enough confidence that you and other stakeholders consider it sensible to release or deploy the software. We say that the failure to find failing tests corroborates our hypothesis that the software works as intended.
    </p>
    <p>
        In the context of legacy code, it's not the absolute lack of automated tests that characterizes legacy code. Rather, it's the lack of adequate test coverage. It's that you don't have enough tests. Thus, when working with legacy code, you want to add tests after the fact.
    </p>
    <h3 id="beab7a226a9148ac84147bf5f7cc941a">
        Characterization Test recipes <a href="#beab7a226a9148ac84147bf5f7cc941a">#</a>
    </h3>
    <p>
        A test written after the fact against a legacy code base is called a Characterization Test, because it characterizes (i.e. describes) the behaviour of the system under test (SUT) at the time it was written. It's not a given that this behaviour is correct or desirable.
    </p>
    <p>
        Michael Feathers gives this recipe for writing a Characterization Test:
    </p>
    <blockquote>
        <ol>
            <li>"Use a piece of code in a test harness.</li>
            <li>"Write an assertion that you know will fail.</li>
            <li>"Let the failure tell you what the behavior is.</li>
            <li>"Change the test so that it expects the behavior that the code produces.</li>
            <li>"Repeat."</li>
        </ol>
        <footer><a href="/ref/wewlc">Working Effectively with Legacy Code</a>, ch. 13, Michael C. Feathers, Prentice Hall, 2005</footer>
    </blockquote>
    <p>
        Notice the second step: "Write an assertion that you know will fail." Why is that important? Why not write the 'correct' assertion from the outset?
    </p>
    <p>
        The reason is the same as I outlined in <a href="/2025/10/20/epistemology-of-software">Epistemology of software</a>: It happens with surprising regularity that you inadvertently write a <a href="/2019/10/14/tautological-assertion">tautological assertion</a>. You could also make other mistakes, but writing a failing test is a falsifiable experiment. In this case, the implied hypothesis is that the test will fail. If it does <em>not</em> fail, you've falsified the implied prediction. To paraphrase Dijkstra, you've proven the test wrong.
    </p>
    <p>
        If, on the other hand, the test fails, you've failed to falsify the hypothesis. You have not proven the test correct, but you've failed in proving it wrong. Epistemologically, that's the best result you may hope for.
    </p>
    <p>
        I'm a little uneasy about the above recipe, because it involves a step where you change the test code to pass the test. How can you know that you, without meaning to, replaced a proper assertion with a tautological assertion?
    </p>
    <p>
        For that reason, I sometimes follow a variation of the recipe:
    </p>
    <ol>
        <li>Write a test that exercises the SUT, including the correct assertion you have in mind.</li>
        <li>Run the test to see it pass.</li>
        <li>Sabotage the SUT so that it fails the assertion. If there are several assertions, do this for each, one after the other.</li>
        <li>Run the test to see it fail.</li>
        <li>Revert the sabotage.</li>
        <li>Run the test again to see it pass.</li>
        <li>Repeat.</li>
    </ol>
    <p>
        The last test run is strictly not necessary if you've been rigorous about how you revert the sabotage, but psychologically, it gives me a better sense that all is good if I can end each cycle with a green test suite.
    </p>
    <h3 id="7a6abd81fbc541bab29122b0f99484e5">
        Example <a href="#7a6abd81fbc541bab29122b0f99484e5">#</a>
    </h3>
    <p>
        I don't get to interact that much with legacy code, but even so, I find myself writing Characterization Tests with surprising regularity. One example was when I was <a href="/2025/04/10/characterising-song-recommendations">characterizing the song recommendations example</a>. If you have the Git repository that accompanies that article series, you can see that the initial setup is adding one Characterization Test after the other. Even so, as I follow a policy of not adding commits with failing tests, you can't see the details of the process leading to each commit.
    </p>
    <p>
        Perhaps a better example can be found in the Git repository that accompanies <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a>. If you own the book, you also have access to the repository. In commit <code>d66bc89443dc10a418837c0ae5b85e06272bd12b</code> I wrote this message:
    </p>
    <blockquote>
        <p>
            "Remove PostOffice dependency from Controller
        </p>
        <p>
            "Instead, the PostOffice behaviour is now the responsibility of the EmailingReservationsRepository Decorator, which is configured in Startup.
        </p>
        <p>
            "I meticulously edited the unit tests and introduced new unit tests as necessary. All new unit tests I added by following the checklist for Characterisation Tests, including seeing all the assertions fail by temporarily editing the SUT."
        </p>
        <footer>Git repository accompanying <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a>, me, 2020</footer>
    </blockquote>
    <p>
        Notice the last paragraph, which is quite typical for how I tend to document my process when it's otherwise invisible in the Git history. Here's a breakdown of the process.
    </p>
    <p>
        I first created the <code>EmailingReservationsRepository</code> without tests. This class is a <a href="https://en.wikipedia.org/wiki/Decorator_pattern">Decorator</a>, so quite a bit of it is boilerplate code. For instance, one method looks like this:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Task</span>&lt;<span style="color:#2b91af;">Reservation</span>?&gt;&nbsp;<span style="font-weight:bold;color:#74531f;">ReadReservation</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="color:#2b91af;">Guid</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">id</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;Inner.<span style="font-weight:bold;color:#74531f;">ReadReservation</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">id</span>);
}</pre>
    </p>
    <p>
        That's usually the case with such Decorators, but then one of the methods turned out like this:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Update</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="color:#2b91af;">Reservation</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">reservation</span>&nbsp;<span style="color:blue;">is</span>&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(<span style="font-weight:bold;color:#1f377f;">reservation</span>));
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">existing</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;Inner.<span style="font-weight:bold;color:#74531f;">ReadReservation</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.Id)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">existing</span>&nbsp;<span style="color:blue;">is</span>&nbsp;{&nbsp;}&nbsp;&amp;&amp;&nbsp;<span style="font-weight:bold;color:#1f377f;">existing</span>.Email&nbsp;<span style="font-weight:bold;color:#74531f;">!=</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.Email)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;PostOffice
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">EmailReservationUpdating</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">existing</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;Inner.<span style="font-weight:bold;color:#74531f;">Update</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;PostOffice.<span style="font-weight:bold;color:#74531f;">EmailReservationUpdated</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);
}</pre>
    </p>
    <p>
        I then realized that I should probably cover this class with some tests after all, which I then proceeded to do in the above commit.
    </p>
    <p>
        Consider one of the <a href="/2019/02/18/from-interaction-based-to-state-based-testing">state-based</a> Characterisation Tests I added to cover the <code>Update</code> method.
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Theory</span>]
[<span style="color:#2b91af;">InlineData</span>(32,&nbsp;<span style="color:#a31515;">&quot;David&quot;</span>)]
[<span style="color:#2b91af;">InlineData</span>(58,&nbsp;<span style="color:#a31515;">&quot;Robert&quot;</span>)]
[<span style="color:#2b91af;">InlineData</span>(58,&nbsp;<span style="color:#a31515;">&quot;Jones&quot;</span>)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;<span style="font-weight:bold;color:#74531f;">UpdateSendsEmail</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">newName</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">postOffice</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SpyPostOffice</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">existing</span>&nbsp;=&nbsp;<span style="color:#2b91af;">Some</span>.Reservation;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">db</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">FakeDatabase</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">db</span>.<span style="font-weight:bold;color:#74531f;">Create</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">existing</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">EmailingReservationsRepository</span>(<span style="font-weight:bold;color:#1f377f;">postOffice</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">db</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">updated</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">existing</span>.<span style="font-weight:bold;color:#74531f;">WithName</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Name</span>(<span style="font-weight:bold;color:#1f377f;">newName</span>));
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>.<span style="font-weight:bold;color:#74531f;">Update</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">updated</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SpyPostOffice</span>.<span style="color:#2b91af;">Observation</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">SpyPostOffice</span>.<span style="color:#2b91af;">Event</span>.Updated,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">updated</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Contains</span>(<span style="font-weight:bold;color:#1f377f;">updated</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">db</span>[<span style="font-weight:bold;color:#1f377f;">restaurantId</span>]);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Contains</span>(<span style="font-weight:bold;color:#1f377f;">expected</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">postOffice</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">DoesNotContain</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">postOffice</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">o</span>&nbsp;=&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">o</span>.Event&nbsp;==&nbsp;<span style="color:#2b91af;">SpyPostOffice</span>.<span style="color:#2b91af;">Event</span>.Updating);
}</pre>
    </p>
    <p>
        This test immediately passed when I added it, so I had to sabotage the <code>Update</code> method to see the assertions fail. Since there are three assertions, I had to sabotage the SUT in three different ways.
    </p>
    <p>
        To see the first assertion fail, the most obvious sabotage was to simply comment out or delete the delegation to <code>Inner.Update</code>:
    </p>
    <p>
        <pre><span style="color:green;">//await&nbsp;Inner.Update(restaurantId,&nbsp;reservation)</span>
<span style="color:green;">//&nbsp;&nbsp;&nbsp;&nbsp;.ConfigureAwait(false);</span></pre>
    </p>
    <p>
        This caused the first assertion to fail. I was sure to actually look at the error message and follow the link to the test failure to make sure that it was, indeed, <em>that</em> assertion that was failing, and not something else. Once I had that verified, I undid the sabotage.
    </p>
    <p>
        With the SUT back to unedited state, it was time to sabotage the second assertion. Just like <code>FakeDatabase</code> inherits from <a href="https://learn.microsoft.com/dotnet/api/system.collections.concurrent.concurrentdictionary-2">ConcurrentDictionary</a>, <code>SpyPostOffice</code> inherits from <a href="https://learn.microsoft.com/dotnet/api/system.collections.objectmodel.collection-1">Collection</a>, which means that the assertion can simply verify whether the <code>postOffice</code> contains the <code>expected</code> observation. Sabotaging that part was as easy as the first one:
    </p>
    <p>
        <pre><span style="color:green;">//await&nbsp;PostOffice.EmailReservationUpdated(restaurantId,&nbsp;reservation)</span>
<span style="color:green;">//&nbsp;&nbsp;&nbsp;&nbsp;.ConfigureAwait(false);</span></pre>
    </p>
    <p>
        The test failed, but again I meticulously verified that the error was the expected error at the expected line. Once I'd done that, I again reverted the SUT to its virgin state, and ran the test to verify that all tests passed.
    </p>
    <p>
        The last assertion is a bit different, because it checks that no <code>Updating</code> message is being sent. This should only happen if the user updates the reservation by changing his or her email address. In that case, but only in that case, should the system send an <code>Updating</code> message to the old address, and an <code>Updated</code> message to the new address. There's a separate test for that, but as it follows the same overall template as the one shown here, I'm not showing it. You can see it in the Git repository.
    </p>
    <p>
        Here's how to sabotage the SUT to see the third assertion fail:
    </p>
    <p>
        <pre><span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">existing</span>&nbsp;<span style="color:blue;">is</span>&nbsp;{&nbsp;}&nbsp;<span style="color:green;">/*&amp;&amp;&nbsp;existing.Email&nbsp;!=&nbsp;reservation.Email*/</span>)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;PostOffice
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">EmailReservationUpdating</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">existing</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);</pre>
    </p>
    <p>
        It's enough to comment out (or delete) the second Boolean check to fail the assertion. Again, I made sure to check that the test failed on the exact line of the third assertion. Once I'd made sure of that, I undid the change, ran the tests again, and committed the changes.
    </p>
    <h3 id="b2fd9167c4c24950ac7ba47df057af63">
        Conclusion <a href="#b2fd9167c4c24950ac7ba47df057af63">#</a>
    </h3>
    <p>
        When working with automated tests, a classic conundrum is that you're writing code to test some other code. How do you know that the test code is correct? After all, you're writing test code because you don't trust your abilities to produce perfect production code. The way out of that quandary is to first predict that the test will fail and run that experiment. If you haven't touched the production code, but the test passes, odds are that there's something wrong with the test.
    </p>
    <p>
        When you are adding tests to an existing code base, you can't perform that experiment without jumping through some hoops. After all, the behaviour you want to observe is already implemented. You must therefore either write a variation of a test that deliberately fails (as Michael Feathers recommends), or temporarily sabotage the system under test so that you can verify that the new test fails as expected.
    </p>
    <p>
        The example shows how to proceed empirically with a Characterisation Test of a C# class that I'd earlier added without tests. Perhaps, however, I should have rather approached the situation in another way.
    </p>
    <p>
        <strong>Next:</strong> Empirical software prototyping.
    </p>
</div>