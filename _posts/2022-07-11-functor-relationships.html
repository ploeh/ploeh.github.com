---
layout: post
title: "Functor relationships"
description: "Sometimes you need to use more than one functor together."
date: 2022-07-11 8:09 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		This article series is part of <a href="/2018/03/19/functors-applicatives-and-friends">a larger series of articles about functors, applicatives, and other mappable containers</a>. Particularly, you've seen examples of both <a href="/2018/03/22/functors">functors</a> and <a href="/2018/10/01/applicative-functors">applicative functors</a>.
	</p>
	<p>
		There are situations where you can get by with a single functor. Many languages come with list comprehensions or other features to work with collections of values (C#, for instance, has <em>language-integrated query</em>, or: LINQ). The <a href="/2022/04/19/the-list-monad">list functor (and monad)</a> gives you a comprehensive API to manipulate multiple values. Likewise, you may write some parsing (<a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate">or validation</a>) that exclusively uses the <a href="/2019/01/14/an-either-functor">Either functor</a>.
	</p>
	<p>
		At other times, however, you may find yourself having to juggle more than one functor at once. Perhaps you are working with Either values, but one existing API returns <a href="/2018/03/26/the-maybe-functor">Maybe</a> values instead. Or perhaps you need to deal with Either values, but you're already working within <a href="/2018/09/24/asynchronous-functors">an asynchronous functor</a>.
	</p>
	<p>
		There are several standard ways you can combine or transform combinations of functors.
	</p>
	<h3 id="70383da35af346f6b2dc3095a1bf7273">
		A partial catalogue <a href="#70383da35af346f6b2dc3095a1bf7273" title="permalink">#</a>
	</h3>
	<p>
		The following relationships often come in handy - particularly those that top this list:
	</p>
	<ul>
		<li><a href="/2022/07/18/natural-transformations">Natural transformations</a></li>
		<li><a href="/2024/09/16/functor-products">Functor products</a></li>
		<li>Functor sums</li>
		<li>Functor compositions</li>
		<li>Traversals</li>
	</ul>
	<p>
		This list is hardly complete, and I may add to it in the future. Compared to some of the other subtopics of <a href="/2017/10/04/from-design-patterns-to-category-theory">the larger articles series on universal abstractions</a>, this catalogue is more heterogeneous. It collects various ways that functors can relate to each other, but uses disparate concepts and abstractions, rather than a single general idea (like a <a href="/2018/12/24/bifunctors">bifunctor</a>, <a href="/2017/10/06/monoids">monoid</a>, or <a href="/2019/04/29/catamorphisms">catamorphism</a>).
	</p>
	<p>
		Keep in mind when reading these articles that all <a href="/2022/03/28/monads">monads</a> are also functors and applicative functors, so what applies to functors also applies to monads.
	</p>
	<h3 id="1a4f0850f8974b59ab44eed352b0daf7">
		Conclusion <a href="#1a4f0850f8974b59ab44eed352b0daf7" title="permalink">#</a>
	</h3>
	<p>
		You can use a single functor in isolation, or you can combine more than one. Most of the relationships described in this articles series work for all (lawful) functors, but traversals require applicative functors and functors that are 'foldable' (i.e. a catamorphism exists).
	</p>
	<p>
		<strong>Next:</strong> <a href="/2022/07/18/natural-transformations">Natural transformations</a>.
	</p>
</div>